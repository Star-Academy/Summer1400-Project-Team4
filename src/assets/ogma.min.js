/**
 * Ogma
 * @description Graph visualization library
 * @version 2.9.3 (built on Wed Jan 08 2020 19:06:20 GMT+0100 (Central European Standard Time))
 * @author Linkurious SAS
 * @license (c) Linkurious 2020. All rights reserved.
 * @preserve
 */
/* eslint-disable */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = t || self).Ogma = e() }(this, function () {
    "use strict"; function d(t) { return "function" == typeof t || "[object Function]" === e.call(t) } function h(value) { var t = function (value) { var t = Number(value); return isNaN(t) ? 0 : 0 !== t && isFinite(t) ? (0 < t ? 1 : -1) * Math.floor(Math.abs(t)) : t }(value); return Math.min(Math.max(t, 0), i) } var e, i; Array.prototype.fill || Object.defineProperty(Array.prototype, "fill", { value: function (value) { if (null == this) throw new TypeError("this is null or not defined"); for (var t = Object(this), e = t.length >>> 0, i = arguments[1] >> 0, n = i < 0 ? Math.max(e + i, 0) : Math.min(i, e), r = arguments[2], o = void 0 === r ? e : r >> 0, s = o < 0 ? Math.max(e + o, 0) : Math.min(o, e); n < s;)t[n] = value, n++; return t } }), Array.prototype.copyWithin || (Array.prototype.copyWithin = function (t, e) { if (null == this) throw new TypeError("this is null or not defined"); var i = Object(this), n = i.length >>> 0, r = t >> 0, o = r < 0 ? Math.max(n + r, 0) : Math.min(r, n), s = e >> 0, a = s < 0 ? Math.max(n + s, 0) : Math.min(s, n), u = arguments[2], l = void 0 === u ? n : u >> 0, d = l < 0 ? Math.max(n + l, 0) : Math.min(l, n), h = Math.min(d - a, n - o), c = 1; for (a < o && o < a + h && (c = -1, a += h - 1, o += h - 1); 0 < h;)a in i ? i[o] = i[a] : delete i[o], a += c, o += c, h--; return i }), Array.prototype.lastIndexOf || (Array.prototype.lastIndexOf = function (t) { if (null == this) throw new TypeError; var e = Object(this), i = e.length >>> 0; if (0 == i) return -1; var n = i - 1; 1 < arguments.length && ((n = Number(arguments[1])) != n ? n = 0 : 0 != n && n != 1 / 0 && n != -1 / 0 && (n = (0 < n ? 1 : -1) * Math.floor(Math.abs(n)))); for (var r = 0 <= n ? Math.min(n, i - 1) : i - Math.abs(n); 0 <= r; r--)if (r in e && e[r] === t) return r; return -1 }), Array.from || (Array.from = (e = Object.prototype.toString, i = Math.pow(2, 53) - 1, function (t, e, i) { var n = Object(t); if (null == t) throw new TypeError("Array.from requires an array-like object - not null or undefined"); var r, o = 1 < arguments.length ? e : void 0; if (void 0 !== o) { if (!d(o)) throw new TypeError("Array.from: when provided, the second argument must be a function"); 2 < arguments.length && (r = i) } for (var s, a = h(n.length), u = d(this) ? Object(new this(a)) : new Array(a), l = 0; l < a;)s = n[l], u[l] = o ? void 0 === r ? o(s, l) : o.call(r, s, l) : s, l += 1; return u.length = a, u })), Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", { value: function (t, e) { if (null == this) throw new TypeError('"this" is null or not defined'); var i = Object(this), n = i.length >>> 0; if (0 == n) return !1; var r, o, s = 0 | e, a = Math.max(0 <= s ? s : n - Math.abs(s), 0); for (; a < n;) { if ((r = i[a]) === (o = t) || "number" == typeof r && "number" == typeof o && isNaN(r) && isNaN(o)) return !0; a++ } return !1 } }), Array.prototype.find || Object.defineProperty(Array.prototype, "find", { value: function (t) { if (null == this) throw new TypeError('"this" is null or not defined'); var e = Object(this), i = e.length >>> 0; if ("function" != typeof t) throw new TypeError("predicate must be a function"); for (var n = arguments[1], r = 0; r < i;) { var o = e[r]; if (t.call(n, o, r, e)) return o; r++ } }, configurable: !0, writable: !0 }); var n = [Uint32Array, Uint16Array, Uint8Array, Int32Array, Int16Array, Int8Array, Float32Array, Float64Array], r = ["join", "slice", "reverse", "forEach", "map", "includes", "copyWithin", "reduce", "indexOf", "sort", "filter", "every", "some", "fill"]; ArrayBuffer.isView || (ArrayBuffer.isView = function (t) { for (var e = 0; e < n.length; ++e)if (t instanceof n[e]) return !0; return !1 }); for (var o, s = function (i) { return function (t, e) { return new i(Array.prototype.slice.call(this, t, e)) } }, t = function (a) { for (var t = 0, e = r; t < e.length; t++) { var i = e[t]; if (!a.prototype[i]) { var n = "slice" === i ? s(a) : Array.prototype[i]; a.prototype[i] = n } } a.from || (a.from = function (t, e, i) { var n = a.__proto__; if ("function" != typeof this) throw new TypeError("# is not a constructor"); if (this.__proto__ !== n) throw new TypeError("this is not a typed array."); if ("function" != typeof (e = e || function (t) { return t })) throw new TypeError("specified argument is not a function"); if (!(t = Object(t)).length) return new this(0); for (var r = [], o = 0; o < t.length; o++)r.push(t[o]); var s = new this((r = r.map(e, i)).length); for (o = 0; o < s.length; o++)s[o] = r[o]; return s }) }, a = 0, u = n; a < u.length; a++) { t(u[a]) } function l() { } function c(t) { if ("object" != typeof this) throw new TypeError("Promises must be constructed via new"); if ("function" != typeof t) throw new TypeError("not a function"); this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], m(t, this) } function f(i, n) { for (; 3 === i._state;)i = i._value; 0 !== i._state ? (i._handled = !0, c._immediateFn(function () { var t = 1 === i._state ? n.onFulfilled : n.onRejected; if (null !== t) { var e; try { e = t(i._value) } catch (t) { return void p(n.promise, t) } g(n.promise, e) } else (1 === i._state ? g : p)(n.promise, i._value) })) : i._deferreds.push(n) } function g(e, t) { try { if (t === e) throw new TypeError("A promise cannot be resolved with itself."); if (t && ("object" == typeof t || "function" == typeof t)) { var i = t.then; if (t instanceof c) return e._state = 3, e._value = t, void _(e); if ("function" == typeof i) return void m((n = i, r = t, function () { n.apply(r, arguments) }), e) } e._state = 1, e._value = t, _(e) } catch (t) { p(e, t) } var n, r } function p(t, e) { t._state = 2, t._value = e, _(t) } function _(t) { 2 === t._state && 0 === t._deferreds.length && c._immediateFn(function () { t._handled || c._unhandledRejectionFn(t._value) }); for (var e = 0, i = t._deferreds.length; e < i; e++)f(t, t._deferreds[e]); t._deferreds = null } function v(t, e, i) { this.onFulfilled = "function" == typeof t ? t : null, this.onRejected = "function" == typeof e ? e : null, this.promise = i } function m(t, e) { var i = !1; try { t(function (value) { i || (i = !0, g(e, value)) }, function (t) { i || (i = !0, p(e, t)) }) } catch (t) { if (i) return; i = !0, p(e, t) } } "undefined" == typeof CanvasRenderingContext2D || CanvasRenderingContext2D.prototype.setLineDash || (CanvasRenderingContext2D.prototype.setLineDash = function (t) { }), Math.log2 || (Math.log2 = function (t) { return Math.log(t) * Math.LOG2E }), Math.sign || (Math.sign = function (t) { return (0 < t ? 1 : 0) - (t < 0 ? 1 : 0) || +t }), Number.isNaN || (Number.isNaN = function (value) { return "number" == typeof value && isNaN(value) }), Number.MAX_SAFE_INTEGER || Object.defineProperty(Number, "MAX_SAFE_INTEGER", { enumerable: !1, configurable: !1, writable: !1, value: Math.pow(2, 53) - 1 }), o = setTimeout, c.prototype.catch = function (t) { return this.then(null, t) }, c.prototype.then = function (t, e) { var i = new this.constructor(l); return f(this, new v(t, e, i)), i }, c.all = function (t) { var a = Array.prototype.slice.call(t); return new c(function (n, r) { if (0 === a.length) return n([]); var o = a.length; function s(e, t) { try { if (t && ("object" == typeof t || "function" == typeof t)) { var i = t.then; if ("function" == typeof i) return void i.call(t, function (t) { s(e, t) }, r) } a[e] = t, 0 == --o && n(a) } catch (t) { r(t) } } for (var t = 0; t < a.length; t++)s(t, a[t]) }) }, c.resolve = function (value) { return value && "object" == typeof value && value.constructor === c ? value : new c(function (t) { t(value) }) }, c.reject = function (value) { return new c(function (t, e) { e(value) }) }, c.race = function (r) { return new c(function (t, e) { for (var i = 0, n = r.length; i < n; i++)r[i].then(t, e) }) }, c._immediateFn = "object" == typeof global && "function" == typeof global.setImmediate && function (t) { global.setImmediate(t) } || function (t) { o(t, 0) }, c._unhandledRejectionFn = function (t) { "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", t) }, c._setImmediateFn = function (t) { c._immediateFn = t }, c._setUnhandledRejectionFn = function (t) { c._unhandledRejectionFn = t }, "object" != typeof global || global.Promise || (global.exports = c), "object" != typeof window || "Promise" in window || (window.Promise = c), String.prototype.endsWith || (String.prototype.endsWith = function (t, e) { var i = this.toString(); ("number" != typeof e || !isFinite(e) || Math.floor(e) !== e || e > i.length) && (e = i.length), e -= t.length; var n = i.lastIndexOf(t, e); return -1 !== n && n === e }), String.prototype.startsWith || (String.prototype.startsWith = function (t, e) { return this.substr(e || 0, t.length) === t }), String.prototype.includes || (String.prototype.includes = function (t, e) { return "number" != typeof e && (e = 0), !(e + t.length > this.length) && -1 !== this.indexOf(t, e) }), "function" != typeof Object.assign && Object.defineProperty(Object, "assign", { value: function (t) { var e = arguments; if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var i = Object(t), n = 1; n < arguments.length; n++) { var r = e[n]; if (null != r) for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (i[o] = r[o]) } return i }, writable: !0, configurable: !0 }); var y = function (t, e) { return (y = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) })(t, e) }; function b(t, e) { function i() { this.constructor = t } y(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i) } var C = function () { return (C = Object.assign || function (t) { for (var e, i = arguments, n = 1, r = arguments.length; n < r; n++)for (var o in e = i[n]) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]); return t }).apply(this, arguments) }; function x(t, e) { var i = {}; for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) { var r = 0; for (n = Object.getOwnPropertySymbols(t); r < n.length; r++)e.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[r]) && (i[n[r]] = t[n[r]]) } return i } var E = {}, A = {}, S = {}, w = function (t) { return null }; if ("object" == typeof global && (A = global), "object" == typeof window && (S = window), "object" == typeof module && "function" == typeof module.require) { var T = module.require.bind(module); w = function (t) { try { return T(t) } catch (t) { return null } } } else "function" == typeof A.require && (w = function (t) { var e = module.require; try { return e(t) } catch (t) { return null } }); function M(t, e) { var i = (void 0 === e ? {} : e).throwOnError, n = null; if (!n && t && (n = E[t]), !n && t && (n = w(t)), !n && t && (n = S[t]), !n && t && (n = A[t]), n || !i) return n; var r = ['unable to find module "' + t + '"; make sure one of these statements is true:', "- Ogma.libraries['" + t + "'] is set to the right library", "- require('" + t + "') returns the right library", "- window['" + t + "'] is set to the right library"].join("\n"); throw new Error(r) } function X(t, e) { for (var i = 1, n = t.length; i < n; i++) { for (var r = t[i], o = i; 0 < o && e.get(t[o - 1]) > e.get(r);)t[o] = t[o - 1], --o; t[o] = r } return t } function At(t, e) { for (var i = 1, n = t.length; i < n; i++) { for (var r = t[i], o = i; 0 < o && e.get(t[o - 1]) < e.get(r);)t[o] = t[o - 1], --o; t[o] = r } return t } function I(value) { return Array.isArray(value) || ArrayBuffer.isView(value) } function L(value) { return Array.isArray(value) ? value : [value] } function N(t) { for (var e = [], i = 0; i < t.length; ++i) { var n = t[i]; if (Array.isArray(n)) for (var r = 0; r < n.length; ++r)e.push(n[r]); else e.push(n) } return e } function k(t, e) { var i = t.indexOf(e); return -1 !== i && (t.splice(i, 1), !0) } function O(t, e) { for (var i, n, r = 0, o = t.length - 1; r <= o;)if ((n = t[i = (r + o) / 2 | 0]) < e) r = 1 + i; else { if (!(e < n)) return i; o = i - 1 } return -1 } function F(t) { if (!t) return []; if ("string" == typeof t) return t.split("."); if (Array.isArray(t)) { for (var e = 0; e < t.length; ++e)if ("string" != typeof t[e]) throw new TypeError(t[e] + " is not a string"); return t.slice() } throw new TypeError('invalid property path "' + t + '": expected string or array of strings') } function R(e, i, n) { var r, o, t; if (0 === i) return function () { e.apply(n, arguments) }; function s() { r = !1, o && (t.apply(n, o), o = null) } return t = function () { var t; return r ? o = arguments : (t = e.apply(n, arguments), setTimeout(s, i), r = !0), t } } function P() { return 120 === new Uint8Array(new Uint32Array([305419896]).buffer)[0] } function D(t) { return t.reduce(function (t, e) { return t.then(e) }, Promise.resolve()) } function z(t, e, i, n, r, o, s, a) { return t + r + 256 * (e + o) + 65536 * (i + s) + 16777216 * (n + a) } function B(t) { return !(null === t || "object" != typeof t || I(t) || t instanceof RegExp || "undefined" != typeof HTMLElement && t instanceof HTMLElement) } function U(t) { for (var e = Object.keys(t), i = new Array(e.length), n = 0; n < e.length; ++n)i[n] = t[e[n]]; return i } function V(t, e, i) { if (Array.isArray(t)) return t.forEach(e, i); if (!B(t)) throw new Error("forEach: invalid argument " + JSON.stringify(t)); var n = Object.keys(t); if (void 0 !== i) for (var r = 0; r < n.length; ++r) { var o = n[r]; e.call(i, t[o], o) } else for (r = 0; r < n.length; ++r) { e(t[o = n[r]], o) } } function j(t) { if (Array.isArray(t)) { for (var e = new Array(t.length), i = 0; i < t.length; ++i)e[i] = j(t[i]); return e } if (!J(t)) return t; var n = {}, r = Object.keys(t); for (i = 0; i < r.length; ++i) { var o = r[i]; n[o] = j(t[o]) } return n } function G(t, e, value) { for (var i = "string" == typeof e ? e.split(".") : e, n = 0; n < i.length - 1; ++n) { var r = i[n], o = t[r]; o || (o = {}, t[r] = o), t = o } t[i[i.length - 1]] = value } function H(t, e) { var i = F(e); if (!i.length) return t; if (t) { for (var n = 0; n < i.length - 1; ++n) { var r = t[i[n]]; if (!r) return; t = r } return t[i[i.length - 1]] } } function q(t, e, i) { void 0 === i && (i = "."), e = e || function (t) { return !B(t) }; for (var n = {}, r = Object.keys(t), o = 0; o < r.length; ++o) { var s = r[o], value = t[s]; if (e(value)) n[s] = value; else for (var a = q(value, e), u = Object.keys(a), l = 0; l < u.length; l++) { var d = u[l]; n["" + s + i + d] = a[d] } } return n } function W(t) { for (var e = {}, i = Object.keys(t), n = 0; n < i.length; ++n) { var r = i[n]; G(e, r, t[r]) } return e } function Y(t, e, i) { void 0 === i && (i = []); for (var n = Object.keys(t), r = 0; r < n.length; ++r) { var o = n[r], value = t[o], s = e ? e + o : o; J(value) ? Y(value, s + ".", i) : i.push(s) } return i } function Z(t, e) { if (void 0 === e && (e = []), J(t)) for (var i = 0, n = Object.keys(t); i < n.length; i++) { Z(t[n[i]], e) } else e.push(t); return e } function K(t) { for (var e in t) "function" == typeof t[e] && delete t[e]; return t } function Q(value, t) { if (void 0 === value) return j(t); if (!B(value)) return value; for (var e = {}, i = 0, n = Object.keys(t); i < n.length; i++) { var r = n[i], o = t[r], s = value[r]; B(o) ? e[r] = Q(s, o) : e[r] = void 0 === s ? j(o) : s } return e } function J(value) { return value && (value.constructor === Object || !value.constructor) } function $(t, e) { if (!J(e) || !J(t)) return e; for (var i = Object.assign({}, t), n = Object.keys(e), r = 0; r < n.length; ++r) { var o = n[r]; i[o] = $(i[o], e[o]) } return i } function tt(i, t) { return null == t ? i : t.reduce(function (t, e) { return t[e] = i[e], t }, {}) } var et, it = (et = 0, "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : function (t) { var e = Date.now(), i = Math.min(16, Math.max(0, 16 - (e - et))), n = et = e + i; return setTimeout(function () { return t(n) }, i) }), nt = "undefined" != typeof cancelAnimationFrame ? cancelAnimationFrame : function (t) { return clearTimeout(t) }; function rt(e, i) { return it(function (t) { e.call(i, t) }) } function ot(t) { t && nt(t) } var st, at, ut, lt, dt = "object" == typeof global && null !== global && void 0 !== global.it, ht = "undefined" != typeof document, ct = "undefined" != typeof window, ft = ct && !window.__OGMA_HEADLESS, gt = ft && ht, pt = (_t.prototype.open = function (t, e) { this.method = t, this.url = e, _t.onSend && _t.onSend(this) }, _t.prototype.respond = function (t, e, i) { this.readyState = 4, this.status = t, this.headers = e, this.responseText = i, this.response = i, this.onreadystatechange() }, _t.prototype.send = function () { this.readyState = 4 }, _t.onCreate = null, _t.onSend = null, _t); function _t() { this.method = null, this.url = null, this.status = 0, this.readyState = 0, this.headers = {}, this.responseText = null, this.response = null, _t.onCreate && _t.onCreate(this) } var vt = (mt.prototype.readAsDataURL = function (t) { this._blob = t, mt.onRead && mt.onRead(this) }, mt.prototype.load = function (t) { this.result = "function" == typeof t ? t(this._blob) : t, this.onload && this.onload() }, mt.onCreate = null, mt.onRead = null, mt); function mt() { this.onload = null, mt.onCreate && mt.onCreate(this) } function yt() { return at || { createElementNS: function () { return null }, createElement: function () { return null }, implementation: { createDocument: function () { throw new Error('unable to create XML document; if you use Node JS install the "xmldom" package') } } } } function bt(t, e) { var value = t.style[e]; if ((!value || "auto" === value) && yt().defaultView) { var i = document.defaultView.getComputedStyle(t, null); value = i ? i[e] : null } return "auto" === value ? null : value } st = M("xmldom"), at = ht ? document : st ? (new st.DOMImplementation).createDocument() : null, ut = "undefined" != typeof XMLHttpRequest ? XMLHttpRequest : pt, lt = "undefined" != typeof FileReader ? FileReader : vt; var xt = (Object.defineProperty(Et.prototype, "offsetWidth", { get: function () { return parseFloat(this.style.width) }, enumerable: !0, configurable: !0 }), Object.defineProperty(Et.prototype, "offsetHeight", { get: function () { return parseFloat(this.style.height) }, enumerable: !0, configurable: !0 }), Object.defineProperty(Et.prototype, "firstChild", { get: function () { return null }, enumerable: !0, configurable: !0 }), Object.defineProperty(Et.prototype, "parentNode", { get: function () { return null }, enumerable: !0, configurable: !0 }), Object.defineProperty(Et.prototype, "classList", { get: function () { return { length: 0, value: "", add: function () { }, remove: function () { }, contains: function (t) { return !1 }, item: null } }, enumerable: !0, configurable: !0 }), Object.defineProperty(Et.prototype, "innerHTML", { get: function () { return "" }, set: function (t) { }, enumerable: !0, configurable: !0 }), Et.prototype.appendChild = function () { }, Et.prototype.removeChild = function () { }, Et.prototype.addEventListener = function () { }, Et.prototype.removeEventListener = function () { }, Et.prototype.insertBefore = function () { }, Et.prototype.contains = function (t) { return !1 }, Et); function Et() { this.onmousewheel = function () { }, this.__dummy = !0, this.style = {}, this.clientWidth = 0, this.clientHeight = 0, this.childNodes = [], this.style = { width: "0px", height: "0px", top: null, left: null, position: "", backgroundColor: null } } function St() { return new xt } function wt() { return ct && window.devicePixelRatio || 1 } function Tt(t) { var e, i, n, r = ";base64,"; if (-1 === t.indexOf(r)) return i = (e = t.split(","))[0].split(":")[1], Mt(n = decodeURIComponent(e[1]), i); i = (e = t.split(r))[0].split(":")[1]; for (var o = (n = window.atob(e[1])).length, s = new Uint8Array(o), a = 0; a < o; ++a)s[a] = n.charCodeAt(a); return Mt([s], i) } var Ct = function (t, e) { this.data = t, this.type = e }; function Mt(t, e) { return "undefined" != typeof Blob ? new Blob(t, { type: e }) : new Ct(t, e) } function It(t, e, i) { if (!ft) return t; var n = null, r = null, o = null; if (window.Blob ? (n = "blob" === i ? t : "dataURL" === i ? Tt(t) : Mt([t], "text/xml"), r = window.URL.createObjectURL(n)) : o = "data:text/xml;charset=UTF-8," + encodeURIComponent('<?xml version="1.0" encoding="UTF-8"?>') + encodeURIComponent(t), navigator.msSaveBlob) navigator.msSaveBlob(n, e); else if (navigator.msSaveOrOpenBlob) navigator.msSaveOrOpenBlob(n, e); else { var s = document.createElement("a"); s.setAttribute("href", window.Blob ? r : o), s.setAttribute("download", e), document.body.appendChild(s), s.click(), document.body.removeChild(s) } return r && setTimeout(function () { window.URL.revokeObjectURL(r) }, 0), t } function Lt(t, e, i, n) { if (void 0 === n && (n = wt()), t.style.width = e + "px", t.style.height = i + "px", "IMG" === t.tagName || "CANVAS" === t.tagName) { var r = t; r.width = e * n, r.height = i * n } } function Nt(e, t) { V(t, function (value, t) { void 0 !== value && e.setAttribute(t, value) }) } var kt = "http://www.w3.org/2000/svg", Ot = "http://www.w3.org/2000/xmlns/", Ft = "http://www.w3.org/1999/xlink"; function Rt(t, e) { var i = at.createElementNS(kt, t); return i.style || (i.style = {}), e && Nt(i, e), i } function Pt(t) { return at.createTextNode(t) } function Dt(i) { return "undefined" == typeof Image ? Promise.resolve(null) : new Promise(function (t) { var e = new Image; e.src = i, e.onload = function () { return t(e) }, e.onerror = function () { return t(null) } }) } function zt(t) { if (0 === t.indexOf("http://") || 0 === t.indexOf("https://")) return t; var e = window.location.origin, i = window.location.pathname, n = i.lastIndexOf("/"); return -1 === n ? e + "/" + t : e + i.substr(0, n) + "/" + t } function Bt(r) { return new Promise(function (e, i) { var n = new ut; n.open("GET", zt(r), !0), n.onreadystatechange = function () { if (4 === n.readyState) { var t = n.status; 200 === t ? e(n.responseText) : i(0 !== t ? new Error('cannot retrieve file at url "' + r + '"; the server responded with status code ' + t + ".") : new Error('cannot send XMLHttpRequest to url "' + r + "\"; if you're using the local file protocol this is most likely the cause.")) } }, n.onerror = function () { i(new Error('cannot retrieve file at url "' + r + '"; the XMLHttpRequest failed.')) }, n.send() }) } function Ut(t) { return "undefined" != typeof HTMLElement && t instanceof HTMLElement } function Vt(t, e) { t.style.cursor = e, t.style.cursor !== e && (t.style.cursor = "-webkit-" + e) } function jt(n) { return new Promise(function (t, e) { var i = new ut; i.responseType = "blob", i.open("GET", zt(n), !0), i.onreadystatechange = function () { 4 === i.readyState && (200 === i.status ? t(i.response) : e(i.status)) }, i.onerror = function (t) { return e(t) }, i.send() }) } function Gt(t) { return jt(t).then(function (n) { return new Promise(function (t, e) { var i = new lt; i.onerror = e, i.onload = function () { return t(i.result) }, i.readAsDataURL(n) }) }) } function Ht(t, e) { void 0 === e && (e = !0); var i = e ? "&#13;" : "\n"; return ("" + t).replace(/&/g, "&amp;").replace(/'/g, "&apos;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r\n/g, i).replace(/[\r\n]/g, i) } var qt = { 0: "left", 1: "middle", 2: "right" }; function Wt(t) { if (t.baseURI) return t.baseURI; var e = t.getElementsByTagName("base"); return 0 < e.length ? e[0].href : t.URL || t.location.href } function Xt(o, t, s, a) { return new Promise(function (e) { var i = t, n = Date.now(), r = (s - t) * Math.min(1, 1 / (a / 16)); !function t() { Date.now() - n < a ? (i = Math.min(1, Math.max(0, i + r)), o.style.opacity = i.toString(), rt(t)) : e() }() }) } var Yt = "undefined" != typeof performance && performance.now ? function () { return 0 | performance.now() } : function () { return Date.now() }, Zt = Yt(); function Kt() { return Yt() - Zt } function Qt() { var t = new Date, e = t.getDate(), i = t.getMonth() + 1; return t.getFullYear() + "-" + (i < 10 ? "0" + i : i) + "-" + (e < 10 ? "0" + e : e) } function Jt() { var t = new Date; return "[" + $t((t.getUTCHours() - (t.getTimezoneOffset() / 60 | 0)) % 24) + ":" + $t(t.getUTCMinutes()) + ":" + $t(t.getUTCSeconds()) + ":" + $t(t.getUTCMilliseconds(), 3) + "]" } function $t(t, e) { void 0 === e && (e = 2); for (var i = Math.pow(10, e - 1), n = String(t); 1 < i;)t < i && (n = "0" + n), i /= 10; return n } var te, ee, ie = ct && !window.PointerEvent && !!window.MSPointerEvent, ne = ct && !(!window.PointerEvent && !ie), re = ie ? "MSPointerDown" : "pointerdown", oe = ie ? "MSPointerMove" : "pointermove", se = ie ? "MSPointerUp" : "pointerup", ae = ie ? "MSPointerCancel" : "pointercancel", ue = {}, le = 0; function de(t) { return "mouse" === t.pointerType || t.MSPOINTER_TYPE_MOUSE && t.pointerType === t.MSPOINTER_TYPE_MOUSE } function he(t) { return "mouse" !== t.pointerType && t.MSPOINTER_TYPE_MOUSE && t.pointerType !== t.MSPOINTER_TYPE_MOUSE } function ce(t) { ue[t.pointerId] = t } function fe(t) { ue[t.pointerId] && (ue[t.pointerId] = t) } function ge(t) { delete ue[t.pointerId] } function pe(t, e) { for (var i in t.touches = [], ue) t.touches.push(ue[i]); t.changedTouches = [t], e(t) } function _e(t, e, i) { function n(t) { de(t) || (he(t) && t.preventDefault(), pe(t, i)) } return t(e, re, n, !1), n } function ve(t, e, i) { function n(t) { he(t) && t.preventDefault(), pe(t, i) } return t(e, ae, n, !1), n } function me(t, e, i) { function n(t) { de(t) && 0 === t.buttons || pe(t, i) } return t(e, oe, n, !1), n } function ye(t, e, i) { function n(t) { return pe(t, i) } return t(e, se, n, !1), t(e, ae, n, !1), n } function be(t, e, i, n) { return i === te.START ? t(e, re, n, !1) : i === te.MOVE ? t(e, oe, n, !1) : i === te.END ? (t(e, se, n, !1), t(e, ae, n, !1)) : void 0 } (ee = te = te || {}).START = "touchstart", ee.MOVE = "touchmove", ee.END = "touchend", ee.CANCEL = "touchcancel"; var xe, Ee, Ae = (Se.prototype.onMounted = function (t, e) { }, Se.prototype.destroy = function (t) { }, Se); function Se() { } (Ee = xe = xe || {}).MOVE = "move", Ee.DOWN = "down", Ee.UP = "up", Ee.CLICK = "click", Ee.DOUBLE_CLICK = "doubleClick", Ee.HOVER = "hover", Ee.UNHOVER = "unhover", Ee.WHEEL = "wheel", Ee.DRAG_START = "dragStart", Ee.DRAG_PROGRESS = "dragProgress", Ee.DRAG_END = "dragEnd", Ee.GESTURE_START = "gestureStart", Ee.GESTURE_PROGRESS = "gestureProgress", Ee.GESTURE_END = "gestureEnd", Ee.RESIZE = "resize", Ee.ADD_NODES = "addNodes", Ee.ADD_EDGES = "addEdges", Ee.REMOVE_NODES = "removeNodes", Ee.REMOVE_EDGES = "removeEdges", Ee.BEFORE_REMOVE_NODES = "beforeRemoveNodes", Ee.BEFORE_REMOVE_EDGES = "beforeRemoveEdges", Ee.CLEAR_GRAPH = "clear", Ee.EXCLUDED_STATE_CHANGE = "excludedStateChange", Ee.UPDATE_ATTRIBUTES = "updateAttributes", Ee.RENDERER_STATE_CHANGE = "rendererStateChange", Ee.UPDATE_NODE_DATA = "updateNodeData", Ee.UPDATE_EDGE_DATA = "updateEdgeData", Ee.SET_DATA = "setData", Ee.START_ZOOM = "startZoom", Ee.VIEW_CHANGED = "viewChanged", Ee.MOVE_END = "moveEnd", Ee.CAMERA_MOVE = "cameraMove", Ee.CAMERA_ROTATE = "cameraRotate", Ee.CAMERA_PAN = "cameraPan", Ee.CAMERA_ZOOM = "cameraZoom", Ee.NODES_DRAG_START = "startMoveNodesByDragging", Ee.NODES_DRAG_PROGRESS = "progressMoveNodesByDragging", Ee.NODES_DRAG_END = "endMoveNodesByDragging", Ee.ANIMATE = "animate", Ee.NEW_FRAME = "newFrame", Ee.BEFORE_NEW_FRAME = "beforeNewFrame", Ee.AFTER_NEW_FRAME = "afterNewFrame", Ee.SET_CONTAINER = "setContainer", Ee.RELOAD_FONTS = "reloadFonts", Ee.MOUSE_LEAVE = "mouseLeave", Ee.MOUSE_DOWN = "mouseDown", Ee.MOUSE_UP = "mouseUp", Ee.MOUSE_MOVE = "mouseMove", Ee.MOUSE_WHEEL = "mouseWheel", Ee.MOUSE_CLICK = "mouseClick", Ee.MOUSE_DOUBLE_CLICK = "mouseDoubleClick", Ee.DOCUMENT_MOUSE_MOVE = "documentMouseMove", Ee.DOCUMENT_MOUSE_UP = "documentMouseUp", Ee.VIRTUAL_DOWN = "virtualDown", Ee.VIRTUAL_UP = "virtualUp", Ee.VIRTUAL_MOVE = "virtualMove", Ee.VIRTUAL_CLICK = "virtualClick", Ee.VIRTUAL_DOUBLE_CLICK = "virtualDoubleClick", Ee.VIRTUAL_WHEEL = "virtualWheel", Ee.TOUCH_DOWN = "touchDown", Ee.TOUCH_UP = "touchUp", Ee.TOUCH_TAP = "touchTap", Ee.TOUCH_DOUBLE_TAP = "touchDoubleTap", Ee.TOUCH_MOVE = "touchMove", Ee.TOUCH_START_GESTURE = "touchStartGesture", Ee.TOUCH_PROGRESS_GESTURE = "touchProgressGesture", Ee.TOUCH_END_GESTURE = "touchEndGesture", Ee.DOCUMENT_TOUCH_MOVE = "documentTouchMove", Ee.DOCUMENT_TOUCH_UP = "documentTouchUp", Ee.GEO_LOADED = "geoLoaded", Ee.GEO_ENABLED = "geoEnabled", Ee.GEO_DISABLED = "geoDisabled", Ee.GEO_READY = "geoReady", Ee.TOOLTIP_HIDE = "hideTooltip", Ee.TOOLTIP_SHOW = "showTooltip", Ee.CONNECT_NODES = "connectNodes", Ee.LAYOUT_START = "layoutStart", Ee.LAYOUT_END = "layoutEnd", Ee.LAYOUT_COMPUTED = "layoutComputed"; var we, Te = ["graphics", "legend", "brand"], Ce = (b(Me, we = Ae), Me.prototype.onMounted = function (t, e) { e.container && t.setContainer(e.container) }, Me.prototype.addWindowEventListener = function (t, e, i) { this._isRealBrowser && this.addElementEventListener(window, t, e, i) }, Me.prototype.addDocumentEventListener = function (t, e, i) { return this._isDocumentReady && this.addElementEventListener(document.documentElement, t, e, i), e }, Me.prototype.removeDocumentEventListener = function (t, e) { this._isDocumentReady && document.documentElement.removeEventListener(t, e) }, Me.prototype.addMediaListener = function (t, e) { if (this._isDocumentReady && "function" == typeof window.matchMedia) { var i = window.matchMedia(t); i.addListener(e), this._onDetachDom.push(function () { return i.removeListener(e) }) } }, Me.prototype.addElementEventListener = function (t, e, i, n) { return this._isDestroyed || (t.addEventListener(e, i, n), this._onDetachDom.push(function () { return t.removeEventListener(e, i, n) })), i }, Me.prototype.detachFromDom = function () { this._onDetachDom.forEach(function (t) { return t() }), this._onDetachDom = null, this._emptyContainer() }, Me.prototype.setTimeout = function (t, e) { var i = this; void 0 === e && (e = 0); var n = setTimeout(function () { i._timeouts.splice(i._timeouts.indexOf(n), 1), t() }, e); return this._timeouts.push(n), n }, Me.prototype.clearTimeout = function (t) { return t && (clearTimeout(t), this._timeouts.splice(this._timeouts.indexOf(t), 1)), null }, Me.prototype.clearAllTimeouts = function () { this._timeouts.forEach(clearTimeout), this._timeouts = [] }, Me.prototype.stopFrames = function () { this._isDestroyed = !0, this._nextFrame && (ot(this._nextFrame), this._nextFrame = null) }, Me.prototype.isDestroyed = function () { return this._isDestroyed }, Me.prototype.getDimensions = function () { return { width: this._width, height: this._height } }, Me.prototype.setDimensions = function (t) { this._resize(t) }, Me.prototype.setLayer = function (t, e, i) { var n = (void 0 === i ? {} : i).automaticResize, r = void 0 !== n && n; e && (e._ogmaLayer = t, r && (e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", Lt(e, this._width, this._height, wt()))), this._layers[t] = { element: e, automaticResize: r }, this._updateContainerContent() }, Me.prototype.setContainer = function (t) { if ("string" == typeof t) { var e = t; if (!(t = document.getElementById(e))) throw new Error('unable to find DOM element with id "' + e + '"') } if (t !== this._container) { var i = this._container; this._isFullScreen = !1, this._container = t, this._resize(), this._updateContainerContent(), this._events.fire(xe.SET_CONTAINER, { element: t, prevElement: i }) } }, Me.prototype.getContainer = function () { return this._container }, Me.prototype.appendElement = function (t) { null !== this._container && this._container.appendChild(t) }, Me.prototype.focus = function () { this._focus = !0 }, Me.prototype.blur = function () { this._focus = !1 }, Me.prototype.hasFocus = function () { return this._focus }, Me.prototype.forceResize = function () { this._resize() }, Me.prototype._beforeOrAfterNextFrame = function (t) { var e = t ? this._afterNextFramePromises : this._beforeNextFramePromises, i = new Promise(function (t) { e.push(function () { return t(), i }) }); return this._refresh(), i }, Me.prototype.beforeNextFrame = function () { return this._beforeOrAfterNextFrame(!1) }, Me.prototype.afterNextFrame = function () { return this._beforeOrAfterNextFrame(!0) }, Me.prototype.refresh = function (t) { t && (this._refreshUntil = Math.max(this._refreshUntil, t)), this._refresh() }, Me.prototype._emptyContainer = function () { if (this._container) { for (var t = [], e = 0; e < this._container.childNodes.length; ++e) { var i = this._container.childNodes[e]; i._ogmaLayer && t.push(i) } for (e = 0; e < t.length; ++e)this._container.removeChild(t[e]) } }, Me.prototype._fillContainer = function () { var i = this; if (this._container) { var t = bt(this._container, "position"); "absolute" !== t && "relative" !== t && "fixed" !== t && (this._container.style.position = "relative"); var n = this._container.firstChild; Te.forEach(function (t) { var e = i._layers[t]; e && e.element && i._container.insertBefore(e.element, n) }) } }, Me.prototype._updateContainerContent = function () { this._emptyContainer(), this._fillContainer() }, Me.prototype._resize = function (t) { if (this._container || t) { var i, n, e = this._width, r = this._height; if (this._container) { var o = this._settings.get("minimumWidth"), s = this._settings.get("minimumHeight"), a = this._container.clientWidth || 1, u = this._container.clientHeight || 1; i = Math.max(o, t ? t.width : a), n = Math.max(s, t ? t.height : u) } else i = t.width, n = t.height; i === e && n === r || (this._width = i, this._height = n, V(this._layers, function (t) { var e = t.element; t.automaticResize && Lt(e, i, n) }), this._events.fire(xe.RESIZE, { prevWidth: e, prevHeight: r, width: i, height: n, difWidth: i - e, difHeight: n - r })) } }, Me.prototype._refresh = function () { var t = this; this._inFrame ? this._mustRefresh = !0 : this._nextFrame || this._isDestroyed || (this._nextFrame = rt(function () { return t._playFrame() })) }, Me.prototype._playFrame = function () { var i = this, t = Kt(), e = t - this._currentTime, n = N([this._beforeNextFramePromises, function () { return i._events.fire(xe.BEFORE_NEW_FRAME, { elapsed: e }) }, function () { return i._events.fire(xe.NEW_FRAME, { elapsed: e }) }, function () { return i._events.fire(xe.AFTER_NEW_FRAME, { elapsed: e }) }, this._afterNextFramePromises, function () { i._inFrame = !1, (i._mustRefresh || t < i._refreshUntil + 17) && (i._mustRefresh = !1, i._refresh()) }]); this._inFrame = !0, this._nextFrame = null, this._mustRefresh = !1, this._currentTime = t, this._beforeNextFramePromises = [], this._afterNextFramePromises = [], n.reduce(function (t, e) { return t.then(function () { if (!i._isDestroyed) return e() }) }, Promise.resolve()) }, Me.prototype.isPlayingFrame = function () { return this._inFrame || !!this._nextFrame }, Me.prototype.setFullScreen = function (value) { var t; this._container && (value && !this._isFullScreen ? (t = this._container).requestFullScreen ? t.requestFullScreen() : t.webkitRequestFullScreen ? t.webkitRequestFullScreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.msRequestFullscreen && t.msRequestFullscreen() : value || !this._isFullScreen || "undefined" != typeof document && (document.cancelFullScreen ? document.cancelFullScreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen())), this._isFullScreen = value }, Me.prototype.isFullScreen = function () { return this._isFullScreen }, Me.prototype.debounceBeforeFrame = function (e) { function i() { var t = o; r = !1, o = [], e(), t.forEach(function (t) { return t() }) } var n = this, r = !1, o = []; return function () { return new Promise(function (t) { o.push(t), r || (r = !0, n.beforeNextFrame().then(i)) }) } }, Me.prototype.destroy = function () { !function () { if (le-- , ht && 0 === le) { var t = document.documentElement; t.removeEventListener(re, ce, !0), t.removeEventListener(oe, fe, !0), t.removeEventListener(se, ge, !0), t.removeEventListener(ae, ge, !0) } }(), this.detachFromDom(), this.clearAllTimeouts(), this.stopFrames() }, Me); function Me(t, e) { var i = t.events, n = t.settings, r = void 0 === e ? {} : e, o = r.width, s = void 0 === o ? 300 : o, a = r.height, u = void 0 === a ? 300 : a, l = we.call(this) || this; return l._layers = {}, l._focus = !1, l._container = null, l._isFullScreen = !1, l._beforeNextFramePromises = [], l._afterNextFramePromises = [], l._refreshUntil = 0, l._currentTime = Kt(), l._timeouts = [], l._isDestroyed = !1, l._onDetachDom = [], l._isRealBrowser = ft, l._isDocumentReady = gt, l._inFrame = !1, l._mustRefresh = !1, l._nextFrame = null, l._onWindowResize = function () { return l._resize() }, l._onWindowFocus = function () { return l.refresh() }, l._events = i, l._settings = n, l._width = s, l._height = u, l._settings.register("minimumWidth", 300, function () { return l._resize() }, !1), l._settings.register("minimumHeight", 300, function () { return l._resize() }, !1), l._events.register([xe.BEFORE_NEW_FRAME, xe.NEW_FRAME, xe.AFTER_NEW_FRAME, xe.SET_CONTAINER, xe.RESIZE]), l._onDetachDom = [], function () { if (ht && 0 === le && ne) { var t = document.documentElement; t.addEventListener(re, ce, !0), t.addEventListener(oe, fe, !0), t.addEventListener(se, ge, !0), t.addEventListener(ae, ge, !0) } le++ }(), l.addWindowEventListener("resize", l._onWindowResize), l.addWindowEventListener("focus", l._onWindowFocus), l } var Ie, Le = (b(Ne, Ie = Ae), Ne.prototype.setProperty = function (t, e, value, i) { var n = (void 0 === i ? {} : i).dispatch, r = void 0 !== n && n; this._setDataProperty(t.isNode, t._indexes, e, value, r), this._events.fire(xe.SET_DATA, { elements: t }) }, Ne.prototype.getProperty = function (t, e) { return this._getDataProperty(t.isNode, t._indexes, e) }, Ne.prototype._setDataProperty = function (t, e, i, value, n) { n && "function" == typeof value && (n = !1), i = ke(i); for (var r = "function" == typeof value, o = t ? this._nodeList : this._edgeList, s = t ? this._nodeDataList : this._edgeDataList, a = function (t, e) { for (var i = 0; i < t.length; ++i) { var n = t[i], r = n.property; if (null === e && null === r) return n; if (e && r && r.length === e.length) { for (var o = !0, s = 0; s < r.length; ++s)if (r[s] !== e[s]) { o = !1; break } if (o) return n } } var a = { property: e && e.slice(), indexes: [], previousValues: [], newValues: [], nodes: null, edges: null }; return t.push(a), a }(t ? this._nodeChanges : this._edgeChanges, i), u = 0; u < e.length; ++u) { var l = e[u], d = s.get(l), h = o.get(l), c = n ? value[u] : value, f = void 0, g = void 0; if (null === i) f = d, g = r ? c(h) : c, s.set(l, g); else { null == d && (d = {}, s.set(l, d)); for (var p = i.length, _ = 0; _ < p; _++) { var v = i[_], m = d[v]; _ < p - 1 ? (null == m && (m = {}, d[v] = m), d = m) : (f = m, g = r ? c(h) : c, d[v] = g) } } a.indexes.push(l), a.previousValues.push(f), a.newValues.push(g) } this._scheduleEvents() }, Ne.prototype._getDataProperty = function (t, e, i, n) { i = ke(i), n = n || new Array(e.length); for (var r = t ? this._nodeDataList : this._edgeDataList, o = 0; o < e.length; ++o) { var s = e[o], a = r.get(s), value = void 0; if (null !== i && i.length) if (null == a) value = void 0; else for (var u = i.length, l = 0; l < u && a; ++l)value = a = a[i[l]]; else value = a; n[o] = value } return n }, Ne.prototype._scheduleEvents = function () { this._shouldTriggerEvents = !0, this._dom.refresh() }, Ne.prototype._triggerEvents = function () { var t = this._prepareEvtPayload(!0), e = this._prepareEvtPayload(!1); this._events.fire(xe.UPDATE_NODE_DATA, t), this._events.fire(xe.UPDATE_EDGE_DATA, e) }, Ne.prototype._prepareEvtPayload = function (t) { var e = t ? this._graph.nodeList : this._graph.edgeList, i = t ? "_nodeChanges" : "_edgeChanges", n = [], r = this[i]; this[i] = []; for (var o = [], s = 0; s < r.length; ++s) { var a = r[s], u = a.indexes, l = a.property, d = a.newValues, h = a.previousValues; n = n.concat(u), t ? o.push({ property: l, newValues: d, previousValues: h, nodes: e(u) }) : o.push({ property: l, newValues: d, previousValues: h, edges: e(u) }) } return t ? { nodes: e(n).dedupe(), isNode: t, changes: o } : { edges: e(n).dedupe(), isNode: t, changes: o } }, Ne); function Ne(t) { var e, d = Ie.call(this) || this; return d._nodeChanges = [], d._edgeChanges = [], d._shouldTriggerEvents = !1, d._dom = t.dom, d._graph = t.graph, d._events = t.events, d._nodeDataList = d._graph.createAttribute(!0, { name: "data", storage: "any" }), d._edgeDataList = d._graph.createAttribute(!1, { name: "data", storage: "any" }), d._nodeList = d._graph.getNodeAttribute("object"), d._edgeList = d._graph.getEdgeAttribute("object"), d._events.register([xe.SET_DATA, xe.UPDATE_NODE_DATA, xe.UPDATE_EDGE_DATA]), d._events.on(((e = {})[xe.ADD_NODES + " " + xe.ADD_EDGES] = function (t) { for (var e = t.nodes, i = t.edges, n = t.objects, r = e || i, o = r.isNode, s = r.size, a = r._indexes, u = d[o ? "_nodeDataList" : "_edgeDataList"], l = 0; l < s; ++l)u.set(a[l], n[l].data) }, e[xe.BEFORE_NEW_FRAME] = function () { d._shouldTriggerEvents && (d._shouldTriggerEvents = !1, d._triggerEvents()) }, e)), d } function ke(t) { return "string" == typeof t ? t.split(".") : I(t) ? t : null == t ? null : void 0 } var Oe = { 1: De(1), 2: De(2), 4: De(4), 8: Re(), 16: Re(), 32: Re(), int8: Re(), int16: Re(), int32: Re(), float: Re(), any: Re() }, Fe = { 1: ze(1), 2: ze(2), 4: ze(4), 8: Pe(), 16: Pe(), 32: Pe(), int8: Pe(), int16: Pe(), int32: Pe(), float: Pe(), any: Pe() }; function Re() { return new Function("array", "index", "return array[index];") } function Pe() { return new Function("array", "index", "value", "array[index] = value;") } function De(t) { var e = 8 / t; return new Function("array", "index", "return (array[index / " + e + " | 0] >> ((index % " + e + ") * " + t + ")) & " + ((1 << t) - 1) + ";") } function ze(t) { return new Function("array", "index", "value", "\n    var offset = (index % " + 8 / t + ") * " + t + ";\n    var finalIndex = index / " + 8 / t + " | 0;\n    var orMask = value << offset;\n    var andMask = 255 - ((" + (Math.pow(2, t) - 1) + " - value) << offset);\n\n    array[finalIndex] = (array[finalIndex] & andMask) | orMask;") } var Be = { get: function (t) { return this._getArrayElt(this._buffer, t) }, set: function (t, value) { this._setArrayElt(this._buffer, t, value) } }, Ue = { get: function (t) { return this._byIndex[this._getArrayElt(this._buffer, t)] }, set: function (t, value) { var e = this._byName[value]; void 0 === e && (e = this._nextIndex++ , this._byIndex.push(value), this._getElementBitSize() > this._elementSize && this.increaseElementSize(), this._byName[value] = e); this._setArrayElt(this._buffer, t, e) } }, Ve = (je.prototype.getValues = function () { return Object.keys(this._byName) }, je.prototype.getName = function () { return this._name }, je.prototype.get = function (t) { return this._get(t) }, je.prototype.set = function (t, value) { this._set(t, value) }, je.prototype._get = function (t) { return this._defaultValue }, je.prototype._set = function (t, value) { value !== this._defaultValue && (this._initialize(), this._set(t, value)) }, je.prototype.setFallback = function (t) { this._fallback = t, this.get = this._getWithFallback }, je.prototype._getWithFallback = function (t) { var value = this._get(t); return void 0 === value ? this._fallback.get(t) : value }, je.prototype._initialize = function () { this._initialized = !0, this._buffer = He(this._nbElements, this._elementSize), this._get = this._methods.get, this._set = this._methods.set, "resource" !== this._storage && this._defaultValue !== this._BASE_VALUE && this._reset(0) }, je.prototype.increaseNbElements = function (t) { var e = Ge(t + 1); if (!(e <= this._nbElements)) { if (this._initialized) if ("any" === this._elementSize) for (var i = this._nbElements; i < e; ++i)this._buffer.push(this._defaultValue); else { var n = He(e, this._elementSize); n.set(this._buffer), this._buffer = n, "resource" !== this._storage && this._defaultValue !== this._BASE_VALUE && this._reset(this._nbElements) } this._nbElements = e } }, je.prototype.increaseElementSize = function () { var t = this._elementSize; if ("number" != typeof t || 32 === t) throw new Error("FlexArray: cannot increase element size"); var e = 2 * t, i = Oe[e], n = Fe[e]; if (this._initialized) { var r = this._nbElements, o = this._getArrayElt, s = this._buffer, a = He(r, e); if (8 <= t) a.set(s); else for (var u = 0; u < r; ++u)n(a, u, o(s, u)); this._buffer = a } this._elementSize = e, this._getArrayElt = i, this._setArrayElt = n }, je.prototype.buffer = function () { if (!this._buffer) throw new Error("FlexArray: buffer not instantiated"); return this._buffer }, je.prototype.elementBitSize = function () { return this._elementSize }, je.prototype.capacity = function () { return this._nbElements }, je.prototype.byteSize = function () { return this._nbElements * this._elementSize / 8 }, je.prototype.isInitialized = function () { return this._initialized || this._fallback && this._fallback.isInitialized() }, je.prototype.getMultiple = function (t, e) { var i = t.length; void 0 === e && (e = new Array(i)); for (var n = 0, r = i; n < r; ++n)e[n] = this.get(t[n]); return e }, je.prototype.fill = function (t, value) { for (var e = 0, i = t.length; e < i; ++e)this.set(t[e], value) }, je.prototype.setMultiple = function (t, e, i) { if (i || !Array.isArray(e) && !ArrayBuffer.isView(e)) for (n = 0, r = t.length; n < r; ++n)this.set(t[n], e); else for (var n = 0, r = t.length; n < r; ++n)this.set(t[n], e[n]) }, je.prototype.reset = function () { return this._initialized && this._reset(0), this }, je.prototype._reset = function (t) { var value = "resource" === this._storage ? 0 : this._defaultValue; if ("number" != typeof this._elementSize || 8 <= this._elementSize) this._buffer.fill(value, t); else { for (var e = 8 / this._elementSize, i = 0, n = 0; n < e; ++n)i <<= this._elementSize, i += value; if (void 0 === t) this._buffer.fill(i); else { var r = t + (8 - t % 8); for (n = t; n < r; ++n)this._setArrayElt(this._buffer, n, value); this._buffer.fill(i, r / 8) } } }, je.prototype._getElementBitSize = function () { return Math.pow(2, Math.ceil(Math.log2(Math.log2(this._nextIndex)))) }, je); function je(t) { this._initialized = !1; var e, i, n = t.name, r = t.storage, o = t.size || 0, s = (e = t.default, i = r, void 0 === e && "any" !== i && "resource" !== i ? 0 : e), a = Math.max(8, Ge(o + 1)), u = "resource" === r ? 1 : r; this._name = n, this._storage = r, this._getArrayElt = Oe[u], this._setArrayElt = Fe[u], this._elementSize = u, this._nbElements = a, this._fallback = null, this._byName = void 0, this._byIndex = void 0, this._nextIndex = void 0, this._defaultValue = s, this._BASE_VALUE = "any" === r ? void 0 : 0, this._methods = Be, this._initialized = !1, this._buffer = null, "resource" === r && (this._methods = Ue, this._byName = {}, this._byIndex = [], this._nextIndex = 1, this._byName[s] = 0, this._byIndex.push(s)) } function Ge(t) { for (var e = 2; e < t;)e *= 2; return e } function He(t, e) { return "any" === e ? new Array(t) : "float" === e ? new Float32Array(t) : "int8" === e ? new Int8Array(t) : "int16" === e ? new Int16Array(t) : "int32" === e ? new Int32Array(t) : 32 === e ? new Uint32Array(t) : 16 === e ? new Uint16Array(t) : new Uint8Array(Math.ceil(t / 8 * e)) } function qe(t) { return Math.pow(2, Math.ceil(Math.log2(t))) } function We(t) { for (var e = 0, i = 0; i < t.length; ++i)e += t[i]; return e } function Xe(value, t, e) { return Math.max(t, Math.min(e, value)) } function Ye(t, e, i) { return t + (e - t) * i } function Ze(t, e, i) { return t * (1 - i) + e * i } function Ke(t) { if (!t.length) return -1 / 0; for (var e = t[0], i = 1, n = t.length; i < n; ++i) { var r = t[i]; e < r && (e = r) } return e } function Qe(t) { if (!t.length) return 1 / 0; for (var e = t[0], i = 1, n = t.length; i < n; ++i) { var r = t[i]; r < e && (e = r) } return e } function Je(t, e) { return Math.log(t) / Math.log(e) } var $e = (ti.prototype.isBusy = function () { return this._busy }, ti.prototype.markBusy = function () { return this._busy = !0, this }, ti.prototype.sliceAndReset = function () { this._busy = !1; var t = this.slice(0, this._size); return this.reset(), t }, ti.prototype.reset = function () { return this._size = 0, this }, ti.prototype.reserve = function (value) { return value > this._capacity && this._setCapacity(qe(value)), this }, ti.prototype._setCapacity = function (t) { var e = new Uint32Array(t); e.set(this._buffer), this._buffer = e, this._capacity = t }, ti.prototype.push = function (value) { return this._size === this._capacity && this._setCapacity(2 * this._capacity), this._buffer[this._size++] = value, this }, ti.prototype.pushUnchecked = function (value) { return this._buffer[this._size++] = value, this }, ti.prototype.slice = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = this._size), this._buffer.slice(t, e) }, ti.prototype.getBuffer = function () { return this._buffer }, ti.prototype.getLength = function () { return this._size }, ti.prototype.getCapacity = function () { return this._capacity }, ti.prototype.setLength = function (value) { return this._size = value, this }, ti.prototype.isEmpty = function () { return 0 === this._size }, ti); function ti() { this._buffer = new Uint32Array(4), this._capacity = 4, this._size = 0, this._busy = !1 } var ei = (ii.prototype.addElements = function (t) { for (var e = [], i = 0, n = t.length; i < n; ++i) { var r = t[i], o = this._idToIndex[r]; void 0 === o && (o = this._getNextIndex(), this._idToIndex[r] = o, this._indexToId[o] = r), e.push(o) } for (var s = 0, a = this._flexArrays; s < a.length; s++)a[s].increaseNbElements(this._nextIndex); for (var u = 0, l = this._indexLists; u < l.length; u++)l[u].reserve(this._nextIndex); return new Uint32Array(e) }, ii.prototype.removeElements = function (t) { for (var e = 0, i = t.length; e < i; ++e) { var n = t[e], r = this._indexToId[n]; void 0 !== r && (delete this._idToIndex[r], this._removeIndex(n)) } }, ii.prototype.clear = function () { this._idToIndex = Object.create(null), this._indexToId = [void 0], this._nextIndex = 1, this._freeIndexes = []; for (var t = 0, e = this._flexArrays; t < e.length; t++)e[t].reset(); for (var i = 0, n = this._indexLists; i < n.length; i++)n[i].reset() }, ii.prototype.has = function (t) { return void 0 !== this._indexToId[t] }, ii.prototype.getIndex = function (t, e) { void 0 === e && (e = !1); var i = this._idToIndex[t]; if (void 0 === i && e) throw new Error(this._name + ' id "' + t + '" not found'); return i }, ii.prototype.createFlexArray = function (t) { var e = t.name; if (e && this._flexArraysByName[e]) throw new Error(this._name + ' flexArray "' + e + '" already exists'); var i = t.default; void 0 === i && "any" !== t.storage && "resource" !== t.storage && (i = 0); var n, r = this._nextIndex, o = { storage: t.storage, size: r, name: e, default: i }; return void 0 === i && "any" !== t.storage && t.storage, n = new Ve(o), this._flexArrays.push(n), this._defaultValues.push(t.default), e && (this._flexArraysByName[e] = n), n }, ii.prototype.getFlexArray = function (t) { return this._flexArraysByName[t] || null }, ii.prototype.getAllFlexArrays = function () { return this._flexArraysByName }, ii.prototype.createIndexList = function () { var t = new $e; return t.reserve(this._nextIndex), this._indexLists.push(t), t }, ii.prototype.getId = function (t) { return this._indexToId[t] }, ii.prototype.getMaxIndex = function () { return this._nextIndex - 1 }, ii.prototype._removeIndex = function (t) { this._indexesToBeFreed.push(t) }, ii.prototype._getNextIndex = function () { var t = this._freeIndexes.pop(); return void 0 === t && (t = this._nextIndex++), t }, ii.prototype.freeIndexes = function () { for (var t = 0, e = this._indexesToBeFreed; t < e.length; t++) { var i = e[t]; this._indexToId[i] = void 0, this._freeIndexes.push(i) } for (var n = 0; n < this._flexArrays.length; ++n)for (var r = this._flexArrays[n], o = this._defaultValues[n], s = 0, a = this._indexesToBeFreed; s < a.length; s++)i = a[s], r.set(i, o); this._indexesToBeFreed = [] }, ii); function ii(t) { var n = this; this._nextIndex = 1, this._freeIndexes = [], this._indexesToBeFreed = [], this._idToIndex = Object.create(null), this._indexToId = [void 0], this._flexArrays = [], this._defaultValues = [], this._flexArraysByName = {}, this._indexLists = [], this._name = t ? "node" : "edge", this._nextIndex = 1, this._freeIndexes = [], this._indexesToBeFreed = [], this._idToIndex = Object.create(null), this._indexToId = [void 0], this._idFlexArray = new Ve({ storage: "int32" }), this._idFlexArray.get = function (t) { return n._indexToId[t] }, this._idFlexArray.getMultiple = function (t) { for (var e = new Array(t.length), i = 0; i < t.length; ++i)e[i] = n._indexToId[t[i]]; return e }, this._flexArraysByName.id = this._idFlexArray } var ni, ri, oi = (si.prototype.addEntry = function (t) { return void 0 === t && (t = this._nextIndex++), t >= this._capacity && this._reserve(t + 1), this._sizes[t] = 0, t }, si.prototype.get = function (t) { var e = this._sizes[t], i = this._MAX_LIST_SIZE * t; if (e <= this._MAX_LIST_SIZE) { for (var n = 0, r = this._constList.length = e; n < r; ++n)this._constList[n] = this._buffer[i + n]; return this._constList } if (e === this._BIG_LIST) { var o = this._buffer[i]; return this._bigLists[o] } }, si.prototype.size = function (t) { var e = this._sizes[t]; return e <= this._MAX_LIST_SIZE ? e : this._bigLists[this._buffer[t * this._MAX_LIST_SIZE]].length }, si.prototype.sizes = function (t) { for (var e = this._sizes, i = this._bigLists, n = this._buffer, r = this._MAX_LIST_SIZE, o = t.length, s = new Array(o), a = 0; a < o; a++) { var u = t[a], l = e[u]; s[a] = l <= r ? l : i[n[u * r]].length } return s }, si.prototype.addTo = function (t, value) { var e = this._sizes[t], i = t * this._MAX_LIST_SIZE; if (e < this._MAX_LIST_SIZE) this._buffer[i + e] = value, this._sizes[t] = e + 1; else if (e === this._BIG_LIST) { var n = this._buffer[i]; this._bigLists[n].push(value) } else { for (var r = new Array(this._MAX_LIST_SIZE), o = 0; o < this._MAX_LIST_SIZE; ++o)r[o] = this._buffer[i + o]; r.push(value), this._bigLists.push(r), this._sizes[t] = this._BIG_LIST, this._buffer[i] = this._bigLists.length - 1 } return this }, si.prototype.removeFrom = function (t, value) { return this.removeFromAndGetSize(t, value), this }, si.prototype.removeFromAndGetSize = function (t, value) { var e = this._MAX_LIST_SIZE * t, i = this._sizes[t]; if (i <= this._MAX_LIST_SIZE) { for (var n = e, r = e + i; n < r; ++n)if (this._buffer[n] === value) return --i, this._buffer[n] = this._buffer[r - 1], this._sizes[t] = i } else if (i === this._BIG_LIST) { var o = this._buffer[e], s = this._bigLists[o]; if (-1 !== (n = s.indexOf(value))) return s.splice(n, 1), s.length } throw new Error('topology: Table: "removeFrom" failed, should not happen') }, si.prototype.reserve = function (t) { return this._capacity < t && this._reserve(t), this }, si.prototype._reserve = function (t) { this._capacity = Math.pow(2, Math.ceil(Math.log2(t))), this._buffer = ai(this._buffer, this._capacity * this._MAX_LIST_SIZE), this._sizes = ai(this._sizes, this._capacity) }, si); function si() { this._BIG_LIST = 255, this._MAX_LIST_SIZE = 8, this._capacity = 8, this._buffer = new Uint32Array(this._capacity * this._MAX_LIST_SIZE), this._sizes = new Uint8Array(this._capacity), this._bigLists = [], this._nextIndex = 0, this._constList = new Array(this._MAX_LIST_SIZE) } function ai(t, e) { var i = new t.constructor(e); return i.set(t), i } (ri = ni = ni || {}).BOTH = "both", ri.IN = "in", ri.OUT = "out"; var ui = (li.prototype.getAdjacentDirections = function (t) { return this._neighborTable.get(t) }, li.prototype.getEdgeIndexesInDirection = function (t) { return this._parallelTable.get(t) }, li.prototype.allocateNodes = function (t) { this._neighborTable.reserve(t.length); for (var e = 0; e < t.length; ++e)this._neighborTable.addEntry(t[e]) }, li.prototype.allocateEdges = function (t, e, i) { this._parallelTable.reserve(Math.floor(t.length / 2)); for (var n = 0; n < t.length; n++) { var r = t[n], o = e[n], s = i[n]; this._sourceList.set(r, o), this._targetList.set(r, s), this.addToAdjacencyList(r) } }, li.prototype.getExtremity = function (t, e) { var i = t ? this._sourceList : this._targetList; if (e.isList) { for (var n = this._graph.acquireIndexList(!0), r = 0; r < e._indexes.length; r++)n.push(i.get(e._indexes[r])); return this._graph.nodeList(n.sliceAndReset()) } return this._graph.getObjectList(!0).get(i.get(e._index)) }, li.prototype.setExtremities = function (t, e, i) { for (var n = 0; n < t.length; ++n)this.removeFromAdjacencyList(t[n]); for (null !== e && this._sourceList.setMultiple(t, e), null !== i && this._targetList.setMultiple(t, i), n = 0; n < t.length; ++n)this.addToAdjacencyList(t[n]) }, li.prototype.addToAdjacencyList = function (t) { var e = this._sourceList.get(t), i = this._targetList.get(t), n = di(e, i), r = this._parallelEdgesIndex[n]; void 0 === r && (r = this._parallelTable.addEntry(), this._parallelEdgesIndex[n] = r, this._neighborTable.addTo(e, r), e !== i && this._neighborTable.addTo(i, r)), this._parallelTable.addTo(r, t) }, li.prototype.removeFromAdjacencyList = function (t) { var e = this._sourceList.get(t), i = this._targetList.get(t), n = di(e, i), r = this._parallelEdgesIndex[n]; 0 === this._parallelTable.removeFromAndGetSize(r, t) && (this._neighborTable.removeFrom(e, r), e !== i && this._neighborTable.removeFrom(i, r), this._parallelEdgesIndex[n] = void 0) }, li.prototype.getParallelEdges = function (t, e) { void 0 === e && (e = {}); for (var i = e.filter || "visible", n = this._graph.acquireIndexList(!1), r = this._graph.getFilter(!1, i), o = 0; o < t._indexes.length; o++) { var s = t._indexes[o], a = di(this._sourceList.get(s), this._targetList.get(s)), u = this._parallelEdgesIndex[a], l = this._parallelTable.get(+u); if (l) for (var d = 0, h = l; d < h.length; d++) { var c = h[d]; r(c) && n.push(c) } } return this._graph.edgeList(n.sliceAndReset()) }, li.prototype.fastGetNodesAdjacentElements = function (t) { for (var e = this._graph.acquireIndexList(!0), i = this._graph.acquireIndexList(!1), n = this._sourceList, r = this._targetList, o = 0; o < t.length; o++)for (var s = t[o], a = 0, u = this._neighborTable.get(s); a < u.length; a++) { var l = u[a], d = this._parallelTable.get(l), h = d[0], c = n.get(h), f = r.get(h); e.push(c + f - s); for (var g = 0, p = d; g < p.length; g++) { var _ = p[g]; i.push(_) } } return { nodes: this._graph.nodeList(e.sliceAndReset()), edges: this._graph.edgeList(i.sliceAndReset()) } }, li.prototype.fastGetEdgesAdjacentElements = function (t) { for (var e = this._graph.acquireIndexList(!0), i = this._graph.acquireIndexList(!1), n = this._sourceList, r = this._targetList, o = 0; o < t.length; o++) { var s = t[o], a = n.get(s), u = r.get(s), l = di(a, u), d = this._parallelEdgesIndex[l], h = this._parallelTable.get(+d); if (h) for (var c = 0, f = h; c < f.length; c++) { var g = f[c]; i.push(g) } e.push(a), e.push(u) } return { nodes: this._graph.nodeList(e.sliceAndReset()), edges: this._graph.edgeList(i.sliceAndReset()) } }, li.prototype.getDeduper = function (t) { return (t ? this.nodeDeduper : this.edgeDeduper).reset() }, li.prototype.collectAdjacentEdges = function (t, e, i, n, r) { void 0 === n && (n = !1), void 0 === r && (r = !1); var o = e === ni.OUT, s = e === ni.IN, a = !(o || s || r), u = this._graph.acquireIndexList(!1), l = this._graph.getFilter(!1, i), d = n ? this.getDeduper(!1) : this._fakeDeduper, h = this._fakeInvertedDeduper, c = this._sourceList, f = this._targetList; if (r) { h = this.getDeduper(!0); for (var g = 0; g < t.length; g++)h.set(t[g], 1) } for (g = 0; g < t.length; g++)for (var p = t[g], _ = 0, v = this._neighborTable.get(p); _ < v.length; _++) { var m = v[_], y = this._parallelTable.get(m); if (a) for (var b = 0, x = y; b < x.length; b++)l(S = x[b]) && 0 === d.get(S) && (u.push(S), d.set(S, 1)); else for (var E = 0, A = y; E < A.length; E++) { var S = A[E], w = c.get(S), T = f.get(S), C = w + T - p; s != (T === p) && w !== T || !l(S) || 0 !== d.get(S) || 1 !== h.get(C) || (u.push(S), d.set(S, 1)) } } return u.sliceAndReset() }, li.prototype.collectAdjacentNodes = function (t, e, i, n, r, o) { void 0 === n && (n = !1); var s = e !== ni.IN, a = e !== ni.OUT, u = this._graph.acquireIndexList(!0), l = this._graph.getFilter(!1, i), d = n ? this.getDeduper(!0) : this._fakeDeduper, h = this._sourceList, c = this._targetList; if (r) for (var f = 0; f < r.length; f++) { var g = r[f]; u.push(g), d.set(g, 1) } if (o) for (f = 0; f < o.length; f++)g = o[f], d.set(g, 1); for (f = 0; f < t.length; f++)for (var p = t[f], _ = 0, v = this._neighborTable.get(p); _ < v.length; _++)for (var m = v[_], y = 0, b = this._parallelTable.get(m); y < b.length; y++) { var x = b[y]; if (l(x)) { var E = h.get(x), A = c.get(x); if (g = E + A - p, (a && p === A || s && p === E) && 0 === d.get(g)) { u.push(g), d.set(g, 1); break } } } return u.sliceAndReset() }, li.prototype.getAdjacentElements = function (t, e, i) { void 0 === i && (i = {}); var n = i.direction || ni.BOTH, r = i.filter || "visible", o = i.policy || "union", s = !!i.bothExtremities, a = i.includeSources; if (!0 === a ? o = "include-sources" : !1 === a && (o = "exclude-sources"), t) { var u = "include-sources" === o ? e : null, l = "exclude-sources" === o ? e : null; return this.collectAdjacentNodes(e, n, r, !0, u, l) } return this.collectAdjacentEdges(e, n, r, !0, s) }, li.prototype.getEdgesBetweenTwoNodes = function (t, e) { var i = di(t, e), n = this._parallelEdgesIndex[i], r = this._parallelTable.get(+n); return new Uint32Array(r || 0) }, li.prototype.getConnectedComponents = function (t, e) { for (var i = void 0 === e ? {} : e, n = i.filter, r = void 0 === n ? "visible" : n, o = i.returnIds, s = void 0 !== o && o, a = i.internalIndexes, u = void 0 !== a && a, l = this._graph, d = [], h = {}, c = l.acquireIndexList(!0), f = l.getFilter(!0, r), g = 0; g < t.length; g++)f(v = t[g]) && c.push(v); var p = c.sliceAndReset(), _ = { filter: r }; for (g = 0; g < p.length; g++) { var v; if (!h[v = p[g]]) { for (var m = [v], y = []; 0 !== m.length;) { var b = m.pop(); h[b] || (m.push.apply(m, this.getAdjacentElements(!0, new Uint32Array([b]), _)), h[b] = !0, y.push(b)) } 0 < y.length && d.push(y) } } if (s) { var x = l.getNodeAttribute("id"); for (g = 0; g < d.length; g++)d[g] = x.getMultiple(d[g]) } else if (!u) for (g = 0; g < d.length; g++)d[g] = l.nodeList(new Uint32Array(d[g])); return d }, li.prototype.getAdjacencyList = function (t) { for (var e = t.directed, i = t.ids, n = t.weight, r = t.nodes, o = e ? ni.OUT : ni.BOTH, s = new Array(r.length), a = this._graph, u = 0; u < r.length; ++u)s[u] = this.collectAdjacentEdges(new Uint32Array([r[u]]), o, "all"); var l = a.getEdgeAttribute("source"), d = a.getEdgeAttribute("target"), h = a.getEdgeAttribute("width"), c = a.getNodeAttribute("id"), f = [], g = "number" == typeof n, p = !("function" == typeof n || g || !n); for (u = 0; u < s.length; u++) { for (var _ = s[u], v = r[u], m = _.length, y = i ? new Array(m) : new Uint32Array(m), b = new Array(m), x = 0; x < m; x++) { var E = _[x], A = l.get(E), S = d.get(E), w = e || v === A ? S : A; i && (w = c.get(w)), y[x] = w, n && (g && (b[x] = n), "function" == typeof n && (b[x] = n(a.getNode(A), a.getNode(S))), p && (b[x] = h.get(E) || 1)) } var T = C({ nodes: y, id: i ? c.get(v) : v }, n && { weights: b }); f.push(T) } return f }, li.prototype.degrees = function (t, e) { if (e !== ni.IN && e !== ni.OUT) return this._neighborTable.sizes(t); for (var i = new Array(t.length), n = e === ni.IN, r = 0, o = t.length; r < o; r++)i[r] = this._degree(t[r], n); return i }, li.prototype._degree = function (t, e) { for (var i = this._neighborTable.get(t), n = this._sourceList, r = this._targetList, o = 0, s = 0; s < i.length; ++s)for (var a = this._parallelTable.get(i[s]), u = 0; u < a.length; ++u) { var l = a[u], d = n.get(l), h = r.get(l); if (e && h === t || !e && d === t) { o += 1; break } } return o }, li.prototype.getDegree = function (t, e) { for (var i = this._getDegreeOptions(e), n = i.direction, r = i.filter, o = new Array(t.length), s = new Uint32Array(1), a = 0; a < t.length; ++a)s[0] = t[a], o[a] = this.collectAdjacentNodes(s, n, r).length; return o }, li.prototype._getDegreeOptions = function (t) { var e = { direction: ni.BOTH, filter: "visible" }; return "string" == typeof t ? e.direction = t : t && ("string" == typeof t.direction && (e.direction = t.direction), "string" == typeof t.filter && (e.filter = t.filter)), e }, li); function li(t) { this._parallelEdgesIndex = [], this._fakeDeduper = { get: function () { return 0 }, set: function () { }, reset: function () { return this } }, this._fakeInvertedDeduper = { get: function () { return 1 }, set: function () { }, reset: function () { return this } }, this._sourceList = null, this._targetList = null, this._graph = t, this._neighborTable = new oi, this._parallelTable = new oi, this._parallelEdgesIndex = [], this.nodeDeduper = t.createNodeAttribute({ storage: 1 }), this.edgeDeduper = t.createEdgeAttribute({ storage: 1 }), this._sourceList = t.getEdgeAttribute("source"), this._targetList = t.getEdgeAttribute("target") } function di(t, e) { var i = t < e ? t : e; return 67108864 * i + (t + e - i) } function hi(t) { dt || console.warn(Jt() + " " + t) } function ci(t) { "object" == typeof t && null !== t || (t = {}); var e = "function" == typeof t.data ? t.data : function (t) { return t }; return { attributes: Array.isArray(t.attributes) ? t.attributes : void 0, data: e } } function fi(t) { 1 < t && hi("getData: more than one argument were specified, you probably want to use a single array argument instead of multiple arguments") } function gi(t, i) { for (var e = function (t) { var e = i; Object.keys(e).forEach(function (i) { var n = e[i]; t.prototype[i] = function (t, e) { return hi('Deprecated method "' + i + '"; please use "' + n + '" instead.'), this[n](t, e) } }) }, n = 0, r = t; n < r.length; n++) { e(r[n]) } } function pi(t) { var e = t.getFlexArray("removed"), i = t.getFlexArray("excluded"), n = t.getFlexArray("virtual"); return { all: function (t) { return 0 === e.get(t) }, visible: function (t) { return 0 === i.get(t) }, raw: function (t) { return 0 === n.get(t) && 0 === e.get(t) }, _all: function (t) { return !0 } } } function _i(t, e, i) { return { all: vi(i.all, t, e), visible: vi(i.visible, t, e), raw: vi(i.raw, t, e), _all: vi(i._all, t, e) } } function vi(n, r, o) { var s = null; return { getList: function () { if (!s) { var t = r(), e = o(); e.reset(); for (var i = 1; i <= t; ++i)n(i) && e.push(i); s = e.sliceAndReset() } return s }, invalidList: function () { s = null } } } function mi(t) { if (void 0 === t) return Math.round(Math.random() * Number.MAX_SAFE_INTEGER); if ("string" != typeof t && ("number" != typeof t || !isFinite(t))) throw new Error(t + " is not a valid id, expected string or number"); return t } function yi(t, e, i) { for (var n = t.getObjectList(e.isNode), r = 0; r < e._indexes.length; ++r) { var o = e._indexes[r]; i(n.get(o), r) } } function bi(t, e, i) { for (var n = new Array(e.size), r = t.getObjectList(e.isNode), o = 0; o < e._indexes.length; ++o) { var s = e._indexes[o], a = r.get(s); n[o] = i(a, o) } return n } function xi(t, e, i) { i = i || function () { return !0 }; for (var n = e.isNode, r = t.acquireIndexList(n), o = t.getObjectList(n), s = t.getListFactory(n), a = 0; a < e._indexes.length; ++a) { var u = e._indexes[a], l = o.get(u); if (l) i(l, a) && r.push(u) } return s(r.sliceAndReset()) } function Ei(t, e, i, n) { var r = t.getListFactory(e.isNode); if (!i) return { valid: e, invalid: r() }; for (var o = t.acquireIndexList(e.isNode), s = t.acquireIndexList(e.isNode), a = t.getObjectList(e.isNode), u = 0; u < e._indexes.length; u++) { var l = e._indexes[u], d = a.get(l); if (void 0 !== d) (i(d, n) ? o : s).pushUnchecked(l) } return { valid: r(o.sliceAndReset()), invalid: r(s.sliceAndReset()) } } function Ai(t, e, i, n) { for (var r = t.getObjectList(e.isNode), o = n, s = 0; s < e._indexes.length; ++s) { var a = e._indexes[s]; o = i(o, r.get(a), s) } return o } function Si(t, e) { for (var i = e.isNode, n = t.topology.getDeduper(i), r = t.acquireIndexList(i), o = t.getListFactory(i), s = 0; s < e._indexes.length; s++) { var a = e._indexes[s]; 0 === n.get(a) && (n.set(a, 1), r.push(a)) } return o(r.sliceAndReset()) } function wi(t, e) { for (var i = e.isNode, n = t.storage.fetch(i), r = n.getFlexArray("excluded"), o = n.getMaxIndex(), s = t.topology.getDeduper(i), a = t.acquireIndexList(i), u = t.getListFactory(i), l = 0; l < e._indexes.length; l++)s.set(e._indexes[l], 1); for (var d = 1; d <= o; ++d)0 === s.get(d) && 0 === r.get(d) && a.push(d); return u(a.sliceAndReset()) } function Ti(t, e, i) { var n = t.getListFactory(e.isNode), r = new Uint32Array(e._indexes.length + i._indexes.length); return r.set(e._indexes), r.set(i._indexes, e._indexes.length), n(r) } function Ci(t, e) { return t.getObjectList(e.isNode).getMultiple(e._indexes) } function Mi(t, e) { var i = t.getStorage(e.isNode); if (e.isList) { for (var n = new Array(e.size), r = 0; r < e._indexes.length; ++r)n[r] = i.getId(e._indexes[r]); return n } return i.getId(e._index) } function Ii(t, e) { return t.topology.getExtremity(!0, e) } function Li(t, e) { return t.topology.getExtremity(!1, e) } function Ni(t, e, i) { return t.getObjectList(e.isNode).get(e._indexes[i]) } function ki(t, e, r) { var i = t.getListFactory(e.isNode), o = t.getObjectList(e.isNode), n = e._indexes.slice(); return n.sort(function (t, e) { var i = o.get(t), n = o.get(e); return r(i, n) }), i(n) } var Oi = new Uint32Array(1), Fi = (Object.defineProperty(Ri.prototype, "_indexes", { get: function () { return Oi[0] = this._index, Oi }, enumerable: !0, configurable: !0 }), Ri.prototype.setAttributes = function (t, e, i) { return this._ogma.modules.individualAttributes.setMultipleAttributes(this, t, e, i) }, Ri.prototype.setAttribute = function (t, value, e) { return this._ogma.modules.individualAttributes.setSingleAttribute(this, t, value, e) }, Ri.prototype.getAttributes = function (t) { return this._ogma.modules.individualAttributes.getMultipleAttributes(this, t)[0] }, Ri.prototype.getAttribute = function (t) { return this._ogma.modules.individualAttributes.getSingleAttribute(this, t)[0] }, Ri.prototype.resetAttributes = function (t, e) { return this._ogma.modules.individualAttributes.resetMultipleAttributes(this, t, e) }, Ri.prototype.replaceOriginalAttributes = function (t, e) { return this._ogma.modules.individualAttributes.replaceOriginalAttributes(this, t, e) }, Ri.prototype.getPreviousAttributes = function (t) { return this._ogma.modules.individualAttributes.getMultiplePreviousAttributes(this, t)[0] }, Ri.prototype.isInView = function (t) { return this._ogma.modules.locate.isElementInView(this, t) }, Ri.prototype.getParallelEdges = function (t) { return this._ogma.modules.graph.getParallelEdges(this, t) }, Ri.prototype.fastGetAdjacentElements = function () { return this._ogma.modules.graph.fastGetEdgesAdjacentElements(this) }, Ri.prototype.isVisible = function () { return !this.isExcluded() }, Ri.prototype.isExcluded = function () { return this._ogma.modules.graph.isExcluded(this)[0] }, Ri.prototype.setExcluded = function (value) { return this._ogma.modules.graph.setExcluded(this, value) }, Ri.prototype.setVisible = function (value) { return this.setExcluded(!value) }, Ri.prototype.toList = function () { return this._ogma.modules.graph.edgeList(new Uint32Array([this._index])) }, Ri.prototype.getId = function () { return Mi(this._ogma.modules.graph, this) }, Ri.prototype.getSource = function () { return Ii(this._ogma.modules.graph, this) }, Ri.prototype.getTarget = function () { return Li(this._ogma.modules.graph, this) }, Ri.prototype.getExtremities = function () { return this._ogma.modules.graph.nodeList(new Uint32Array([this.getSource()._index, this.getTarget()._index])) }, Ri.prototype.setSource = function (t) { this._ogma.modules.graph.setSource(this, t) }, Ri.prototype.setTarget = function (t) { this._ogma.modules.graph.setTarget(this, t) }, Ri.prototype.slice = function () { return this.toList() }, Ri.prototype.toJSON = function (t) { void 0 === t && (t = {}); var e = ci(t), i = e.attributes, n = e.data; return { id: this.getId(), source: this.getSource().getId(), target: this.getTarget().getId(), attributes: this.getAttributes(i), data: n(j(this.getData())) } }, Ri.prototype.get = function (t) { return 0 === t ? this : void 0 }, Ri.prototype.setSelected = function (t) { this._ogma.modules.selection.setActive(this, t) }, Ri.prototype.isSelected = function () { return this._ogma.modules.selection.areActive(this) }, Ri.prototype.locate = function (t) { return this._ogma.modules.locate.locateElements(this, t) }, Ri.prototype.getBoundingBox = function (t) { return this._ogma.modules.locate.getBoundingBox(this, t) }, Ri.prototype.setData = function (t, value) { return arguments.length < 2 && (value = t, t = null), this._ogma.modules.data.setProperty(this, t, value), this }, Ri.prototype.getData = function (t) { return fi(arguments.length), this._ogma.modules.data.getProperty(this, t)[0] }, Ri.prototype.addClass = function (t, e) { return this._ogma.modules.classes.addClassesToElements([t], this, e) }, Ri.prototype.addClasses = function (t, e) { return this._ogma.modules.classes.addClassesToElements(t, this, e) }, Ri.prototype.removeClass = function (t, e) { return this._ogma.modules.classes.removeClassesFromElements([t], this, e) }, Ri.prototype.removeClasses = function (t, e) { return this._ogma.modules.classes.removeClassesFromElements(t, this, e) }, Ri.prototype.hasClass = function (t) { return this._ogma.modules.classes.hasSingleElementClass(t, this) }, Ri.prototype.getClassList = function () { return this._ogma.modules.classes.getElementsClassList(this)[0] }, Ri.prototype.getAnimationInformation = function () { return this._ogma.modules.graphics.getAnimationInformation(this)[0] }, Ri.prototype.isVirtual = function () { return this._ogma.modules.transformations.isElementVirtual(this) }, Ri.prototype.getTransformation = function () { return this._ogma.modules.transformations.getElementTransformation(this) }, Ri.prototype.getMetaEdge = function () { return this._ogma.modules.grouping.getMetaElement(this)[0] }, Ri.prototype.getSubEdges = function () { return this._ogma.modules.grouping.getSubElements(this)[0] }, Ri.prototype.pulse = function (t) { this._ogma.modules.pulses.pulse(this, t) }, Ri); function Ri(t, e) { this.size = 1, this.isNode = !1, this.isList = !1, this._index = t, this._ogma = e } gi([Fi], { setStyle: "setAttributes", resetStyle: "resetAttributes", getStyle: "getAttribute" }); var Pi = (Object.defineProperty(Di.prototype, "size", { get: function () { return this._indexes.length }, enumerable: !0, configurable: !0 }), Di.prototype.setAttributes = function (t, e) { return this._ogma.modules.individualAttributes.setMultipleAttributes(this, t, e) }, Di.prototype.setAttribute = function (t, value, e) { return this._ogma.modules.individualAttributes.setSingleAttribute(this, t, value, e) }, Di.prototype.getAttributes = function (t) { return this._ogma.modules.individualAttributes.getMultipleAttributes(this, t) }, Di.prototype.getAttribute = function (t) { return this._ogma.modules.individualAttributes.getSingleAttribute(this, t) }, Di.prototype.resetAttributes = function (t, e) { return this._ogma.modules.individualAttributes.resetMultipleAttributes(this, t, e) }, Di.prototype.replaceOriginalAttributes = function (t, e) { return this._ogma.modules.individualAttributes.replaceOriginalAttributes(this, t, e) }, Di.prototype.getPreviousAttributes = function (t) { return this._ogma.modules.individualAttributes.getMultiplePreviousAttributes(this, t) }, Di.prototype.getPreviousAttribute = function (t) { return this._ogma.modules.individualAttributes.getSinglePreviousAttribute(this, t) }, Di.prototype.getParallelEdges = function (t) { return this._ogma.modules.graph.getParallelEdges(this, t) }, Di.prototype.fastGetAdjacentElements = function () { return this._ogma.modules.graph.fastGetEdgesAdjacentElements(this) }, Di.prototype.isVisible = function () { return this.isExcluded().map(function (value) { return !value }) }, Di.prototype.isExcluded = function () { return this._ogma.modules.graph.isExcluded(this) }, Di.prototype.setExcluded = function (value) { return this._ogma.modules.graph.setExcluded(this, value) }, Di.prototype.setVisible = function (value) { return this.setExcluded(!value) }, Di.prototype.toList = function () { return this }, Di.prototype.toArray = function () { return Ci(this._ogma.modules.graph, this) }, Di.prototype.clone = function () { return this._ogma.modules.graph.edgeList(this._indexes.slice()) }, Di.prototype.getId = function () { return Mi(this._ogma.modules.graph, this) }, Di.prototype.getSource = function () { return Ii(this._ogma.modules.graph, this) }, Di.prototype.getTarget = function () { return Li(this._ogma.modules.graph, this) }, Di.prototype.getExtremities = function () { return this.getSource().concat(this.getTarget()) }, Di.prototype.get = function (t) { return Ni(this._ogma.modules.graph, this, t) }, Di.prototype.forEach = function (t) { yi(this._ogma.modules.graph, this, t) }, Di.prototype.map = function (t) { return bi(this._ogma.modules.graph, this, t) }, Di.prototype.filter = function (t) { return xi(this._ogma.modules.graph, this, t) }, Di.prototype.reduce = function (t, e) { return Ai(this._ogma.modules.graph, this, t, e) }, Di.prototype.concat = function (t) { return Ti(this._ogma.modules.graph, this, t) }, Di.prototype.dedupe = function () { return Si(this._ogma.modules.graph, this) }, Di.prototype.slice = function (t, e) { return this._ogma.modules.graph.edgeList(this._indexes.slice(t, e)) }, Di.prototype.indexOf = function (t) { return t instanceof Fi ? this._indexes.indexOf(t._index) : -1 }, Di.prototype.includes = function (t) { return -1 !== this.indexOf(t) }, Di.prototype.sort = function (t) { return ki(this._ogma.modules.graph, this, t) }, Di.prototype.inverse = function () { return wi(this._ogma.modules.graph, this) }, Di.prototype.toJSON = function (e) { return void 0 === e && (e = {}), this.map(function (t) { return t.toJSON(e) }) }, Di.prototype.setSelected = function (t) { this._ogma.modules.selection.setActive(this, t) }, Di.prototype.isSelected = function () { return this._ogma.modules.selection.areActive(this) }, Di.prototype.locate = function (t) { return this._ogma.modules.locate.locateElements(this, t) }, Di.prototype.getBoundingBox = function (t) { return this._ogma.modules.locate.getBoundingBox(this, t) }, Di.prototype.setData = function (t, e) { if (arguments.length < 2 && (e = t, t = null), "function" != typeof e && !I(e)) throw new Error("invalid argument " + e + "; expected array or function"); return this._ogma.modules.data.setProperty(this, t, e, { dispatch: !0 }), this }, Di.prototype.fillData = function (t, value) { return arguments.length < 2 && (value = t, t = null), this._ogma.modules.data.setProperty(this, t, value, { dispatch: !1 }), this }, Di.prototype.getData = function (t) { return fi(arguments.length), this._ogma.modules.data.getProperty(this, t) }, Di.prototype.addClass = function (t, e) { return this._ogma.modules.classes.addClassesToElements([t], this, e) }, Di.prototype.addClasses = function (t, e) { return this._ogma.modules.classes.addClassesToElements(t, this, e) }, Di.prototype.removeClass = function (t, e) { return this._ogma.modules.classes.removeClassesFromElements([t], this, e) }, Di.prototype.removeClasses = function (t, e) { return this._ogma.modules.classes.removeClassesFromElements(t, this, e) }, Di.prototype.hasClass = function (e) { var i = this; return this.map(function (t) { return i._ogma.modules.classes.hasSingleElementClass(e, t) }) }, Di.prototype.getClassList = function () { return this._ogma.modules.classes.getElementsClassList(this) }, Di.prototype.getAnimationInformation = function () { return this._ogma.modules.graphics.getAnimationInformation(this) }, Di.prototype.getMetaEdge = function () { return this._ogma.modules.grouping.getMetaElement(this) }, Di.prototype.getSubEdges = function () { return this._ogma.modules.grouping.getSubElements(this) }, Di.prototype.pulse = function (t) { this._ogma.modules.pulses.pulse(this, t) }, Di); function Di(t, e) { this.isList = !0, this.isNode = !1, this._indexes = t, this._ogma = e } gi([Pi], { setStyle: "setAttributes", resetStyle: "resetAttributes", getStyle: "getAttribute" }); var zi = "geo.latitude", Bi = "geo.longitude", Ui = 85.0511287798, Vi = { latitudePath: "latitude", longitudePath: "longitude", maxZoomLevel: 22, minZoomLevel: 0, wrapCoordinates: !0, tileUrlTemplate: "https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}{r}.png", tileUrlSubdomains: "abc", attribution: null, attributionOptions: void 0, backgroundColor: "silver", opacity: 1, duration: 0, detectRetina: !1, disableNodeDragging: !0, tileBuffer: 1, sizeRatio: 1, tiles: { url: "https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}{r}.png", subdomains: "abc", tms: !1, wms: !1 }, crs: null }, ji = { maxBoundsViscosity: 1, worldCopyJump: !0, zoomControl: !1, attributionControl: !1 }; function Gi() { return ct || "undefined" != typeof global && !global.process } function Hi(t) { return Math.log2(t) + 1 } function qi(t) { return null != t && !isNaN(t) } function Wi(t, e) { return Yi(t, e, "longitude") } function Xi(t, e) { return Yi(t, e, "latitude") } function Yi(t, e, i) { if (isNaN(e)) throw new TypeError("node " + t + ": " + e + " is not a valid " + i) } var Zi = yt().createElement("div"); function Ki(t, e, i, n) { var r, o, s, a, u, l, d, h; o = !0, s = e, a = i, u = n, l = (r = t).getAttribute(o, a), d = r.getAttribute(o, u), h = s._indexes, d.setMultiple(h, l.getMultiple(h)) } var Qi = new Uint32Array(1), Ji = (Object.defineProperty($i.prototype, "_indexes", { get: function () { return Qi[0] = this._index, Qi }, enumerable: !0, configurable: !0 }), $i.prototype.setAttributes = function (t, e) { return this._ogma.modules.individualAttributes.setMultipleAttributes(this, t, e) }, $i.prototype.setAttribute = function (t, value, e) { return this._ogma.modules.individualAttributes.setSingleAttribute(this, t, value, e) }, $i.prototype.resetAttributes = function (t, e) { return this._ogma.modules.individualAttributes.resetMultipleAttributes(this, t, e) }, $i.prototype.getAttributes = function (t) { return this._ogma.modules.individualAttributes.getMultipleAttributes(this, t)[0] }, $i.prototype.getAttribute = function (t) { return this._ogma.modules.individualAttributes.getSingleAttribute(this, t)[0] }, $i.prototype.getPosition = function () { return this.getAttributes(["x", "y"]) }, $i.prototype.getPositionOnScreen = function () { return this._ogma.modules.camera.graphToScreenCoordinates(this.getPosition()) }, $i.prototype.isInScreen = function () { var t = this.getPositionOnScreen(), e = this._ogma.modules.camera; return 0 <= t.x && t.x <= e.width && 0 <= t.y && t.y <= e.height }, $i.prototype.replaceOriginalAttributes = function (t, e) { return this._ogma.modules.individualAttributes.replaceOriginalAttributes(this, t, e) }, $i.prototype.getPreviousAttributes = function (t) { return this._ogma.modules.individualAttributes.getMultiplePreviousAttributes(this, t)[0] }, $i.prototype.isInView = function (t) { return this._ogma.modules.locate.isElementInView(this, t) }, $i.prototype.getAdjacentNodes = function (t) { return this._ogma.modules.graph.getAdjacentNodes(this, t) }, $i.prototype.getAdjacentEdges = function (t) { return this._ogma.modules.graph.getAdjacentEdges(this, t) }, $i.prototype.getDegree = function (t) { return this._ogma.modules.graph.getDegree(this, t)[0] }, $i.prototype.fastGetAdjacentElements = function () { return this._ogma.modules.graph.fastGetNodesAdjacentElements(this) }, $i.prototype.getConnectedComponent = function (t) { return this._ogma.modules.graph.getConnectedComponentByNode(this, t)[0] }, $i.prototype.isVisible = function () { return !this.isExcluded() }, $i.prototype.isExcluded = function () { return this._ogma.modules.graph.isExcluded(this)[0] }, $i.prototype.setExcluded = function (value) { return this._ogma.modules.graph.setExcluded(this, value) }, $i.prototype.setVisible = function (value) { return this.setExcluded(!value) }, $i.prototype.toList = function () { return this._ogma.nodeList(new Uint32Array([+this._index])) }, $i.prototype.getId = function () { return Mi(this._ogma.modules.graph, this) }, $i.prototype.slice = function () { return this.toList() }, $i.prototype.toJSON = function (t) { void 0 === t && (t = {}); var e = ci(t), i = e.attributes, n = e.data; return { id: this.getId(), attributes: this.getAttributes(i), data: n(j(this.getData())) } }, $i.prototype.get = function (t) { return 0 === t ? this : void 0 }, $i.prototype.setSelected = function (t) { this._ogma.modules.selection.setActive(this, t) }, $i.prototype.isSelected = function () { return this._ogma.modules.selection.areActive(this) }, $i.prototype.locate = function (t) { return this._ogma.modules.locate.locateElements(this, t) }, $i.prototype.getBoundingBox = function () { return this._ogma.modules.locate.getBoundingBox(this) }, $i.prototype.setData = function (t, value) { return arguments.length < 2 && (value = t, t = null), this._ogma.modules.data.setProperty(this, t, value), this }, $i.prototype.getData = function (t) { return fi(arguments.length), this._ogma.modules.data.getProperty(this, t)[0] }, $i.prototype.addClass = function (t, e) { return this._ogma.modules.classes.addClassesToElements([t], this, e) }, $i.prototype.addClasses = function (t, e) { return this._ogma.modules.classes.addClassesToElements(t, this, e) }, $i.prototype.removeClass = function (t, e) { return this._ogma.modules.classes.removeClassesFromElements([t], this, e) }, $i.prototype.removeClasses = function (t, e) { return this._ogma.modules.classes.removeClassesFromElements(t, this, e) }, $i.prototype.hasClass = function (t) { return this._ogma.modules.classes.hasSingleElementClass(t, this) }, $i.prototype.getClassList = function () { return this._ogma.modules.classes.getElementsClassList(this)[0] }, $i.prototype.getGeoCoordinates = function () { var t = this._ogma.modules.graph, e = t.getNodeAttribute(zi).get(this._index), i = t.getNodeAttribute(Bi).get(this._index); return { latitude: qi(e) ? e : void 0, longitude: qi(i) ? i : void 0 } }, $i.prototype.setGeoCoordinates = function (t) { var e = this; return this.toList().setGeoCoordinates([t]).then(function () { return e }) }, $i.prototype.getAnimationInformation = function () { return this._ogma.modules.graphics.getAnimationInformation(this)[0] }, $i.prototype.isVirtual = function () { return this._ogma.modules.transformations.isElementVirtual(this) }, $i.prototype.getTransformation = function () { return this._ogma.modules.transformations.getElementTransformation(this) }, $i.prototype.getMetaNode = function () { return this._ogma.modules.grouping.getMetaElement(this)[0] }, $i.prototype.getSubNodes = function () { return this._ogma.modules.grouping.getSubElements(this)[0] }, $i.prototype.pulse = function (t) { this._ogma.modules.pulses.pulse(this, t) }, $i); function $i(t, e) { this.size = 1, this.isNode = !0, this.isList = !1, this._index = t, this._ogma = e } gi([Ji], { setStyle: "setAttributes", resetStyle: "resetAttributes", getStyle: "getAttribute", setPosition: "setAttributes" }); var tn = (Object.defineProperty(en.prototype, "size", { get: function () { return this._indexes.length }, enumerable: !0, configurable: !0 }), en.prototype.setAttributes = function (t, e) { return this._ogma.modules.individualAttributes.setMultipleAttributes(this, t, e) }, en.prototype.setAttribute = function (t, e, i) { return this._ogma.modules.individualAttributes.setSingleAttribute(this, t, e, i) }, en.prototype.getAttributes = function (t) { return this._ogma.modules.individualAttributes.getMultipleAttributes(this, t) }, en.prototype.getAttribute = function (t) { return this._ogma.modules.individualAttributes.getSingleAttribute(this, t) }, en.prototype.resetAttributes = function (t, e) { return this._ogma.modules.individualAttributes.resetMultipleAttributes(this, t, e) }, en.prototype.getPosition = function () { return this.getAttributes(["x", "y"]) }, en.prototype.getPositionOnScreen = function () { var e = this; return this.getPosition().map(function (t) { return e._ogma.modules.camera.graphToScreenCoordinates(t) }) }, en.prototype.replaceOriginalAttributes = function (t, e) { return this._ogma.modules.individualAttributes.replaceOriginalAttributes(this, t, e) }, en.prototype.getPreviousAttributes = function (t) { return this._ogma.modules.individualAttributes.getMultiplePreviousAttributes(this, t) }, en.prototype.getPreviousAttribute = function (t) { return this._ogma.modules.individualAttributes.getSinglePreviousAttribute(this, t) }, en.prototype.getAdjacentNodes = function (t) { return this._ogma.modules.graph.getAdjacentNodes(this, t) }, en.prototype.getAdjacentEdges = function (t) { return this._ogma.modules.graph.getAdjacentEdges(this, t) }, en.prototype.getDegree = function (t) { return this._ogma.modules.graph.getDegree(this, t) }, en.prototype.getConnectedComponents = function (t) { return this._ogma.modules.graph.getConnectedComponents(this, t) }, en.prototype.fastGetAdjacentElements = function () { return this._ogma.modules.graph.fastGetNodesAdjacentElements(this) }, en.prototype.isVisible = function () { return this.isExcluded().map(function (value) { return !value }) }, en.prototype.isExcluded = function () { return this._ogma.modules.graph.isExcluded(this) }, en.prototype.setExcluded = function (value) { return this._ogma.modules.graph.setExcluded(this, value) }, en.prototype.setVisible = function (value) { return this.setExcluded(!value) }, en.prototype.toList = function () { return this }, en.prototype.toArray = function () { return Ci(this._ogma.modules.graph, this) }, en.prototype.clone = function () { return this._ogma.modules.graph.nodeList(this._indexes.slice()) }, en.prototype.getId = function () { return Mi(this._ogma.modules.graph, this) }, en.prototype.get = function (t) { return Ni(this._ogma.modules.graph, this, t) }, en.prototype.forEach = function (t) { yi(this._ogma.modules.graph, this, t) }, en.prototype.map = function (t) { return bi(this._ogma.modules.graph, this, t) }, en.prototype.filter = function (t) { return xi(this._ogma.modules.graph, this, t) }, en.prototype.reduce = function (t, e) { return Ai(this._ogma.modules.graph, this, t, e) }, en.prototype.concat = function (t) { return Ti(this._ogma.modules.graph, this, t) }, en.prototype.dedupe = function () { return Si(this._ogma.modules.graph, this) }, en.prototype.slice = function (t, e) { return this._ogma.modules.graph.nodeList(this._indexes.slice(t, e)) }, en.prototype.indexOf = function (t) { return t instanceof Ji ? this._indexes.indexOf(t._index) : -1 }, en.prototype.includes = function (t) { return -1 !== this.indexOf(t) }, en.prototype.inverse = function () { return wi(this._ogma.modules.graph, this) }, en.prototype.sort = function (t) { return ki(this._ogma.modules.graph, this, t) }, en.prototype.toJSON = function (e) { return void 0 === e && (e = {}), this.map(function (t) { return t.toJSON(e) }) }, en.prototype.setSelected = function (t) { this._ogma.modules.selection.setActive(this, t) }, en.prototype.isSelected = function () { return this._ogma.modules.selection.areActive(this) }, en.prototype.locate = function (t) { return this._ogma.modules.locate.locateElements(this, t) }, en.prototype.getBoundingBox = function () { return this._ogma.modules.locate.getBoundingBox(this) }, en.prototype.setData = function (t, e) { if (arguments.length < 2 && (e = t, t = null), "function" != typeof e && !I(e)) throw new Error("invalid argument " + e + "; expected array or function"); return this._ogma.modules.data.setProperty(this, t, e, { dispatch: !0 }), this }, en.prototype.fillData = function (t, value) { return arguments.length < 2 && (value = t, t = null), this._ogma.modules.data.setProperty(this, t, value, { dispatch: !1 }), this }, en.prototype.getData = function (t) { return fi(arguments.length), this._ogma.modules.data.getProperty(this, t) }, en.prototype.addClass = function (t, e) { return this._ogma.modules.classes.addClassesToElements([t], this, e) }, en.prototype.addClasses = function (t, e) { return this._ogma.modules.classes.addClassesToElements(t, this, e) }, en.prototype.removeClass = function (t, e) { return this._ogma.modules.classes.removeClassesFromElements([t], this, e) }, en.prototype.removeClasses = function (t, e) { return this._ogma.modules.classes.removeClassesFromElements(t, this, e) }, en.prototype.hasClass = function (e) { var i = this; return this.map(function (t) { return i._ogma.modules.classes.hasSingleElementClass(e, t) }) }, en.prototype.getClassList = function () { return this._ogma.modules.classes.getElementsClassList(this) }, en.prototype.getGeoCoordinates = function () { for (var t = this._ogma.modules.graph, e = new Array(this._indexes.length), i = t.getNodeAttribute(zi).getMultiple(this._indexes), n = t.getNodeAttribute(Bi).getMultiple(this._indexes), r = 0, o = this._indexes.length; r < o; r++)e[r] = { latitude: i[r], longitude: n[r] }; return e }, en.prototype.setGeoCoordinates = function (t) { var e = this, i = this._ogma.modules.geo, n = this._ogma.modules.graph, r = this.getId(), o = this._indexes, s = new Array(o.length), a = new Array(o.length); if (null === t && (t = new Array(o.length).fill(null)), t.length !== o.length) throw new RangeError("You must provide coordinates for each node in the NodeList"); for (var u = 0, l = o.length; u < l; u++) { var d = t[u] || { latitude: null, longitude: null }, h = d.latitude, c = d.longitude, f = r[u]; null == h && null == c ? h = c = void 0 : (Xi(f, h), Wi(f, c)), s[u] = h, a[u] = c } return this.setData(i.latitudePath, s), this.setData(i.longitudePath, a), n.getNodeAttribute(zi).setMultiple(o, s), n.getNodeAttribute(Bi).setMultiple(o, a), this._ogma.modules.transformations.refresh().then(function () { return e }) }, en.prototype.getAnimationInformation = function () { return this._ogma.modules.graphics.getAnimationInformation(this) }, en.prototype.getMetaNode = function () { return this._ogma.modules.grouping.getMetaElement(this) }, en.prototype.getSubNodes = function () { return this._ogma.modules.grouping.getSubElements(this) }, en.prototype.pulse = function (t) { this._ogma.modules.pulses.pulse(this, t) }, en); function en(t, e) { this.isList = !0, this.isNode = !0, this._indexes = t, this._ogma = e } function nn(t, e, i, n) { return void 0 === i && (i = {}), void 0 === n && (n = {}), on(t, e, [i], n).get(0) } function rn(n, r, t, o) { if (void 0 === o && (o = {}), o.batchSize) { for (var e = [], i = 0; i < t.length; i += o.batchSize)e.push(t.slice(i, i + o.batchSize)); return e.reduce(function (t, e) { var i = null; return t.then(function (t) { return i = t, n.getDom().afterNextFrame() }).then(function () { return on(n, r, e, o) }).then(function (t) { return i.concat(t) }) }, Promise.resolve(r ? n.nodeList() : n.edgeList())) } return Promise.resolve(on(n, r, t, o)) } function on(t, e, i, n) { for (var r = t.storage.fetch(e), o = [], s = [], a = [], u = [], l = new Set, d = n.virtual, h = void 0 !== d && d, c = 0, f = i; c < f.length; c++) { var g = f[c]; if ("object" != typeof g || null === g || Array.isArray(g)) throw new Error(g + " is not a valid " + (e ? "node" : "edge")); var p = mi(g.id); if (!r.getIndex(p, !1) && !l.has(p) && (s.push(p), o.push(g), l.add(p), !e)) { var _ = g, v = t.getExtremityIndex(p, _.source, "source"), m = t.getExtremityIndex(p, _.target, "target"); a.push(v), u.push(m) } } var y = r.addElements(s); e ? t.topology.allocateNodes(y) : t.topology.allocateEdges(y, a, u); for (var b = r.getFlexArray("object"), x = r.getFlexArray("excluded"), E = r.getFlexArray("removed"), A = r.getFlexArray("virtual"), S = e ? t.node : t.edge, w = e ? t.nodeList : t.edgeList, T = t.getCacheLists(e), C = w(y), M = 0; M < y.length; M++) { var I = y[M]; b.set(I, S(I)) } return x.setMultiple(y, 0), E.setMultiple(y, 0), A.setMultiple(y, h ? 1 : 0), T.visible.invalidList(), T.all.invalidList(), T._all.invalidList(), h || T.raw.invalidList(), 0 !== C.size && (e ? t.fireEvent(xe.ADD_NODES, { virtual: h, objects: o, nodes: C }) : t.fireEvent(xe.ADD_EDGES, { virtual: h, objects: o, edges: C })), C } gi([tn], { setStyle: "setAttributes", resetStyle: "resetAttributes", getStyle: "getAttribute", setPosition: "setAttributes" }); var sn, an = (b(un, sn = Ae), un.prototype.onMounted = function (t, e) { if (e.graph) { var i = e.graph, n = i.nodes, r = i.edges; n && this.addNodes(n), r && this.addEdges(r) } }, un.prototype.createIndexList = function (t) { return this.storage.fetch(t).createIndexList() }, un.prototype.setIndexFreeStep = function (t) { this._indexFreeStep = t }, un.prototype.getDom = function () { return this._dom }, un.prototype.acquireIndexList = function (t) { var e = t ? this._nodeIndexLists : this._edgeIndexLists, i = e.find(function (t) { return !t.isBusy() }); return i || (i = this.createIndexList(t), e.push(i)), i.markBusy(), i }, un.prototype.getObjectList = function (t) { return t ? this._nodes : this._edges }, un.prototype.getListFactory = function (t) { return t ? this.nodeList : this.edgeList }, un.prototype.getStorage = function (t) { return t ? this.storage.nodes : this.storage.edges }, un.prototype.getFilter = function (t, e) { var i = t ? this._nodeFilters : this._edgeFilters; return i[e] || i.visible }, un.prototype.fireEvent = function (t, e) { this._events.fire(t, e) }, un.prototype.getCacheLists = function (t) { return t ? this._nodeCacheLists : this._edgeCacheLists }, un.prototype._resolvePromises = function () { var t = this._promisesToResolve; this._promisesToResolve = [], t.forEach(function (t) { return t() }) }, un.prototype._initialize = function () { var t = this; this._nodeCacheLists = _i(function () { return t.getNodeMaxIndex() }, function () { return t.acquireIndexList(!0) }, this._nodeFilters), this._edgeCacheLists = _i(function () { return t.getEdgeMaxIndex() }, function () { return t.acquireIndexList(!1) }, this._edgeFilters), this.topology = new ui(this), this._resolvePromises() }, un.prototype.getNodeMaxIndex = function () { return this.storage.nodes.getMaxIndex() }, un.prototype.getEdgeMaxIndex = function () { return this.storage.edges.getMaxIndex() }, un.prototype.isExcluded = function (t) { return this.storage.fetch(t.isNode).getFlexArray("excluded").getMultiple(t._indexes) }, un.prototype.setExcluded = function (t, value) { for (var e = value ? 1 : 0, i = t.isNode, n = this.storage.fetch(i), r = n.getFlexArray("excluded"), o = n.getFlexArray("removed"), s = this.acquireIndexList(i), a = this.getListFactory(i), u = 0; u < t._indexes.length; u++) { var l = t._indexes[u], d = r.get(l), h = o.get(l); e !== d && 0 === h && s.push(l) } var c = s.sliceAndReset(); if (c.length) { this.getCacheLists(t.isNode).visible.invalidList(); var f = a(c); r.setMultiple(c, e), this._events.fire(xe.EXCLUDED_STATE_CHANGE, { elements: f, value: value }) } }, un.prototype.addNode = function (t, e) { return nn(this, !0, t, e) }, un.prototype.addEdge = function (t, e) { return nn(this, !1, t, e) }, un.prototype.addNodes = function (t, e) { return rn(this, !0, t, e) }, un.prototype.addEdges = function (t, e) { return rn(this, !1, t, e) }, un.prototype.getExtremityIndex = function (t, e, i) { if (e instanceof Ji) return e._index; var n = this.storage.nodes.getIndex(e); if (!n) throw new Error("addEdge(s): invalid " + i + ' for edge "' + t + '"; node "' + e + '" does not exist'); return n }, un.prototype.getNodes = function (t) { return this.getElements(!0, t) }, un.prototype.getEdges = function (t) { return this.getElements(!1, t) }, un.prototype.getElements = function (t, e) { var i = t ? this.nodeList : this.edgeList, n = t ? tn : Pi, r = t ? Ji : Fi; if (e && "string" != typeof e) { var o = this.acquireIndexList(t), s = this.storage.fetch(t); if (e instanceof r) o.push(e._index); else if (I(e)) for (var a = 0, u = e; a < u.length; a++) { var l = u[a]; l instanceof r ? o.push(l._index) : (f = s.getIndex(l)) && o.push(f) } else if (e instanceof n) for (var d = this.getFilter(t, "all"), h = e, c = 0; c < h._indexes.length; c++) { var f; d(f = h._indexes[c]) && o.push(f) } return i(o.sliceAndReset()) } var g = e || "visible", p = this.getCacheLists(t)[g]; if (!p) throw new Error('getNodes/getEdges: unexpected argument "' + g + '"'); return i(p.getList()) }, un.prototype.getNode = function (t) { return this._getElement(!0, t) }, un.prototype.getEdge = function (t) { return this._getElement(!1, t) }, un.prototype._getElement = function (t, e) { if (e instanceof (t ? Ji : Fi)) return e; var i = this.getStorage(t), n = this.getObjectList(t), r = i.getIndex(e); return r ? n.get(r) : void 0 }, un.prototype.clear = function () { this._events.fire(xe.CLEAR_GRAPH), this.storage.nodes.clear(), this.storage.edges.clear(), this._initialize() }, un.prototype.createAttribute = function (t, e) { return this.storage.fetch(t).createFlexArray(e) }, un.prototype.createNodeAttribute = function (t) { return this.createAttribute(!0, t) }, un.prototype.createEdgeAttribute = function (t) { return this.createAttribute(!1, t) }, un.prototype.getAttribute = function (t, e) { return this.storage.fetch(t).getFlexArray(e) }, un.prototype.getAttributes = function (e, t) { var i = this; return t.map(function (t) { return i.getAttribute(e, t) }) }, un.prototype.getNodeAttribute = function (t) { return this.storage.nodes.getFlexArray(t) }, un.prototype.getNodeAttributes = function (t) { return this.getAttributes(!0, t) }, un.prototype.getEdgeAttribute = function (t) { return this.storage.edges.getFlexArray(t) }, un.prototype.getEdgeAttributes = function (t) { return this.getAttributes(!1, t) }, un.prototype.getAllNodeAttributes = function () { return this.storage.nodes.getAllFlexArrays() }, un.prototype.getAllEdgeAttributes = function () { return this.storage.edges.getAllFlexArrays() }, un.prototype.setSource = function (t, e) { var i = this.getNode(e); this.topology.setExtremities(t._indexes, i._indexes, null) }, un.prototype.setTarget = function (t, e) { var i = this.getNode(e); this.topology.setExtremities(t._indexes, null, i._indexes) }, un.prototype.getParallelEdges = function (t, e) { return void 0 === e && (e = {}), this.topology.getParallelEdges(t, e) }, un.prototype.getEdgesBetweenTwoNodes = function (t, e) { return this.edgeList(this.topology.getEdgesBetweenTwoNodes(t._index, e._index)) }, un.prototype.getAdjacentDirections = function (t) { return this.topology.getAdjacentDirections(t) }, un.prototype.getEdgeIndexesInDirection = function (t) { return this.topology.getEdgeIndexesInDirection(t) }, un.prototype.fastGetNodesAdjacentElements = function (t) { return this.topology.fastGetNodesAdjacentElements(t._indexes) }, un.prototype.fastGetEdgesAdjacentElements = function (t) { return this.topology.fastGetEdgesAdjacentElements(t._indexes) }, un.prototype.getAdjacentNodes = function (t, e) { return this.nodeList(this.topology.getAdjacentElements(!0, t._indexes, e)) }, un.prototype.getAdjacentEdges = function (t, e) { return this.edgeList(this.topology.getAdjacentElements(!1, t._indexes, e)) }, un.prototype.getDegree = function (t, e) { return this.topology.getDegree(t._indexes, e) }, un.prototype.degrees = function (t, e) { return this.topology.degrees(t, e) }, un.prototype.getAdjacencyList = function (t) { var e = void 0 === t ? {} : t, i = e.directed, n = void 0 !== i && i, r = e.internalIndexes, o = void 0 !== r && r, s = e.weight, a = void 0 === s ? 1 : s, u = e.nodes, l = e.indexes; return this.topology.getAdjacencyList({ directed: n, weight: a, ids: !o, nodes: l || this.getNodes(u)._indexes }) }, un.prototype.getConnectedComponents = function (t, e) { return this.topology.getConnectedComponents(t._indexes, e) }, un.prototype.getConnectedComponentByNode = function (t, e) { return this.topology.getConnectedComponents(t._indexes, e) }, un); function un(t, e) { var i = t.dom, n = t.events, r = sn.call(this) || this; r.storage = { nodes: new ei(!0), edges: new ei(!1), fetch: function (t) { return t ? this.nodes : this.edges } }, r._promisesToResolve = [], r._indexFreeStep = 0, r._nodeIndexLists = [], r._edgeIndexLists = [], r._events = n, r._dom = i, r._events.register([xe.ADD_NODES, xe.ADD_EDGES, xe.EXCLUDED_STATE_CHANGE], [xe.CLEAR_GRAPH, xe.BEFORE_REMOVE_NODES, xe.REMOVE_NODES, xe.BEFORE_REMOVE_EDGES, xe.REMOVE_EDGES]); return [{ name: "excluded", storage: 1, default: 1 }, { name: "removed", storage: 1, default: 1 }, { name: "virtual", storage: 1, default: 0 }].forEach(function (t) { r.createNodeAttribute(t), r.createEdgeAttribute(t) }), r.node = e.node, r.edge = e.edge, r.nodeList = e.nodeList, r.edgeList = e.edgeList, r._nodes = r.createAttribute(!0, { name: "object", storage: "any" }), r._edges = r.createAttribute(!1, { name: "object", storage: "any" }), r.createAttribute(!1, { name: "source", storage: 32 }), r.createAttribute(!1, { name: "target", storage: 32 }), r._nodeFilters = pi(r.storage.nodes), r._edgeFilters = pi(r.storage.edges), r._initialize(), r._events.on({ newFrame: function () { 1 === r._indexFreeStep ? r._indexFreeStep = 2 : 2 === r._indexFreeStep && (r.storage.nodes.freeIndexes(), r.storage.edges.freeIndexes(), r._indexFreeStep = 0) } }), r } var ln = ["AliceBlue", "#F0F8FF", "AntiqueWhite", "#FAEBD7", "Aqua", "#00FFFF", "Aquamarine", "#7FFFD4", "Azure", "#F0FFFF", "Beige", "#F5F5DC", "Bisque", "#FFE4C4", "Black", "#000000", "BlanchedAlmond", "#FFEBCD", "Blue", "#0000FF", "BlueViolet", "#8A2BE2", "Brown", "#A52A2A", "BurlyWood", "#DEB887", "CadetBlue", "#5F9EA0", "Chartreuse", "#7FFF00", "Chocolate", "#D2691E", "Coral", "#FF7F50", "CornflowerBlue", "#6495ED", "Cornsilk", "#FFF8DC", "Crimson", "#DC143C", "Cyan", "#00FFFF", "DarkBlue", "#00008B", "DarkCyan", "#008B8B", "DarkGoldenRod", "#B8860B", "DarkGray", "#A9A9A9", "DarkGrey", "#A9A9A9", "DarkGreen", "#006400", "DarkKhaki", "#BDB76B", "DarkMagenta", "#8B008B", "DarkOliveGreen", "#556B2F", "DarkOrange", "#FF8C00", "DarkOrchid", "#9932CC", "DarkRed", "#8B0000", "DarkSalmon", "#E9967A", "DarkSeaGreen", "#8FBC8F", "DarkSlateBlue", "#483D8B", "DarkSlateGray", "#2F4F4F", "DarkSlateGrey", "#2F4F4F", "DarkTurquoise", "#00CED1", "DarkViolet", "#9400D3", "DeepPink", "#FF1493", "DeepSkyBlue", "#00BFFF", "DimGray", "#696969", "DimGrey", "#696969", "DodgerBlue", "#1E90FF", "FireBrick", "#B22222", "FloralWhite", "#FFFAF0", "ForestGreen", "#228B22", "Fuchsia", "#FF00FF", "Gainsboro", "#DCDCDC", "GhostWhite", "#F8F8FF", "Gold", "#FFD700", "GoldenRod", "#DAA520", "Gray", "#808080", "Grey", "#808080", "Green", "#008000", "GreenYellow", "#ADFF2F", "HoneyDew", "#F0FFF0", "HotPink", "#FF69B4", "IndianRed", "#CD5C5C", "Indigo", "#4B0082", "Ivory", "#FFFFF0", "Khaki", "#F0E68C", "Lavender", "#E6E6FA", "LavenderBlush", "#FFF0F5", "LawnGreen", "#7CFC00", "LemonChiffon", "#FFFACD", "LightBlue", "#ADD8E6", "LightCoral", "#F08080", "LightCyan", "#E0FFFF", "LightGoldenRodYellow", "#FAFAD2", "LightGray", "#D3D3D3", "LightGrey", "#D3D3D3", "LightGreen", "#90EE90", "LightPink", "#FFB6C1", "LightSalmon", "#FFA07A", "LightSeaGreen", "#20B2AA", "LightSkyBlue", "#87CEFA", "LightSlateGray", "#778899", "LightSlateGrey", "#778899", "LightSteelBlue", "#B0C4DE", "LightYellow", "#FFFFE0", "Lime", "#00FF00", "LimeGreen", "#32CD32", "Linen", "#FAF0E6", "Magenta", "#FF00FF", "Maroon", "#800000", "MediumAquaMarine", "#66CDAA", "MediumBlue", "#0000CD", "MediumOrchid", "#BA55D3", "MediumPurple", "#9370DB", "MediumSeaGreen", "#3CB371", "MediumSlateBlue", "#7B68EE", "MediumSpringGreen", "#00FA9A", "MediumTurquoise", "#48D1CC", "MediumVioletRed", "#C71585", "MidnightBlue", "#191970", "MintCream", "#F5FFFA", "MistyRose", "#FFE4E1", "Moccasin", "#FFE4B5", "NavajoWhite", "#FFDEAD", "Navy", "#000080", "OldLace", "#FDF5E6", "Olive", "#808000", "OliveDrab", "#6B8E23", "Orange", "#FFA500", "OrangeRed", "#FF4500", "Orchid", "#DA70D6", "PaleGoldenRod", "#EEE8AA", "PaleGreen", "#98FB98", "PaleTurquoise", "#AFEEEE", "PaleVioletRed", "#DB7093", "PapayaWhip", "#FFEFD5", "PeachPuff", "#FFDAB9", "Peru", "#CD853F", "Pink", "#FFC0CB", "Plum", "#DDA0DD", "PowderBlue", "#B0E0E6", "Purple", "#800080", "RebeccaPurple", "#663399", "Red", "#FF0000", "RosyBrown", "#BC8F8F", "RoyalBlue", "#4169E1", "SaddleBrown", "#8B4513", "Salmon", "#FA8072", "SandyBrown", "#F4A460", "SeaGreen", "#2E8B57", "SeaShell", "#FFF5EE", "Sienna", "#A0522D", "Silver", "#C0C0C0", "SkyBlue", "#87CEEB", "SlateBlue", "#6A5ACD", "SlateGray", "#708090", "SlateGrey", "#708090", "Snow", "#FFFAFA", "SpringGreen", "#00FF7F", "SteelBlue", "#4682B4", "Tan", "#D2B48C", "Teal", "#008080", "Thistle", "#D8BFD8", "Tomato", "#FF6347", "Turquoise", "#40E0D0", "Violet", "#EE82EE", "Wheat", "#F5DEB3", "White", "#FFFFFF", "WhiteSmoke", "#F5F5F5", "Yellow", "#FFFF00", "YellowGreen", "#9ACD32"], dn = /^rgba?\((\d+),?\s*(\d+),?\s*(\d+),?\s*((\d+)?\.?\d+)*\)$/; function hn(t, e) { void 0 === e && (e = [0, 0, 0, 0]); var i = dn.exec(t); return i ? (e[0] = parseInt(i[1]) / 255, e[1] = parseInt(i[2]) / 255, e[2] = parseInt(i[3]) / 255, e[3] = void 0 === i[4] ? 1 : parseFloat(i[4]), e) : null } function cn(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function fn(t) { var e = t[0], i = t[1], n = t[2], r = t[3]; return "rgba(" + (256 * e | 0) + "," + (256 * i | 0) + "," + (256 * n | 0) + "," + (void 0 === r ? 1 : r) + ")" } function gn(t) { t = t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (t, e, i, n) { return e + e + i + i + n + n }); var e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t); return e ? [parseInt(e[1], 16) / 255, parseInt(e[2], 16) / 255, parseInt(e[3], 16) / 255, 1] : null } var pn = [0, 0, 0, 0], _n = (vn.prototype.parseColor = function (t) { var e = this._colorByName[t]; if (void 0 === e) { var i = t + ""; e = "#" === i.charAt(0) ? gn(i) : hn(i), this._colorByName[t] = e } return e }, vn.prototype.toHexa = function (t) { var e = this.parseColor(t), i = e[0], n = e[1], r = e[2]; return "#" + cn(255 * i) + cn(255 * n) + cn(255 * r) }, vn.prototype.rgbaToRgb = function (t) { var e = 1, i = t; return i && hn(t, pn) && (i = "rgb(" + 255 * pn[0] + "," + 255 * pn[1] + "," + 255 * pn[2] + ")", e = parseFloat(pn[3].toString())), { color: i, opacity: e } }, vn); function vn() { this._colorByName = {}, this._colorByName.null = [0, 0, 0, 0], this._colorByName.transparent = [0, 0, 0, 0]; for (var t = 0; t < ln.length; t += 2) { var e = ln[t].toLowerCase(), value = ln[t + 1]; this._colorByName[e] = gn(value) } } var mn, yn = 2, bn = 4, xn = 5, En = 6, An = 7, Sn = 1, wn = 2, Tn = 3, Cn = 4, Mn = 5, In = ((mn = {})[yn] = "image", mn[bn] = "piechart", mn[3] = "text", mn[xn] = "icon", mn[En] = "badge", mn), Ln = (Nn.prototype.reset = function () { this._init_() }, Nn.prototype._init_ = function () { this._mustUpdate = !0, this._nextPatternId = 1, this._patterns = [null], this._patternsByHash = {}, this._pixelRatio = 1, this._nullPattern = { id: -1, type: 1, attributes: {} } }, Nn.prototype._increaseNextId = function () { var t = this._nextPatternId++; for (t % 256 == 255 && (t = this._nextPatternId++); this._patterns.length <= t;)this._patterns.push(void 0); return t }, Nn.prototype._createPattern = function (t) { var e = t.type, i = t.attributes, n = { id: this._increaseNextId(), type: e, attributes: this._cloneAttributes(e, i) }; return this._patterns[n.id] = n, this._mustUpdate = !0, n }, Nn.prototype._cloneAttributes = function (t, e) { return t === yn ? { image: e.image, scaled: e.scaled, duplicated: e.duplicated } : 3 === t || t === xn || t === En ? { font: e.font, size: e.size, style: e.style, text: e.text, align: e.align || "center", offset: e.offset || 0 } : t === bn ? { colors: e.colors, colorArray: e.colors.split(";").map(function (t) { return t.trim() }) } : void 0 }, Nn.prototype.getPatternList = function () { return this._patterns.filter(function (t) { return t }) }, Nn.prototype.update = function () { this._mustUpdate && (this._version += 1, this._mustUpdate = !1) }, Nn.prototype.setPixelRatio = function (value) { value !== this._pixelRatio && (this._pixelRatio = value, this._mustUpdate = !0) }, Nn.prototype.getPixelRatio = function () { return this._pixelRatio }, Nn.prototype.notifyUpdate = function () { this._mustUpdate = !0 }, Nn.prototype.getIdFromDefinition = function (t) { var e = t.type, i = t.attributes, n = 3 === e || e === xn || e === En, r = 0; return e && 1 !== e && e !== An && (e !== yn || i.image) && (!n || i.text && i.font) && (r = this._addPattern(t), 3 === e && "normal" === i.style && (i.style = "bold", this._addPattern(t))), r }, Nn.prototype._addPattern = function (t) { var e = this._getPatternHash(t), i = this._patternsByHash[e]; return i || (65500 < this._nextPatternId ? hi("maximum number of pattern exceeded") : (i = this._createPattern(t).id, this._patternsByHash[e] = i)), i }, Nn.prototype._getPatternHash = function (t) { var e = t.type, i = t.attributes, n = [In[e]]; return e === yn ? n.push(i.scaled ? "scaled" : "non-scaled", i.duplicated ? "duplicated" : "non-duplicated", i.image.src || i.image.toDataURL()) : 3 === e ? n.push(i.text, i.font, i.style, i.size, i.align || "center", i.offset || 0) : e === xn || e === En ? n.push(i.text, i.font, i.style, i.size) : n.push(i.colors), n.join("+") }, Nn.prototype.getDefinitionFromId = function (t) { return t ? this._patterns[t] : this._nullPattern }, Nn.prototype.getVersion = function () { return this._version }, Nn); function Nn() { this._pixelRatio = 1, this._nextPatternId = 1, this._version = 0, this._init_() } var kn = Math.round(Math.log2(512)), On = Math.round(Math.log2(128)), Fn = kn + On, Rn = 128, Pn = Math.round(Math.sqrt(16)), Dn = Rn * Pn, zn = 16, Bn = 1, Un = 256, Vn = 5, jn = 5; function Gn(t) { return t.map(function (t) { var e = t.x, i = t.y, n = t.r; return { x: e, y: i, r: void 0 === n ? 0 : n } }) } var Hn = (qn.prototype.register = function (t, e) { var i = e.getDistanceFromStrokeVertically, n = e.getDistanceFromStrokeHorizontally, r = e.points, o = e.hole, s = e.isSimple; if (!this._byName[t]) { for (var a = s ? 1 : 8, u = s ? 7 : 15; this._byId[a];)a += 1; if (u < a) throw new Error("max number of shape exceeded"); var l = { id: a, name: t, getDistanceFromStrokeVertically: i, getDistanceFromStrokeHorizontally: n, points: Gn(r.slice()), hole: o ? Gn(o.slice()) : null, isSimple: !!s }; return this._mustUpdate = !0, this._byId[a] = l, this._byName[t] = l } }, qn.prototype.getIdFromName = function (t) { return this._byName[t].id }, qn.prototype.getNameFromId = function (t) { var e = this._byId[t]; return e ? e.name : null }, qn.prototype.getDefinitionFromName = function (t) { return this._byName[t] || null }, qn.prototype.update = function () { this._mustUpdate && (this._version += 1, this._mustUpdate = !1) }, qn.prototype.getVersion = function () { return this._version }, qn.prototype.getShapeList = function () { return this._byId.filter(function (t) { return t }) }, qn); function qn() { this._version = 0, this._mustUpdate = !0, this._byName = {}, this._byId = new Array(16) } var Wn = (Xn.prototype.update = function () { this._mustUpdate && (this._version += 1, this._mustUpdate = !1, this._isFullyAllocated && this._nbCellsFreed === this._nbCellsAllocated && (this._isFullyFreed = !0)) }, Xn.prototype.allocate = function (t) { var e = -1; return !this._isFullyAllocated && this._nbCellsAllocated + t <= this._capacity ? (e = this._nbCellsAllocated, this._nbCellsAllocated += t, this._mustUpdate = !0) : this._isFullyAllocated = !0, e }, Xn.prototype.free = function (t, e) { for (var i = 0; i < e; i++) { var n = (t + i) * this._elementSize; if (0 === this._dataView.getUint16(n)) throw new Error('"free": invalid address provided'); this._dataView.setUint16(n, 0) } this._mustUpdate = !0, this._nbCellsFreed += e }, Xn.prototype.triggerUpdate = function () { this._mustUpdate = !0 }, Xn.prototype.isEmpty = function () { return this._nbCellsFreed === this._nbCellsAllocated }, Xn.prototype.isFullyFreed = function () { return this._isFullyFreed }, Xn.prototype.getId = function () { return this._id }, Xn.prototype.getDepth = function () { return this._depth }, Xn.prototype.getElementType = function () { return this._elementType }, Xn.prototype.getDataView = function () { return this._dataView }, Xn.prototype.getByteArray = function () { return this._byteArray }, Xn.prototype.getElementSize = function () { return this._elementSize }, Xn.prototype.isAnimated = function () { return this._animated }, Xn.prototype.getCapacity = function () { return this._capacity }, Xn.prototype.getSize = function () { return this._nbCellsAllocated }, Xn.prototype.getNbSideElementsPerMainElement = function () { return this._nbSideElementsPerMainElement }, Xn.prototype.hasSideData = function () { return 0 < this._nbSideElementsPerMainElement }, Xn.prototype.getSideDataView = function () { return this._sideDataView }, Xn.prototype.getSideByteArray = function () { return this._sideByteArray }, Xn.prototype.getTotalSideElementsSize = function () { return this._totalSideElementsSize }, Xn.prototype.getVersion = function () { return this._version }, Xn.prototype.getStencilUsage = function () { return this._stencilUsage }, Xn); function Xn(t) { var e = t.elementSize, i = t.sideElementSize, n = t.nbSideElementsPerMainElement, r = t.id, o = t.depth, s = t.elementType, a = t.animated, u = t.stencilUsage; this._version = 0, this._nbCellsAllocated = 0, this._nbCellsFreed = 0, this._isFullyAllocated = !1, this._isFullyFreed = !1, this._mustUpdate = !0, this._capacity = 512, this._id = r, this._depth = o, this._elementType = s, this._animated = a, this._stencilUsage = u, this._elementSize = e, this._sideElementSize = i, this._nbSideElementsPerMainElement = n, this._totalSideElementsSize = n * i, this._byteCapacity = this._capacity * this._elementSize, this._byteArray = new Uint8Array(this._byteCapacity), this._dataView = new DataView(this._byteArray.buffer), this._sideByteCapacity = this._capacity * this._totalSideElementsSize, this._sideByteArray = new Uint8Array(this._sideByteCapacity), this._sideDataView = new DataView(this._sideByteArray.buffer) } var Yn = (Zn.prototype.reset = function () { this._init_() }, Zn.prototype._init_ = function () { this._buffersByDepth = new Array(100), this._buffersById = [], this._buffersByAscendingDepth = [], this._buffersByDescendingDepth = [], this._mustUpdate = !0 }, Zn.prototype._fillBlockInfo = function (t, e, i, n) { return this._blockInfo.buffer = t, this._blockInfo.offset = e, this._blockInfo.size = i, this._blockInfo.address = n, this._blockInfo }, Zn.prototype._createBuffer = function (t, e, i, n, r) { var o = e ? 120 : 52, s = this._buffersById.length, a = new Wn({ elementSize: o, sideElementSize: 4, nbSideElementsPerMainElement: n, id: s, depth: i, elementType: t, animated: e, stencilUsage: r }); return this._buffersById.push(a), a }, Zn.prototype.getBlockInfo = function (t) { return this._getBlockInfo(t) }, Zn.prototype._getBlockInfo = function (t) { return this._fillBlockInfo(this._buffersById[t >> Fn], (t >> On) % 512, t % 128, t) }, Zn.prototype.allocateBlock = function (t, e, i, n, r, o, s) { var a = function (t, e) { for (var value = 0; value < t;)value += e; return value }(o, 8); this._mustUpdate = !0; var u = null, l = -1; if (t) { var d = this._getBlockInfo(t), h = d.buffer, c = d.offset, f = d.size, g = d.size === r, p = h.getDepth() === n, _ = h.getElementType() === e, v = h.isAnimated() === i, m = h.getNbSideElementsPerMainElement() === a, y = h.getStencilUsage() === s; g && p && _ && v && m && y ? (h.triggerUpdate(), u = h, l = c) : h.free(c, f) } if (-1 === l) { var b = +i, x = a / 8, E = this._buffersByDepth[n] || Array(2), A = (this._buffersByDepth[n] = E)[b] || [], S = (E[b] = A)[e] || Array(16), w = (A[e] = S)[x] || Array(4), T = (S[x] = w)[s] || [], C = (w[s] = T)[T.length - 1]; C && (l = (u = C).allocate(r)), -1 === l && (l = (u = this._createBuffer(e, i, n, a, s)).allocate(r), T.push(u)) } var M = ((u.getId() << kn) + l << On) + r; return this._fillBlockInfo(u, l, r, M) }, Zn.prototype.freeBlock = function (t) { if (t) { this._mustUpdate = !0; var e = this._getBlockInfo(t); e.buffer.free(e.offset, e.size) } return 0 }, Zn.prototype._sortBuffersByDepth = function () { for (var t = [], e = 0; e < this._buffersByDepth.length; e++) { var i = this._buffersByDepth[e]; if (i) for (var n = 0; n < i.length; n++) { var r = i[n]; if (r) for (var o = 0; o < r.length; o++) { var s = r[o]; if (s) for (var a = 0; a < s.length; a++) { var u = s[a]; if (u) for (var l = 0; l < u.length; l++) { var d = u[l]; if (d) for (var h = 0; h < d.length; h++) { var c = d[h]; c.update(), c.isFullyFreed() ? (this._buffersById[c.getId()] = void 0, d.splice(h, 1), --h) : t.push(c) } } } } } } this._buffersByAscendingDepth = t, this._buffersByDescendingDepth = t.slice().reverse() }, Zn.prototype.update = function () { this._mustUpdate && (this._sortBuffersByDepth(), this._version += 1, this._mustUpdate = !1) }, Zn.prototype.getBuffers = function () { return this._buffersById }, Zn.prototype.getBuffersByAscendingDepth = function () { return this._buffersByAscendingDepth }, Zn.prototype.getBuffersByDescendingDepth = function () { return this._buffersByDescendingDepth }, Zn.prototype.getVersion = function () { return this._version }, Zn); function Zn() { this._version = 0, this._version = 0, this._blockInfo = { buffer: null, offset: 0, size: 0, address: 0 }, this._init_() } var Kn = 300, Qn = 150, Jn = (Object.defineProperty($n.prototype, "__dummy", { get: function () { return !0 }, enumerable: !0, configurable: !0 }), Object.defineProperty($n.prototype, "parentNode", { get: function () { return null }, enumerable: !0, configurable: !0 }), $n.prototype.getContext = function (t) { return "2d" === t ? this.__context : null }, $n.prototype.toDataURL = function (t) { return void 0 === t && (t = "png"), "data:image/" + t + ";base64," }, $n.prototype.addEventListener = function () { }, $n.prototype.removeEventListener = function () { }, $n.prototype.getBoundingClientRect = function () { return { left: 0, top: 0, bottom: 0, right: 0, width: this.width, height: this.height } }, $n); function $n() { this.style = {}, this.width = Kn, this.height = Qn, this.__context = new tr, this.style = {}, this.width = Kn, this.height = Qn } var tr = (Object.defineProperty(er.prototype, "font", { set: function (t) { var e = t.match(/\d+/); e && (this._fontSize = parseFloat(e[0])) }, enumerable: !0, configurable: !0 }), Object.defineProperty(er.prototype, "fillStyle", { set: function (t) { }, enumerable: !0, configurable: !0 }), Object.defineProperty(er.prototype, "textBaseline", { set: function (t) { }, enumerable: !0, configurable: !0 }), Object.defineProperty(er.prototype, "textAlign", { set: function (t) { }, enumerable: !0, configurable: !0 }), Object.defineProperty(er.prototype, "strokeStyle", { set: function (t) { }, enumerable: !0, configurable: !0 }), Object.defineProperty(er.prototype, "lineWidth", { set: function (t) { }, enumerable: !0, configurable: !0 }), er.prototype.fill = function () { }, er.prototype.stroke = function () { }, er.prototype.clearRect = function () { }, er.prototype.fillRect = function () { }, er.prototype.strokeRect = function () { }, er.prototype.beginPath = function () { }, er.prototype.closePath = function () { }, er.prototype.moveTo = function () { }, er.prototype.lineTo = function () { }, er.prototype.rect = function () { }, er.prototype.arc = function () { }, er.prototype.save = function () { }, er.prototype.restore = function () { }, er.prototype.clip = function () { }, er.prototype.translate = function () { }, er.prototype.rotate = function () { }, er.prototype.fillText = function () { }, er.prototype.setLineDash = function () { }, er.prototype.quadraticCurveTo = function () { }, er.prototype.bezierCurveTo = function () { }, er.prototype.drawImage = function () { }, er.prototype.measureText = function (t) { return { width: t.length * Math.ceil(.625 * this._fontSize) } }, er.prototype.getImageData = function () { return { width: 0, height: 0, data: new Uint8ClampedArray(0) } }, er); function er() { this._fontSize = 10 } var ir = M("canvas") || M("canvas-prebuilt"); function nr() { var t = null; return ht ? t = document.createElement("canvas") : ir ? (t = ir.createCanvas ? ir.createCanvas(Kn, Qn) : new ir(Kn, Qn)).style = {} : t = new Jn, t } function rr(t, e, i, n) { void 0 === i && (i = t.width), void 0 === n && (n = t.height), e.clearRect(0, 0, i, n) } function or(t, e, i, n) { void 0 === n && (n = ""), t.font = n + " " + i + "px " + e } function sr() { return null !== ar(nr(), {}) } function ar(t, e) { var i = t.getContext("webgl", e); return (i = i || t.getContext("experimental-webgl", e)) || null } function ur() { return { pieceId: 0, shape: "circle", x1: 0, y1: 0, x2: 0, y2: 0, rectWidthOrSourceRadiusScaled: 0, rectWidthOrSourceRadiusFixed: 0, rectHeightOrTargetRadiusScaled: 0, rectHeightOrTargetRadiusFixed: 0, thicknessOrFontSizeScaled: 0, thicknessOrFontSizeFixed: 0, strokeWidthScaled: 0, strokeWidthFixed: 0, offsetScaled: 0, offsetFixed: 0, pattern: { id: void 0, type: 0, attributes: {} }, opacity: 1, fillColor: null, strokeColor: null, patternColor: null, globalMinVisibleSize: 0, strokeMinVisibleSize: 0, patternMinVisibleSize: 0, offsetAngle: 0, patternScale: 0, symbolicSize: -1, curvature: 0, dashLength: 0, gapLength: 0, hasHead: !1, hasTail: !1, isBodyTriangle: !1, isSelfLoop: !1, isText: !1, adjustTextAngle: !1, unusedFlag1: !1, unusedFlag2: !1, unusedFlag3: !1 } } function lr(t) { return t.pieceId = 0, t.shape = "", t.x1 = 0, t.y1 = 0, t.x2 = 0, t.y2 = 0, t.rectWidthOrSourceRadiusScaled = 0, t.rectWidthOrSourceRadiusFixed = 0, t.rectHeightOrTargetRadiusScaled = 0, t.rectHeightOrTargetRadiusFixed = 0, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = 0, t.strokeWidthFixed = 0, t.offsetScaled = 0, t.offsetFixed = 0, t.pattern.type = 0, t.opacity = 1, t.fillColor = null, t.strokeColor = null, t.patternColor = null, t.globalMinVisibleSize = 0, t.strokeMinVisibleSize = 0, t.patternMinVisibleSize = 0, t.offsetAngle = 0, t.patternScale = 0, t.symbolicSize = 0, t.curvature = 0, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isBodyTriangle = !1, t.isSelfLoop = !1, t.isText = !1, t.adjustTextAngle = !1, t.unusedFlag1 = !1, t.unusedFlag2 = !1, t.unusedFlag3 = !1, t } function dr() { return { valid: !1, id: void 0, end: ur(), start: ur(), animation: { duration: 0, beginTime: -1, easing: "linear" } } } function hr(t, e, i, n) { t.width = e * n, t.height = i * n, t.style.width = e + "px", t.style.height = i + "px" } var cr = (fr.createInitData = function () { return null }, fr.getName = function () { return null }, fr.isAvailable = function () { return !0 }, fr.prototype.getDomElement = function () { return null }, fr.prototype._initCanvas = function (t) { t.style.touchAction = "none" }, fr.prototype.export = function (t) { return Promise.resolve() }, fr.prototype.extractElement = function (t, e) { return this._memoryManager.extractGenericElement(t, e, this._scales) }, fr.prototype._compareDimensions = function (t, e, i) { return (t !== this._width || e !== this._height || i !== this._pixelRatio) && (this._width = t, this._height = e, this._pixelRatio = i, !0) }, fr.prototype._compareView = function (t, e, i, n) { return (t !== this._viewX || e !== this._viewY || i !== this._viewZoom || n !== this._viewAngle) && (this._viewX = t, this._viewY = e, this._viewZoom = i, this._viewAngle = n, this._viewAngleCos = Math.cos(n), this._viewAngleSin = Math.sin(n), !0) }, fr.prototype._compareCurrentTime = function (t) { return t !== this._currentTime && (this._currentTime = t, !0) }, fr.prototype._compareBackgroundColor = function (t, e) { return (t !== this._backgroundColor || e !== this._renderBackground) && (this._renderBackground = e, this._backgroundColor = t, this._backgroundRgba = this._colorManager.parseColor(this._backgroundColor), !0) }, fr.prototype._compareShapes = function () { return this._shapesVersion !== this._shapeManager.getVersion() && (this._shapesVersion = this._shapeManager.getVersion(), !0) }, fr.prototype._comparePatterns = function () { return this._patternsVersion !== this._patternManager.getVersion() && (this._patternsVersion = this._patternManager.getVersion(), !0) }, fr.prototype._compareBoundaries = function () { return this._boundariesVersion !== this._boundariesManager.getVersion() && (this._boundariesVersion = this._boundariesManager.getVersion(), !0) }, fr.prototype._compareTexts = function () { return this._textsVersion !== this._textManager.getVersion() && (this._textsVersion = this._textManager.getVersion(), !0) }, fr.prototype._compareIsDisplayableBuffer = function (t) { return this._isBufferDisplayable !== t && (this._isBufferDisplayable = t, !0) }, fr.prototype._compareHideImages = function (t) { return this._hideImages !== t && (this._hideImages = t, !0) }, fr.prototype.renderFrame = function (t) { var e = t.x, i = t.y, n = t.zoom, r = t.angle, o = t.width, s = t.height, a = t.pixelRatio, u = t.backgroundColor, l = t.currentTime, d = t.isBufferDisplayable, h = t.hideImages, c = t.renderBackground, f = this._compareShapes(), g = this._comparePatterns(), p = this._compareBoundaries(), _ = this._compareTexts(), v = this._compareDimensions(o, s, a), m = this._compareView(e, i, n, r), y = this._compareCurrentTime(l), b = this._compareBackgroundColor(u, c), x = this._compareIsDisplayableBuffer(d), E = this._compareHideImages(h); if (p) { var A = this._boundariesManager, S = this._scales; S.bytesToActualCoord = 1, S.bytesToActualScaledSize = A.maxScaledSize / 65535, S.bytesToActualMinVisibleSize = A.maxMinVisibleSize / 15, S.bytesToActualSymbolicSize = A.maxSymbolicSize / 255, S.bytesToActualDashLength = A.maxDashLength / 3, S.bytesToActualGapLength = A.maxGapLength / 3, S.bytesToActualPatternScale = A.maxPatternScale / 255 } this._firstFrame && this._beforeFirstFrame(), this._render({ shapesChanged: f, patternsChanged: g, boundariesChanged: p, textsChanged: _, dimensionsChanged: v, viewChanged: m, currentTimeChanged: y, backgroundColorChanged: b, isBufferDisplayableChanged: x, isHideImagesChanged: E }), this._firstFrame && (this._afterFirstFrame(), this._firstFrame = !1) }, fr.prototype._render = function (t) { }, fr.prototype._beforeFirstFrame = function () { }, fr.prototype._afterFirstFrame = function () { }, fr.prototype.destroy = function () { }, fr.prototype.ensureAnimationsReady = function () { }, fr.prototype.getImageData = function () { return null }, fr.prototype.setViewportClipping = function (t) { }, fr); function fr(t) { var e = t.bufferList, i = t.patternManager, n = t.boundariesManager, r = t.colorManager, o = t.shapeManager, s = t.textManager, a = t.easingManager, u = t.memoryManager; this._firstFrame = !0, this._width = 0, this._height = 0, this._pixelRatio = 0, this._viewX = 0, this._viewY = 0, this._viewZoom = 0, this._viewAngle = 0, this._viewAngleCos = 0, this._viewAngleSin = 0, this._currentTime = 0, this._scales = { bytesToActualCoord: 0, bytesToActualScaledSize: 0, bytesToActualMinVisibleSize: 0, bytesToActualSymbolicSize: 0, bytesToActualDashLength: 0, bytesToActualGapLength: 0, bytesToActualPatternScale: 0 }, this._shapesVersion = 0, this._patternsVersion = 0, this._boundariesVersion = 0, this._textsVersion = 0, this._backgroundColor = null, this._backgroundRgba = [1, 1, 1, 0], this._renderBackground = !1, this._isBufferDisplayable = null, this._hideImages = !1, this._genericObject = dr(), this._littleEndian = P(), this._bufferList = e, this._shapeManager = o, this._patternManager = i, this._boundariesManager = n, this._textManager = s, this._colorManager = r, this._easingManager = a, this._memoryManager = u } var gr, pr, _r = "#define D3D9_FIX 0\n#define ANIMATED 0\nprecision highp float;\nprecision mediump int;\nattribute /*ushort*/ vec4 a_final_shapeInfo_miscInfo_opacityAndAllMinVisibleSizes_symbolicSizeAndCurvature;\nattribute /*ushort*/ vec4 a_final_patternId_fillRGBA_strokeRGBA_patternRGBA;\nattribute /*float*/ vec4 a_final_x1_y1_x2_y2;\nattribute /*ushort*/ vec4 a_final_rectWidthOrSourceRadiusScaled_rectWidthOrSourceRadiusFixed_rectHeightOrTargetRadiusScaled_rectHeightOrTargetRadiusFixed;\nattribute /*ushort*/ vec4 a_final_thicknessOrFontSizeScaled_thicknessOrFontSizeFixed_strokeWidthScaled_strokeWidthFixed;\nattribute /*ushort*/ vec2 a_final_offsetScaled_offsetFixed;\nattribute /*ushort*/ vec4 a_prev_shapeInfo_miscInfo_opacityAndAllMinVisibleSizes_symbolicSizeAndCurvature;\nattribute /*ushort*/ vec4 a_prev_patternId_fillRGBA_strokeRGBA_patternRGBA;\nattribute /*float*/ vec4 a_prev_x1_y1_x2_y2;\nattribute /*ushort*/ vec4 a_prev_rectWidthOrSourceRadiusScaled_rectWidthOrSourceRadiusFixed_rectHeightOrTargetRadiusScaled_rectHeightOrTargetRadiusFixed;\nattribute /*ushort*/ vec4 a_prev_thicknessOrFontSizeScaled_thicknessOrFontSizeFixed_strokeWidthScaled_strokeWidthFixed;\nattribute /*ushort*/ vec2 a_prev_offsetScaled_offsetFixed;\nattribute /*float*/ vec2 a_animationBeginTime_animationDuration; \nattribute /*ushort*/ vec4 a_animationEasing; \nattribute /*ushort*/ vec2 a_text_charId_charOffsetXY; \nattribute vec3 a_vertexInfo;\nuniform float u_viewWidth;\nuniform float u_viewHeight;\nuniform float u_viewX;\nuniform float u_viewY;\nuniform float u_viewAngle;\nuniform float u_viewZoom;\nuniform float u_currentTime;\nuniform float u_pixelRatio;\nuniform sampler2D u_patternInfoTexture;\nvarying vec4 a;\nvarying vec4 b;\nvarying vec4 c;\nvarying vec2 d;\nvarying vec2 e;\n#if D3D9_FIX\nvarying vec4 f;\nvarying vec3 g;\nvarying vec4 h;\nvarying vec4 i;\n#else\nvarying float j;\nvarying vec2 k;\nvarying vec2 l;\nvarying vec2 m;\nvarying float n;\nvarying float o;\nvarying vec2 p;\nvarying vec2 q;\nvarying float r;\nvarying float s;\n#endif\nconst float EPSILON = 0.000001;\nconst float INFINITY = 10000000.0;\nconst float PI = 3.14159265359;\nconst float P2_12 = 4096.0;\nconst float P2_8 = 256.0;\nconst float P2_7 = 128.0;\nconst float P2_6 = 64.0;\nconst float P2_5 = 32.0;\nconst float P2_4 = 16.0;\nconst float P2_3 = 8.0;\nconst float P2_2 = 4.0;\nconst float P2_1 = 2.0;\nuniform float BYTES_TO_COORD;\nuniform float BYTES_TO_SCALED_SIZE;\nuniform float BYTES_TO_MIN_VISIBLE_SIZE;\nuniform float BYTES_TO_SYMBOLIC_SIZE;\nuniform float BYTES_TO_CURVATURE;\nuniform float BYTES_TO_DASH_LENGTH;\nuniform float BYTES_TO_GAP_LENGTH;\nuniform float BYTES_TO_PATTERN_SCALE;\nuniform float PATTERN_POSITION_GRANULARITY;\nuniform float PATTERN_INFO_TEXTURE_SIZE;\nuniform float PATTERN_NEAREST_TEXTURE_SIZE;\nuniform float PATTERN_LINEAR_TEXTURE_SIZE;\nuniform float PATTERN_LINEAR_SDF_TEXTURE_SIZE;\nuniform float PATTERN_MIPMAP_TEXTURE_SIZE;\nconst float BYTES_TO_OFFSET_ANGLE = 0.0;\nconst float BYTES_TO_COLOR = 0.0;\nconst float SDF_FONT_SIZE = 0.0;\nconst float CURVATURE_RATIO = 0.0;\nconst float PATTERN_MARGIN = 0.0;\nconst float TEXT_WIDTH_MULTIPLIER = 0.0;\nconst float TEXT_HEIGHT_MULTIPLIER = 0.0;\nconst float SELF_LOOP_CURVATURE_MULTIPLIER = 0.0;\nconst float EDGE_ARROW_SIZE_RATIO = 0.0;\nconst float NB_PIECES_PER_CURVE = 0.0;\nconst float PIECE_NODE_COMPONENT = 0.0;\nconst float PIECE_EDGE_BODY = 0.0;\nconst float PIECE_EDGE_HEAD = 0.0;\nconst float PIECE_EDGE_TAIL = 0.0;\nconst float PIECE_EDGE_TEXT = 0.0;\nconst float MAX_TEXT_SIZE = 0.0;\nconst float BYTES_TO_TEXT_OFFSET = 0.0;\nconst float FILTER_NEAREST = 0.0;\nconst float FILTER_LINEAR = 0.0;\nconst float FILTER_LINEAR_SDF = 0.0;\nconst float FILTER_MIPMAP = 0.0;\nconst float SHAPE_TEXTURE_SIZE = 0.0;\nconst float SIMPLE_SHAPE_SAMPLING_SIZE = 0.0;\nconst float COMPLEX_SHAPE_SAMPLING_SIZE = 0.0;\nconst float SHAPE_SAMPLING_BUFFER_RATIO = 0.0;\nconst float MAX_NB_SHAPES = 0.0;\nconst float FIRST_COMPLEX_SHAPE_ID = 0.0;\nconst float SELF_LOOP_TO_CIRCLE_APPROX = 0.0;\nconst float NB_SHAPES_BY_SIDE = SHAPE_TEXTURE_SIZE / COMPLEX_SHAPE_SAMPLING_SIZE;\nconst float SHAPE_FILL_PERCENT = 1.0 - SHAPE_SAMPLING_BUFFER_RATIO;\nconst float T_STEP_PER_CURVE_PIECE = 1.0 / NB_PIECES_PER_CURVE;\nconst float HEAD_TAIL_PX_ADJUST = 1.5;\nstruct ne {\nfloat nf;\nfloat ng;\nfloat nh;\nfloat ni;\nfloat nj;\nfloat nk;\nfloat nl;\nfloat nm;\n};\nstruct nn {\nfloat no;\nfloat np;\nfloat nq;\nfloat nr;\nfloat ns;\nfloat nt;\nfloat nu;\n};\nstruct nv {\nfloat nf;\nfloat ng;\nfloat nh;\nfloat ni;\nfloat nj;\nfloat nk;\nfloat nl;\nfloat nm;\nfloat no;\nfloat np;\nfloat nq;\nfloat nr;\nfloat ns;\nfloat nt;\nfloat nu;\nfloat bu;\nfloat nw;\nfloat nx;\nfloat ny;\nfloat nz;\nfloat oa;\nfloat ob;\nvec4 az;\nvec4 ba;\nvec4 bl;\nfloat oc;\nfloat od;\nfloat oe;\nfloat of;\nfloat og;\nfloat oh;\nfloat oi;\nfloat oj;\nfloat ok;\nfloat ol;\nfloat om;\nfloat on;\nfloat oo;\nfloat op;\nfloat oq;\nfloat or;\nfloat os;\n};\nstruct ot {\nfloat ou;\nvec2 ov;\nvec4 az;\nvec4 ba;\nfloat bu;\nfloat ow;\nfloat ox;\nfloat nh;\nfloat oy;\nvec2 oz;\nfloat pa;\nvec2 bb;\nvec2 pb;\nvec2 pc;\nfloat pd;\nfloat pe;\nvec4 bl;\nvec2 pf;\nfloat pg;\nfloat ph;\nvec2 pi;\nvec2 pj;\nvec2 pk;\n};\nfloat pl(float lh, float pm, float pn) {\nfloat po = mod(lh, pow(2.0, pn));\nreturn floor(po / pow(2.0, pm));\n}\nne pp(float lh) {\nne pq;\npq.nf = pl(lh, 0.0, 4.0);\npq.ng = pl(lh, 4.0, 8.0);\npq.nh = pl(lh, 8.0, 10.0);\npq.ni = pl(lh, 10.0, 12.0);\npq.nj = pl(lh, 12.0, 13.0);\npq.nk = pl(lh, 13.0, 14.0);\npq.nl = pl(lh, 14.0, 15.0);\npq.nm = pl(lh, 15.0, 16.0);\nreturn pq;\n}\nnn pr(float lh) {\nnn pq;\npq.no = pl(lh, 0.0, 8.0);\npq.np = pl(lh, 8.0, 11.0);\npq.nq = pl(lh, 11.0, 12.0);\npq.nr = pl(lh, 12.0, 13.0);\npq.ns = pl(lh, 13.0, 14.0);\npq.nt = pl(lh, 14.0, 15.0);\npq.nu = pl(lh, 15.0, 16.0);\nreturn pq;\n}\nvec4 ps(in float lh) {\nreturn vec4(\npl(lh, 0.0, 4.0),\npl(lh, 4.0, 8.0),\npl(lh, 8.0, 12.0),\npl(lh, 12.0, 16.0)\n);\n}\nvec2 pt(in float lh) {\nreturn vec2(mod(lh, 256.0), floor(lh / 256.0));\n}\nvec2 pu(in float lh) {\nfloat pv = floor(lh / P2_6);\nfloat pw = lh - (pv * P2_6);\nreturn vec2(pv, pw);\n}\nvec2 px(in float lh) {\nfloat py = floor(lh / P2_7);\nfloat pz = lh - (py * P2_7);\nreturn vec2(py, pz);\n}\nvec2 qa(in vec2 qb, in float qc) {\nfloat qd = cos(qc);\nfloat qe = sin(qc);\nreturn vec2(qd * qb.x + qe * qb.y, -qe * qb.x + qd * qb.y);\n}\nvec4 qf(in vec4 qg) {\nreturn floor(qg / 256.0) - 128.0;\n}\nvec4 qh(in vec4 qg) {\nreturn mod(qg, 256.0) - 128.0;\n}\nfloat qi(float lh) {\nreturn lh - 128.0;\n}\nvec2 qi(vec2 lh) {\nreturn lh - 128.0;\n}\nvec2 qj(vec2 qk) {\nreturn vec2(-qk.y, qk.x);\n}\nvec2 ql(vec2 qm, vec2 fn, vec2 qn, float t) {\nfloat qo = 1.0 - t;\nreturn (qo * qo * qm) + (2.0 * qo * t * fn) + (t * t * qn);\n}\nvec2 qp(vec2 qm, vec2 qq, vec2 qr, vec2 qn, float t) {\nfloat qo = 1.0 - t;\nfloat qs = qo * qo;\nfloat qt = qs * qo;\nfloat qu = t * t;\nfloat qv = qu * t;\nreturn (qt * qm) + (3.0 * qs * t * qq) + (3.0 * qo * qu * qr) + (qv * qn);\n}\nvec2 qw(vec2 qm, vec2 fn, vec2 qn, float t) {\nfloat qo = (1.0 - t);\nvec2 qb = (qo * fn + t * qn) - (qo * qm + t * fn);\nreturn normalize(qb);\n}\nvec2 qx(vec2 qm, vec2 fn, vec2 qn, float t) {\nreturn qj(qw(qm, fn, qn, t));\n}\nvec2 qy(vec2 qm, vec2 qq, vec2 qr, vec2 qn, float t) {\nfloat qo = 1.0 - t;\nfloat qs = qo * qo;\nfloat qu = t * t;\nvec2 qb = qs * (qq - qm) + 2.0 * qo * t * (qr - qq) + qu * (qn - qr);\nreturn normalize(qb);\n}\nvec2 qz(vec2 qm, vec2 qq, vec2 qr, vec2 qn, float t) {\nreturn qj(qy(qm, qq, qr, qn, t));\n}\nfloat rk(float oa, float rl, float t) {\nfloat y = abs(oa) / CURVATURE_RATIO + EPSILON;\nfloat of = y * y;\nfloat qo = t - 0.5;\nfloat qs = qo * qo;\nfloat rm = 1.0 / (16.0 * of);\nfloat rn = sqrt(qs + rm);\nfloat ro = (0.5 / y) * sqrt(of + 0.25);\nfloat rp = (abs(2.0 * y)) * ((qo * rn) + (0.5 * ro) + (rm * log(abs((qo + rn) / (-0.5 + ro)))));\nreturn rp * rl;\n}\nfloat rq(vec2 qm, vec2 rr, vec2 rs, vec2 qn, float rt) {\nvec2 pf = (qm + rr + rs) / 3.0;\nvec2 ru = pf - rr;\nvec2 rv = rr - rs;\nfloat rw = dot(ru, ru);\nfloat rx = dot(rv, rv) / 4.0;\nfloat sf = sqrt(rw - rx) * SELF_LOOP_TO_CIRCLE_APPROX * 1.55;\nreturn 2.0 * PI * sf * rt;\n}\nfloat sg(float lh) {\nreturn lh - 32.0;\n}\nfloat sh(float lh) {\nreturn lh - 512.0;\n}\nfloat si(float lh) {\nreturn lh - 32768.0;\n}\nvoid sj() {\ngl_Position = vec4(-10.0, -10.0, 1.0, 1.0);\n}\nvec4 sk(vec2 sl) {\nreturn vec4(((vec2(sl.x, u_viewHeight - sl.y) / vec2(u_viewWidth, u_viewHeight)) * 2.0 - 1.0), 0.5, 1.0);\n}\nfloat sp(float ap, float aq) {\nreturn step(ap - EPSILON, aq) * step(aq, ap + EPSILON);\n}\nbool ao(float ap, float aq) {\nreturn abs(ap - aq) < EPSILON;\n}\nbool sq(float lh) {\nreturn lh > 0.5;\n}\nvec2 sr(vec2 ss) {\nreturn qa((ss - vec2(u_viewX, u_viewY)) * u_viewZoom, u_viewAngle) + vec2(u_viewWidth, u_viewHeight) / 2.0;\n}\nfloat st(float ph) {\nreturn ph * EDGE_ARROW_SIZE_RATIO;\n}\nfloat su(float sv, float sw) {\nreturn sv * BYTES_TO_SCALED_SIZE * u_viewZoom + sw;\n}\nfloat tc(float ow, float ta, float tb) {\nfloat td = tb - ta;\nfloat a = 1.0 / td;\nfloat b = -ta / td;\nreturn ow * a + b;\n}\nstruct te {\nvec2 tf;\nvec2 tg;\n};\nte th(vec2 ti, float sf, float oa) {\nte lj;\nfloat tj = (sf + sf / SELF_LOOP_CURVATURE_MULTIPLIER * oa) * SELF_LOOP_CURVATURE_MULTIPLIER;\nfloat tk = -u_viewAngle + PI;\nfloat tl = -u_viewAngle + PI / 2.0;\nlj.tf = ti + vec2(cos(tk), sin(tk)) * tj;\nlj.tg = ti + vec2(cos(tl), sin(tl)) * tj;\nreturn lj;\n}\nfloat tq(vec2 tr, vec2 rr, vec2 rs, vec2 ts, float tt) {\nvec2 tu = tr;\nfloat t = 0.0;\nfloat tv = 0.0;\nfloat tw = rq(tr, rr, rs, ts, 1.0);\nreturn tt / tw;\n}\nnv tx(\nvec4 ty,\nvec4 tz,\nvec4 ua,\nvec4 ub,\nvec4 uc,\nvec2 ud,\nvec2 ue\n) {\nnv a;\nne av = pp(ty.x);\nnn uf = pr(ty.y);\nvec4 ug = ps(ty.z);\nvec2 uh = pt(ty.w);\nvec2 ui = pu(ue.y);\na.nf = av.nf;\na.ng = av.ng;\na.nh = av.nh;\na.ni = av.ni;\na.nj = av.nj;\na.nk = av.nk;\na.nl = av.nl;\na.nm = av.nm;\na.no = uf.no;\na.np = uf.np;\na.nq = uf.nq;\na.nr = uf.nr;\na.ns = uf.ns;\na.nt = uf.nt;\na.nu = uf.nu;\na.bu = ug.x;\na.nw = ug.y;\na.nx = ug.z;\na.ny = ug.w;\na.nz = uh.x;\na.oa = uh.y;\na.ob = tz.x;\na.az = ps(tz.y);\na.ba = ps(tz.z);\na.bl = ps(tz.w);\na.oc = ua.x;\na.od = ua.y;\na.oe = ua.z;\na.of = ua.w;\na.og = ub.x;\na.oh = ub.y;\na.oi = ub.z;\na.oj = ub.w;\na.ok = uc.x;\na.ol = uc.y;\na.om = uc.z;\na.on = uc.w;\na.oo = ud.x;\na.op = ud.y;\na.oq = ue.x;\na.or = sh(ui.x);\na.os = sg(ui.y);\nreturn a;\n}\nbool uu(const in nv a, out ot lj) {\nfloat nf = a.nf;\nfloat ng = a.ng;\nfloat nh = a.nh * BYTES_TO_DASH_LENGTH;\nfloat ni = a.ni * BYTES_TO_GAP_LENGTH;\nfloat nj = a.nj;\nfloat nk = a.nk;\nfloat nl = a.nl;\nfloat nm = a.nm;\nfloat no = a.no * BYTES_TO_PATTERN_SCALE;\nfloat np = a.np * BYTES_TO_OFFSET_ANGLE;\nfloat nq = a.nq;\nfloat nr = a.nr;\nfloat ns = a.ns;\nfloat nt = a.nt;\nfloat nu = a.nu;\nfloat bu = a.bu * BYTES_TO_COLOR;\nfloat nw = a.nw * BYTES_TO_MIN_VISIBLE_SIZE - EPSILON;\nfloat nx = a.nx * BYTES_TO_MIN_VISIBLE_SIZE - EPSILON;\nfloat ny = a.ny * BYTES_TO_MIN_VISIBLE_SIZE - EPSILON;\nfloat nz = a.nz * BYTES_TO_SYMBOLIC_SIZE * u_viewZoom + step(a.nz, EPSILON) * INFINITY;\nfloat oa = qi(a.oa);\nfloat ob = a.ob;\nvec4 az = a.az * BYTES_TO_COLOR;\nvec4 ba = a.ba * BYTES_TO_COLOR;\nvec4 bl = a.bl * BYTES_TO_COLOR;\nvec2 uv = vec2(a.oc, a.od) * BYTES_TO_COORD;\nvec2 uw = vec2(a.oe, a.of) * BYTES_TO_COORD;\nvec2 tr = sr(uv);\nvec2 ts = sr(uw);\nfloat ux = su(a.og, a.oh);\nfloat uy = su(a.oi, a.oj);\nfloat uz = su(a.ok, a.ol);\nfloat ou = su(a.om, a.on);\nfloat va = su(a.oo, a.op);\nvec2 vb = a_vertexInfo.xy;\nvec2 vc = vec2(0.0, 0.0);\nfloat vd = ux;\nfloat ve = uy;\nfloat vf = uy * no;\nif (nq > EPSILON) {\nif (a.oq < EPSILON) {\nreturn false;\n}\nvf = uz;\nob = a.oq;\nux = vf * TEXT_WIDTH_MULTIPLIER * u_pixelRatio;\nuy = vf * TEXT_HEIGHT_MULTIPLIER * u_pixelRatio;\n}\nbool vz = abs(oa) > EPSILON && sp(ng, PIECE_EDGE_BODY) < EPSILON;\nbool wa = vz && a_vertexInfo.z > EPSILON;\nif (nf < EPSILON || ng < EPSILON || nz < nw || wa) {\nreturn false;\n}\nou *= step(nx, nz);\nfloat wo = 0.0;\nfloat wp = 1.0;\nfloat wl = 0.0;\nfloat wn = 1.0;\nfloat wq = 0.0;\nfloat xa = 1.0;\nfloat xc = 1.0;\nfloat xn = 0.0;\nfloat xo = 0.0;\nvec2 pf;\nvec2 pi;\nvec2 pj;\nvec2 pk;\nfloat ph;\nfloat pg;\nfloat yh = 0.0;\nfloat yi = 1.0;\nif (sp(ng, PIECE_NODE_COMPONENT) > EPSILON) {\npf = ceil((tr + ts) / 2.0);\npi = normalize(vec2(uw.x - uv.x + 0.001, uv.y - uw.y));\npj = qj(pi);\npk = pj;\nph = ux;\npg = uy;\n} else {\nxc = 0.0;\nfloat yy = distance(tr, ts);\nvec2 yz = normalize(ts - tr);\nvec2 za = (tr + ts) / 2.0;\nvec2 zb = qj(yz);\nvec2 zc = za + (zb * yy * -oa / CURVATURE_RATIO);\nif (sp(ng, PIECE_EDGE_TEXT) > 0.0) {\nfloat zd;\nfloat ze = ou;\nou = 0.0;\nif (nm > EPSILON) {\nte fn = th(tr, ze / 2.0, oa);\npf = qp(tr, fn.tf, fn.tg, ts, 0.5);\npi = qy(tr, fn.tf, fn.tg, ts, 0.5);\npj = qj(pi);\npk = pj;\nzd = rq(tr, fn.tf, fn.tg, ts, 0.5);\n} else if (abs(oa) > EPSILON) {\npf = ql(tr, zc, ts, 0.5);\npi = qw(tr, zc, ts, 0.5);\npj = qj(pi);\npk = pj;\nzd = rk(oa, yy, 1.0);\n} else {\npf = za;\npi = yz;\npj = zb;\npk = zb;\nzd = yy;\n}\nph = ux;\npg = uy;\nif (nr > EPSILON && nm < EPSILON && vd > zd - ze) {\npi = vec2(1.0, 0.0);\npj = vec2(0.0, 1.0);\npk = vec2(0.0, 1.0);\n} else {\nfloat qc = -atan(pi.y, pi.x);\nyh = qc;\nnp -= qc;\nif ((qc > PI / 2.0 || qc < -PI / 2.0)) {\nnp += (1.0 - nm) * PI;\nyi = -1.0;\npi *= -1.0;\npj *= -1.0;\npk *= -1.0;\n}\n}\n} else {\nfloat xg = uz;\nfloat zm = ux;\nfloat zn = uy;\nfloat zo = nj + nk;\nfloat zp = st(xg);\nfloat zq = nj * zp;\nfloat zr = nk * zp;\nfloat zs = sp(ng, PIECE_EDGE_HEAD);\nfloat zt = sp(ng, PIECE_EDGE_TAIL);\nfloat zu = INFINITY * nm + yy - zm - zn;\nfloat zv = min(zu / zo, zp);\nfloat aae =\nnk * (zp + max(zm + zv - zr, 0.0))\n+ (1.0 - nk) * nl * zm;\nfloat aaf =\nnj * (zp + max(zn + zv - zq, 0.0))\n+ (1.0 - nj) * nl * zn;\nif (zs > EPSILON || zt > EPSILON) {\nvec2 aai = zs * ts + zt * tr;\nfloat va = zs * aaf + zt * aae + (HEAD_TAIL_PX_ADJUST - 0.5);\nfloat aaj = zs * zq + zt * zr;\nvec2 aak;\nif (nm > EPSILON) {\nte fn = th(tr, zm, oa);\nfloat zd = rq(tr, fn.tf, fn.tg, ts, 1.0);\nfloat tt = zs * (zd - aaf) + zt * aae;\nfloat t = tq(tr, fn.tf, fn.tg, ts, tt);\naak = qp(tr, fn.tf, fn.tg, ts, t);\n} else {\nfloat zd = rk(oa, yy, 1.0);\nfloat t = (zs * (zd - aaf) + zt * aae) / zd;\naak = ql(tr, zc, ts, t);\n}\npi = normalize(aai - aak);\npj = qj(pi);\npk = pj;\npf = aai - pi * (va - aaj / 2.0);\nph = aaj;\npg = aaj;\nnh = 0.0;\nni = 0.0;\n} else {\nfloat aao;\nfloat aap;\nfloat aaq;\nif (abs(oa) < EPSILON) {\npf = za;\npi = yz;\npj = zb;\npk = pj;\nph = yy;\naao = yy;\naap = 0.0;\naaq = yy;\n} else {\nfloat aas = a_vertexInfo.z;\nfloat aat = aas * T_STEP_PER_CURVE_PIECE;\nfloat qu = aat + T_STEP_PER_CURVE_PIECE;\nif (nm < EPSILON) {\nvec2 aau = ql(tr, zc, ts, aat);\nvec2 aav = ql(tr, zc, ts, qu);\npf = (aau + aav) / 2.0;\npi = normalize(aav - aau);\npj = qx(tr, zc, ts, aat);\npk = qx(tr, zc, ts, qu);\nph = distance(aau, aav);\naao = rk(oa, yy, 1.0);\naap = rk(oa, yy, aat);\naaq = rk(oa, yy, qu);\n} else {\nte fn = th(tr, zm, oa);\nvec2 rr = fn.tf;\nvec2 rs = fn.tg;\nvec2 aau = qp(tr, rr, rs, ts, aat);\nvec2 aav = qp(tr, rr, rs, ts, qu);\npf = (aau + aav) / 2.0;\npi = normalize(aav - aau);\npj = qz(tr, rr, rs, ts, aat);\npk = qz(tr, rr, rs, ts, qu);\nph = distance(aau, aav);\naao = rq(tr, rr, rs, ts, 1.0);\naap = rq(tr, rr, rs, ts, aat);\naaq = rq(tr, rr, rs, ts, qu);\n}\n}\npg = uz;\nwl = (aae - 1.0) / aao;\nwn = 1.0 - (aaf - HEAD_TAIL_PX_ADJUST) / aao;\nwo = aap / aao;\nwp = aaq / aao;\nwq = aao;\nif (nl > 0.0 && zu > 5.0) {\nfloat abb = (aao * pg) / (aao - aae);\nfloat tw = aao;\nfloat oc = aae;\nfloat oe = aao - aaf;\nfloat a = -abb / tw;\nfloat b = abb;\nfloat od = a * oc + b;\nfloat of = a * oe + b;\nfloat abc = od / (oc - oe);\nfloat abd = -abc * oe;\npg = abd;\nxo = abc * tw + abd + 1.0;\n}\n}\n}\n}\nvec2 bb = vec2(0.0, 0.0);\nvec2 pb = vec2(EPSILON, EPSILON);\nvec2 pc = vec2(-EPSILON, -EPSILON);\nfloat pd = -1.0;\nfloat pe = 0.0;\nbool abe = false;\nif (ob > EPSILON && nz > ny) {\nfloat abf = floor(ob / PATTERN_INFO_TEXTURE_SIZE);\nfloat abg = ob - (abf * PATTERN_INFO_TEXTURE_SIZE);\nvec4 abh = texture2D(u_patternInfoTexture, vec2(abg, abf) / 255.0) * 255.0;\nvec2 abi = px(abh.z);\nvec2 abj = px(abh.w);\npd = abi.x * 2.0 + abj.x;\nfloat abk = 0.0;\nif (ao(pd, FILTER_NEAREST)) {\nabk = PATTERN_NEAREST_TEXTURE_SIZE;\n} else if (ao(pd, FILTER_LINEAR)) {\nabk = PATTERN_LINEAR_TEXTURE_SIZE;\n} else if (ao(pd, FILTER_LINEAR_SDF)) {\nabk = PATTERN_LINEAR_SDF_TEXTURE_SIZE;\nabe = true;\n} else if (ao(pd, FILTER_MIPMAP)) {\nabk = PATTERN_MIPMAP_TEXTURE_SIZE;\n}\nfloat abl = 1.0 / abk;\nvec2 abm = (vec2(abi.y, abj.y) * PATTERN_POSITION_GRANULARITY) * abl / 2.0;\nvec2 abn = (abh.xy * PATTERN_POSITION_GRANULARITY * abl) + abm;\nabn += PATTERN_MARGIN * abl;\nabm -= PATTERN_MARGIN * abl * 2.0;\nvec2 abo = vec2(ph / 2.0, pg / 2.0) * abl;\nvec2 abp = vec2(ou, ou) * abl;\nfloat abq = 1.0 * u_pixelRatio;\nif (no > EPSILON) {\nif (abe) {\npe = 2.0 / vf;\nabq = SDF_FONT_SIZE / vf;\n} else {\nabq = (abm.y / abo.y) / no;\n}\n}\nvec2 abr = (abo + abp) * abq;\nabm += PATTERN_MARGIN * abl;\nbb = abn + abr * vb;\npb = abn - abm;\npc = abn + abm;\n}\nif (nq > EPSILON) {\nvc.y = a.os * vf / 2.0 - 1.0;\nxa = 0.0;\nxc = 0.0;\nif (abe) {\nvc.x = ceil(a.or * BYTES_TO_TEXT_OFFSET * vf);\n} else {\nvc.x = floor(a.or);\n}\nvc += vec2(1.0, 1.0);\nvc = qa(vc, yh);\nvc *= yi;\n}\nvec2 abu = vec2(cos(np), sin(np)) * va;\nvec2 abv = pf + abu + vc;\nif (nq > EPSILON && sp(ng, PIECE_NODE_COMPONENT) > EPSILON) {\nabv = ceil(abv);\n}\nfloat abw = ou * 2.0;\nfloat abx = ph + xc * (abw + 1.0);\nfloat aby = pg + xa * (abw + 1.0);\nvec2 abz = pi * abx / 2.0;\nvec2 aca = pj * aby / 2.0;\nvec2 acb = pk * aby / 2.0;\nfloat acc = (wp - wo);\nfloat acd = vb.x / 2.0 + 0.5;\nfloat ow = wo + acc * acd;\nfloat pa = xn + (xo - xn) * ow / 2.0;\nfloat ace = step(nf, FIRST_COMPLEX_SHAPE_ID - EPSILON);\nfloat acf = ace * SIMPLE_SHAPE_SAMPLING_SIZE + (1.0 - ace) * COMPLEX_SHAPE_SAMPLING_SIZE;\nfloat acg = acf / COMPLEX_SHAPE_SAMPLING_SIZE;\nfloat ach = acg * SHAPE_SAMPLING_BUFFER_RATIO / 2.0;\nfloat aci = acg * (1.0 - SHAPE_SAMPLING_BUFFER_RATIO);\nvec2 acr = vec2(mod(nf, NB_SHAPES_BY_SIDE), floor(nf / NB_SHAPES_BY_SIDE));\nvec2 acs = acr + vec2(ach) + vec2(wo * aci, 0.0);\nvec2 acv = vec2(acc, 1.0) * aci;\nvec2 ov = (acs + acv * (vb / 2.0 + 0.5)) / NB_SHAPES_BY_SIDE;\nvec2 oz = vec2(abx / acc, aby) / 2.0;\nfloat adc = nh * uz;\nfloat add = ni * uz;\nfloat ox = adc + add;\nfloat oy = (ow * wq) / ox;\nlj.ov = ov;\nlj.oz = oz;\nlj.ou = ou;\nlj.az = az;\nlj.ba = ba;\nlj.bu = bu;\nlj.ow = tc(ow, wl, wn);\nlj.ox = ox;\nlj.nh = adc;\nlj.oy = oy;\nlj.pa = pa;\nlj.bb = bb;\nlj.pb = pb;\nlj.pc = pc;\nlj.pd = pd;\nlj.pe = pe;\nlj.bl = bl;\nlj.pf = abv;\nlj.ph = abx;\nlj.pg = aby;\nlj.pi = pi;\nlj.pj = pj;\nlj.pk = pk;\nreturn true;\n}\nfloat ade(float adf, float adg, vec4 adh) {\nfloat adi = clamp(((u_currentTime - adf) / adg), 0.0, 1.0);\nfloat r = adi;\nfloat adj = r * r;\nfloat adk = adj * r;\nvec4 adl = adi < 0.5 ? qf(adh) : qh(adh);\nfloat adm = adl.x;\nfloat adn = adl.y;\nfloat ado = adl.z;\nfloat adp = adl.w;\nfloat adq = adm + adn * r + ado * adj + adp * adk;\nreturn adq;\n}\nvoid main() {\nnv a_final = tx(\na_final_shapeInfo_miscInfo_opacityAndAllMinVisibleSizes_symbolicSizeAndCurvature,\na_final_patternId_fillRGBA_strokeRGBA_patternRGBA,\na_final_x1_y1_x2_y2,\na_final_rectWidthOrSourceRadiusScaled_rectWidthOrSourceRadiusFixed_rectHeightOrTargetRadiusScaled_rectHeightOrTargetRadiusFixed,\na_final_thicknessOrFontSizeScaled_thicknessOrFontSizeFixed_strokeWidthScaled_strokeWidthFixed,\na_final_offsetScaled_offsetFixed,\na_text_charId_charOffsetXY\n);\n#if ANIMATED\nfloat adf = a_animationBeginTime_animationDuration.x;\nfloat adg = a_animationBeginTime_animationDuration.y;\nvec4 adh = a_animationEasing;\nfloat ut = ade(adf, adg, adh);\nnv a_prev = tx(\na_prev_shapeInfo_miscInfo_opacityAndAllMinVisibleSizes_symbolicSizeAndCurvature,\na_prev_patternId_fillRGBA_strokeRGBA_patternRGBA,\na_prev_x1_y1_x2_y2,\na_prev_rectWidthOrSourceRadiusScaled_rectWidthOrSourceRadiusFixed_rectHeightOrTargetRadiusScaled_rectHeightOrTargetRadiusFixed,\na_prev_thicknessOrFontSizeScaled_thicknessOrFontSizeFixed_strokeWidthScaled_strokeWidthFixed,\na_prev_offsetScaled_offsetFixed,\na_text_charId_charOffsetXY\n);\nconst float ONE = 1.0;\na_final.nf = mix(a_prev.nf, a_final.nf, ONE);\na_final.nh = mix(a_prev.nh, a_final.nh, ut);\na_final.ni = mix(a_prev.ni, a_final.ni, ut);\na_final.nj = mix(a_prev.nj, a_final.nj, ONE);\na_final.nk = mix(a_prev.nk, a_final.nk, ONE);\na_final.ng = mix(a_prev.ng, a_final.ng, ONE);\na_final.no = mix(a_prev.no, a_final.no, ONE);\na_final.nq = mix(a_prev.nq, a_final.nq, ONE);\na_final.nr = mix(a_prev.nr, a_final.nr, ONE);\na_final.ns = mix(a_prev.ns, a_final.ns, ONE);\na_final.nt = mix(a_prev.nt, a_final.nt, ONE);\na_final.nm = mix(a_prev.nm, a_final.nm, ONE);\na_final.np = mix(a_prev.np, a_final.np, ut);\na_final.bu = mix(a_prev.bu, a_final.bu, ut);\na_final.nw = mix(a_prev.nw, a_final.nw, ut);\na_final.nx = mix(a_prev.nx, a_final.nx, ut);\na_final.ny = mix(a_prev.ny, a_final.ny, ut);\na_final.nz = mix(a_prev.nz, a_final.nz, ut);\na_final.oa = mix(a_prev.oa, a_final.oa, ut);\na_final.ob = mix(a_prev.ob, a_final.ob, ONE);\na_final.az = mix(a_prev.az, a_final.az, ut);\na_final.ba = mix(a_prev.ba, a_final.ba, ut);\na_final.bl = mix(a_prev.bl, a_final.bl, ut);\na_final.oc = mix(a_prev.oc, a_final.oc, ut);\na_final.od = mix(a_prev.od, a_final.od, ut);\na_final.oe = mix(a_prev.oe, a_final.oe, ut);\na_final.of = mix(a_prev.of, a_final.of, ut);\na_final.og = mix(a_prev.og, a_final.og, ut);\na_final.oh = mix(a_prev.oh, a_final.oh, ut);\na_final.oi = mix(a_prev.oi, a_final.oi, ut);\na_final.oj = mix(a_prev.oj, a_final.oj, ut);\na_final.ok = mix(a_prev.ok, a_final.ok, ut);\na_final.ol = mix(a_prev.ol, a_final.ol, ut);\na_final.om = mix(a_prev.om, a_final.om, ut);\na_final.on = mix(a_prev.on, a_final.on, ut);\na_final.oo = mix(a_prev.oo, a_final.oo, ut);\na_final.op = mix(a_prev.op, a_final.op, ut);\na_final.oq = mix(a_prev.oq, a_final.oq, ONE);\na_final.or = mix(a_prev.or, a_final.or, ONE);\na_final.os = mix(a_prev.os, a_final.os, ONE);\n#endif\not lj;\nbool adr = uu(a_final, lj);\nif (!adr) {\nsj();\nreturn;\n}\nvec2 vb = a_vertexInfo.xy;\na = lj.az;\nb = lj.ba;\nc = lj.bl;\nd = lj.ov;\ne = lj.bb;\n#if D3D9_FIX\nf = vec4(lj.pb, lj.pc);\ng = vec3(lj.ou, lj.bu, lj.pa);\nh = vec4(lj.ow, lj.ox, lj.nh, lj.oy);\ni = vec4(lj.oz, lj.pe, lj.pd);\n#else\nj = lj.ou;\nk = lj.pb;\nl = lj.pc;\nm = vec2(lj.bu, lj.pa);\nn = lj.ow;\no = lj.ox;\np = vec2(lj.nh, lj.oy);\nq = lj.oz;\nr = lj.pe;\ns = lj.pd;\n#endif\nfloat ads = step(vb.x, 0.0);\nfloat adt = 1.0 - ads;\nvec2 sl = lj.pf\n+ (lj.pi * (lj.ph / 2.0) * vb.x)\n+ ((ads * lj.pj + adt * lj.pk) * (lj.pg / 2.0) * vb.y);\ngl_Position = sk(sl);\n}\n", vr = "#define D3D9_FIX 0\nprecision highp float;\nprecision mediump int;\nuniform vec3 u_backgroundColor;\nuniform sampler2D u_patternNearestTexture;\nuniform sampler2D u_patternLinearTexture;\nuniform sampler2D u_patternLinearSdfTexture;\nuniform sampler2D u_patternMipmapTexture;\nuniform sampler2D u_shapeTexture;\nvarying vec4 a;\nvarying vec4 b;\nvarying vec4 c;\nvarying vec2 d;\nvarying vec2 e;\n#if D3D9_FIX\nvarying vec4 f;\nvarying vec3 g;\nvarying vec4 h;\nvarying vec4 i;\n#else\nvarying float j;\nvarying vec2 k;\nvarying vec2 l;\nvarying vec2 m;\nvarying float n;\nvarying float o;\nvarying vec2 p;\nvarying vec2 q;\nvarying float r;\nvarying float s;\n#endif\nconst float FILTER_NEAREST = 0.0;\nconst float FILTER_LINEAR = 0.0;\nconst float FILTER_LINEAR_SDF = 0.0;\nconst float FILTER_MIPMAP = 0.0;\nconst float EPSILON = 0.000000001;\nconst float SDF_BUFFER = (256.0 - 64.0) / 256.0; \nvec4 ad(in vec4 ae, in vec4 af) {\nfloat ag = af.a;\nfloat ah = ae.a + EPSILON;\nfloat ai = min(ag + ah, 1.0);\nfloat r = ag / ai;\nreturn vec4(mix(ae.rgb, af.rgb, r), ai);\n}\nfloat aj(in float ak, in float al) {\nfloat am = (ak * 256.0 + al) * 256.0;\nfloat an = am / 32768.0;\nreturn an * 2.0 - 1.0;\n}\nbool ao(float ap, float aq) {\nreturn abs(ap - aq) < EPSILON;\n}\nvoid main() {\n#if D3D9_FIX\nfloat j = g.x;\nfloat ar = g.y;\nfloat as = g.z;\nvec2 k = f.xy;\nvec2 l = f.zw;\nfloat n = h.x;\nfloat o = h.y;\nfloat at = h.z;\nfloat au = h.w;\nvec2 q = i.xy;\nfloat r = i.z;\nfloat s = i.w;\n#else\nfloat ar = m.x;\nfloat as = m.y;\nfloat at = p.x;\nfloat au = p.y;\n#endif\nvec4 av = texture2D(u_shapeTexture, d);\nfloat aw = aj(av.b, av.a) * q.x;\nfloat ax = aj(av.r, av.g) * q.y;\nax += as;\nfloat ay = min(aw, ax);\nvec4 az = a;\nvec4 ba = b;\nif (s > -EPSILON) {\nvec2 bb = e;\nfloat bj =\nstep(k.x, bb.x) *\nstep(bb.x, l.x) *\nstep(k.y, bb.y) *\nstep(bb.y, l.y);\nfloat bk = bj;\nvec4 bl;\nif (ao(s, FILTER_NEAREST)) {\nbl = texture2D(u_patternNearestTexture, bb);\n} else if (ao(s, FILTER_LINEAR)) {\nbl = texture2D(u_patternLinearTexture, bb);\n} else if (ao(s, FILTER_LINEAR_SDF)) {\nbl = texture2D(u_patternLinearSdfTexture, bb);\nbl.a = smoothstep(SDF_BUFFER - r, SDF_BUFFER + r, bl.a);\n} else if (ao(s, FILTER_MIPMAP)) {\nbl = texture2D(u_patternMipmapTexture, bb);\n}\nbl.rgb += c.rgb;\nbl.a *= bk;\naz = ad(az, bl);\n}\nfloat bm = clamp(ay, 0.0, 1.0);\nfloat bn = clamp(ay - j, 0.0, 1.0);\nfloat bo = bm - bn;\nbo = 1.0 - clamp(ay - j, 0.0, 1.0);\naz.a *= bn;\nba.a *= bo;\nvec4 bp = ad(az, ba);\nfloat bq = bm;\nbp.rgb = mix(u_backgroundColor, bp.rgb, ar);\nif (o > EPSILON) {\nfloat ch = fract(au) * o;\nfloat ci = clamp(min(ch, at - ch), 0.0, 1.0);\nbq *= ci;\n}\nif (n < 0.0 || n > 1.0 || bq < EPSILON) {\ndiscard;\n}\nbp.a *= bq;\nbp.rgb *= bp.a;\ngl_FragColor = bp;\n}\n"; (pr = gr = gr || {})[pr.INIT = 0] = "INIT", pr[pr.COMPILING = 1] = "COMPILING", pr[pr.DONE = 2] = "DONE"; var mr = (yr.prototype.setConstant = function (t, value) { this._constants[t] = value }, yr.prototype.setMacro = function (t, value) { this._macros[t] = value }, yr.prototype.getState = function () { return this._state }, yr.prototype.getProgram = function () { return this._program }, yr.prototype.compile = function () { var t = this._gl, e = br(this._vertexSource, this._macros, this._constants), i = br(this._fragmentSource, this._macros, this._constants); this._program && (t.deleteProgram(this._program), t.deleteShader(this._vertexShader), t.deleteShader(this._fragmentShader)), this._program = t.createProgram(), this._vertexShader = t.createShader(t.VERTEX_SHADER), this._fragmentShader = t.createShader(t.FRAGMENT_SHADER), t.shaderSource(this._vertexShader, e), t.compileShader(this._vertexShader), t.attachShader(this._program, this._vertexShader), t.shaderSource(this._fragmentShader, i), t.compileShader(this._fragmentShader), t.attachShader(this._program, this._fragmentShader), t.linkProgram(this._program), this._state = gr.COMPILING }, yr.prototype.getError = function () { var t = this._gl; return t.getShaderParameter(this._vertexShader, t.COMPILE_STATUS) ? t.getShaderParameter(this._fragmentShader, t.COMPILE_STATUS) ? t.getProgramParameter(this._program, t.LINK_STATUS) ? (this._state = gr.DONE, null) : { step: "link", message: t.getProgramInfoLog(this._program) } : { step: "fragment", message: t.getShaderInfoLog(this._fragmentShader) } : { step: "vertex", message: t.getShaderInfoLog(this._vertexShader) } }, yr); function yr(t, e) { var i = e.vertex, n = e.fragment, r = e.constants, o = e.macros; this._program = null, this._vertexShader = null, this._fragmentShader = null, this._state = gr.INIT, this._gl = t, this._vertexSource = i, this._fragmentSource = n, this._constants = j(r || {}), this._macros = j(o || {}) } function br(t, e, i) { for (var n = Object.keys(e), r = Object.keys(i), o = 0; o < n.length; ++o) { var s = n[o], a = e[s]; t = t.replace("#define " + s + " 0", "#define " + s + " " + a) } for (o = 0; o < r.length; ++o) { var u = r[o], value = i[u], l = value + (value % 1 == 0 ? ".0" : ""); t = t.replace("const float " + u + " = 0.0;", "const float " + u + " = " + l + ";") } return t } var xr, Er, Ar = 0, Sr = ((xr = {})[0] = { min: "NEAREST", mag: "NEAREST", mipmap: !1 }, xr[1] = { min: "LINEAR", mag: "LINEAR", mipmap: !1 }, xr[2] = { min: "LINEAR", mag: "LINEAR", mipmap: !1 }, xr[3] = { min: "LINEAR_MIPMAP_LINEAR", mag: "LINEAR", mipmap: !0 }, xr), wr = ((Er = {})[Ar] = "ALPHA", Er[1] = "RGBA", Er); function Tr(value) { return Math.ceil((value + 2 * Bn) / zn) * zn } function Cr(t, e, i, n, r) { for (var o = 0, s = t.length; o < s; ++o) { var a = t[o], u = a.x, l = a.y, d = u + n, h = l + r, c = d < i && h < i; if (c) for (var f = u; f < d; ++f)if (1 === e[f + l * i]) { c = !1; break } if (c) for (f = l; f < h; ++f)if (1 === e[u + f * i]) { c = !1; break } if (c) { for (f = u; f < d; ++f)for (var g = l; g < h; ++g)e[f + g * i] = 1; return t.splice(o, 1), t.push({ x: u, y: h }, { x: d, y: l }), a } } return null } function Mr(t, e, i, n, r, o, s) { var a = 4 * t, u = e >> 1 << 7, l = e % 2 << 7; s[a] = i / zn, s[1 + a] = n / zn, s[2 + a] = u + r / zn, s[3 + a] = l + o / zn } function Ir(t, e, i, n, r, o, s) { n |= 0, r |= 0, o |= 0, s |= 0, e |= 0; for (var a = 0; a < o; ++a)for (var u = 0; u < s; ++u) { var l = 4 * (n + a + (r + u) * e), d = 4 * (a + u * o); t[l] = i[d], t[1 + l] = i[1 + d], t[2 + l] = i[2 + d], t[3 + l] = i[3 + d] } } function Lr(t, e) { for (var i = 0, n = 4, r = 0; r < t.length; ++r) { var o = t[r], s = o.width, a = o.height, u = Tr(s), l = Tr(a); i += u * l, n = Math.max(n, Math.max(u, l)) } var d = qe(Math.max(n, Math.sqrt(i))); return Math.min(d, e) } function Nr(t, e) { return Math.floor((e - t) / 2) } function kr(t, e, i, n, r, o, s) { var a = Sr[o], u = a.min, l = a.mag, d = a.mipmap, h = t[wr[s]]; if (s === Ar) { for (var c = new Uint8Array(r * r), f = 0; f < c.length; ++f)c[f] = n[4 * f + 3]; n = c } t.activeTexture(t.TEXTURE0 + i), t.bindTexture(t.TEXTURE_2D, e), t.texImage2D(t.TEXTURE_2D, 0, h, r, r, 0, h, t.UNSIGNED_BYTE, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t[l]), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t[u]), d && t.generateMipmap(t.TEXTURE_2D) } function Or(t, e, i, n, r) { for (var o = new Uint8Array(i * i * 4), s = Math.ceil(i / zn), a = new Uint8Array(s * s), u = [{ x: 0, y: 0 }], l = 0; l < e.length; ++l) { var d = e[l], h = d.id, c = Tr(d.width) / zn, f = Tr(d.height) / zn, g = Cr(u, a, s, c, f); if (g) { var p = d.width, _ = d.height, v = d.pixels, m = c * zn, y = f * zn, b = g.x * zn + Nr(p, m), x = g.y * zn + Nr(_, y); Ir(o, i, v, b, x, p, _), Mr(h, t, b, x, m, y, r) } else { if (i < n) return Or(t, e, 2 * i, n, r); hi("exceeded max WebGL texture size of " + n + "; some texts/icons/images won't be displayed"), Mr(h, t, 0, 0, 0, 0, r) } } return { texture: o, size: i } } function Fr(t, e, i, n) { for (var r = t.getDistanceFromStrokeVertically, o = t.getDistanceFromStrokeHorizontally, s = e * (1 - i) / 2, a = (e - 1) / 2, u = 0; u < e; ++u)for (var l = 0; l < e; ++l) { var d = 4 * (l * e + u), h = (u - a) / s, c = (l - a) / s, f = Xe(r(h, c), -1, 1), g = Xe(o(h, c), -1, 1); Pr(n, d, Rr(f), Rr(g)) } } function Rr(value) { return 32768 * ((value + 1) / 2) } function Pr(t, e, i, n) { t[e] = i >> 8, t[e + 1] = i % 256, t[e + 2] = n >> 8, t[e + 3] = n % 256 } function Dr(t, e) { for (var i = -Math.PI / 2, n = 2 * Math.PI / t.length, r = 0, o = t; r < o.length; r++) { var s = i + n; e(o[r], i, s), i = s } } function zr(n, t, r, o, s) { Dr(t, function (t, e, i) { n.beginPath(), n.moveTo(r, o), n.arc(r, o, s, e, i), n.fillStyle = t, n.fill() }) } var Br = (Ur.prototype.refresh = function (t) { for (var e = 0, i = t.getShapeList(); e < i.length; e++) { var n = i[e]; if (!this._shapesWritten.includes(n.id)) { var r = n.isSimple ? 32 : Rn, o = n.isSimple ? this._simpleShapePixels : this._complexShapePixels; Fr(n, r, 1 / 16, o), this._loadShapeInGpu(n.id, r, o), this._shapesWritten.push(n.id) } } }, Ur.prototype._loadShapeInGpu = function (t, e, i) { var n = this._gl, r = Dn, o = t % Pn * Rn, s = Math.floor(t / Pn) * Rn; if (this._texture) n.bindTexture(n.TEXTURE_2D, this._texture); else { var a = new Uint8Array(r * r * 4); this._texture = n.createTexture(), n.activeTexture(n.TEXTURE0 + this._glTextureUnit), n.bindTexture(n.TEXTURE_2D, this._texture), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, r, r, 0, n.RGBA, n.UNSIGNED_BYTE, a) } n.texSubImage2D(n.TEXTURE_2D, 0, o, s, e, e, n.RGBA, n.UNSIGNED_BYTE, i) }, Ur.prototype.getTextureSize = function () { return Dn }, Ur.prototype.getSamplingSize = function () { return Rn }, Ur.prototype.getBufferRatio = function () { return 1 / 16 }, Ur.prototype.getTextureUnit = function () { return this._glTextureUnit }, Ur); function Ur(t, e) { this._gl = t, this._glTextureUnit = e, this._simpleShapePixels = new Uint8Array(4096), this._complexShapePixels = new Uint8Array(65536), this._texture = null, this._shapesWritten = [] } var Vr = 1e20, jr = (Gr.prototype.getFontToImageSizeRatio = function () { return 1 + 2 * this._buffer / this._fontSize }, Gr.prototype.draw = function (t, e, i) { or(this._ctx, e, this._fontSize, i); var value, n = this._ctx.measureText(t).width + 2 * this._buffer, r = (value = n, Math.ceil((value + 2 * Bn) / zn) * zn - 2 * Bn), o = this._height, s = r * o, a = Math.max(r, o); this._canvas.width < r && (this._canvas.width = r, or(this._ctx, e, this._fontSize, i), this._ctx.textAlign = "center", this._ctx.textBaseline = "middle", this._ctx.fillStyle = "black"), s > this._gridSize && (this._gridOuter = new Float64Array(s), this._gridInner = new Float64Array(s), this._gridSize = s), a > this._maxDimension && (this._f = new Float64Array(a), this._d = new Float64Array(a), this._z = new Float64Array(a + 1), this._v = new Int16Array(a), this._maxDimension = a), this._ctx.clearRect(0, 0, r, o), this._ctx.fillText(t, r / 2, o / 2); for (var u = this._ctx.getImageData(0, 0, r, o), l = new Uint8ClampedArray(s), d = 0; d < s; d++) { var h = u.data[4 * d + 3] / 255; this._gridOuter[d] = 1 == h ? 0 : 0 == h ? Vr : Math.pow(Math.max(0, .5 - h), 2), this._gridInner[d] = 1 == h ? Vr : 0 == h ? 0 : Math.pow(Math.max(0, h - .5), 2) } for (Hr(this._gridOuter, r, o, this._f, this._d, this._v, this._z), Hr(this._gridInner, r, o, this._f, this._d, this._v, this._z), d = 0; d < s; d++) { var c = this._gridOuter[d] - this._gridInner[d]; l[d] = Math.max(0, Math.min(255, Math.round(255 - 255 * (c / this._radius + this._cutoff)))) } return { height: o, width: r, distance: l } }, Gr); function Gr(t) { var e = void 0 === t ? {} : t, i = e.fontSize, n = void 0 === i ? 24 : i, r = e.buffer, o = void 0 === r ? 6 : r, s = e.radius, a = void 0 === s ? 8 : s, u = e.cutoff, l = void 0 === u ? .25 : u; this._maxDimension = 1, this._gridSize = 1, this._gridOuter = null, this._gridInner = null, this._f = null, this._d = null, this._z = null, this._v = null, this._fontSize = n, this._buffer = o, this._radius = a, this._cutoff = l, this._height = Math.ceil(this._fontSize + 2 * this._buffer * 1.5), this._canvas = nr(), this._canvas.height = this._height, this._canvas.width = 1, this._ctx = this._canvas.getContext("2d"), this._ctx.textBaseline = "middle", this._ctx.textAlign = "center", this._ctx.fillStyle = "black" } function Hr(t, e, i, n, r, o, s) { for (var a = 0; a < e; a++) { for (var u = 0; u < i; u++)n[u] = t[u * e + a]; qr(n, r, o, s, i); for (u = 0; u < i; u++)t[u * e + a] = r[u] } for (u = 0; u < i; u++) { for (a = 0; a < e; a++)n[a] = t[u * e + a]; qr(n, r, o, s, e); for (a = 0; a < e; a++)t[u * e + a] = Math.sqrt(r[a]) } } function qr(t, e, i, n, r) { n[i[0] = 0] = -Vr, n[1] = +Vr; for (var o = 1, s = 0; o < r; o++) { for (var a = (t[o] + o * o - (t[i[s]] + i[s] * i[s])) / (2 * o - 2 * i[s]); a <= n[s];)s-- , a = (t[o] + o * o - (t[i[s]] + i[s] * i[s])) / (2 * o - 2 * i[s]); i[++s] = o, n[s] = a, n[s + 1] = +Vr } for (o = 0, s = 0; o < r; o++) { for (; n[s + 1] < o;)s++; e[o] = (o - i[s]) * (o - i[s]) + t[i[s]] } } var Wr = 128 - 2 * Bn, Xr = 128 - 2 * Bn, Yr = (Zr.prototype.refresh = function (t) { this._pixelRatio = t.getPixelRatio(); for (var e = this._gl, i = this._getPatternsByFilter(t.getPatternList()), n = 0; n < i.length; ++n) { var r = n, o = i[n], s = Or(r, o, Lr(o, this._maxTextureSize), this._maxTextureSize, this._patternIdToInfoTexture), a = s.texture, u = s.size, l = this._glTextures[r] || (this._glTextures[r] = e.createTexture()), d = 0 === r ? Ar : 1; kr(e, l, this._glUnit + 1 + r, a, u, r, d), this._textureSizes[r] = u } var h = this._glTextureInfo || (this._glTextureInfo = e.createTexture()), c = this._patternIdToInfoTexture; kr(e, h, this._glUnit, c, 256, 0, 1) }, Zr.prototype.bindMetDataTexture = function () { var t = this._gl; t.activeTexture(t.TEXTURE0 + this._glUnit), t.bindTexture(t.TEXTURE_2D, this._glTextureInfo) }, Zr.prototype.getGranularity = function () { return zn }, Zr.prototype.getInfoTextureUnit = function () { return this._glUnit }, Zr.prototype.getNearestTextureUnit = function () { return this._glUnit + 1 + 0 }, Zr.prototype.getLinearTextureUnit = function () { return this._glUnit + 1 + 1 }, Zr.prototype.getLinearSdfTextureUnit = function () { return this._glUnit + 1 + 2 }, Zr.prototype.getMipmapTextureUnit = function () { return this._glUnit + 1 + 3 }, Zr.prototype.getInfoTextureSize = function () { return 256 }, Zr.prototype.getNearestTextureSize = function () { return this._textureSizes[0] }, Zr.prototype.getLinearTextureSize = function () { return this._textureSizes[1] }, Zr.prototype.getLinearSdfTextureSize = function () { return this._textureSizes[2] }, Zr.prototype.getMipmapTextureSize = function () { return this._textureSizes[3] }, Zr.prototype._getPatternsByFilter = function (t) { for (var e = new Array(4), i = 0; i < 4; ++i)e[i] = []; for (i = 0; i < t.length; ++i) { var n = this._getPatternPixels(t[i]); e[n.filter].push(n) } return e }, Zr.prototype._getPatternPixels = function (t) { var e = t.id, i = t.type, n = t.attributes, r = null; switch (i) { case yn: r = n.duplicated ? this._getDuplicatedImagePixels(n.image) : n.scaled ? this._getScaledImagePixels(n.image) : this._getNonScaledImagePixels(n.image); break; case 3: var o = n.text, s = n.font, a = n.style, u = n.size, l = n.offset; r = "sdf" === n.size ? this._getSdfTextPixels(o, s, a) : this._getRegularTextPixels(o, s, a, u, l); break; case xn: r = this._getIconPixels(n.text, n.font, n.style); break; case En: r = this._getBadgeIconPixels(n.text, n.font, n.style); break; case bn: r = this._getPieChartPixels(n.colorArray); break; default: throw new Error('pattern type "' + i + '" does not exist') }return r.id = e, r }, Zr.prototype._getScaledImagePixels = function (t) { var e = t.width, i = t.height; if (Un < e || Un < i) { var n = Un / Math.max(t.width, t.height); e *= n, i *= n } return e && i && (e = Tr(e), i = Tr(i)), e -= 2 * Bn, i -= 2 * Bn, this._getImagePixels(t, e, i) }, Zr.prototype._getNonScaledImagePixels = function (t) { return this._getImagePixels(t, t.width, t.height) }, Zr.prototype._getDuplicatedImagePixels = function (t) { if (0 === t.width || 0 === t.height) return this._getImagePixels(t, 0, 0); this._canvasForDuplicatedImage || (this._canvasForDuplicatedImage = nr(), this._canvasForDuplicatedImage.width = Un, this._canvasForDuplicatedImage.height = Un); for (var e = this._canvasForDuplicatedImage, i = e.getContext("2d"), n = t.width, r = t.height, o = (Un - n) / 2, s = (Un - r) / 2; 0 < o;)o -= n; for (; 0 < s;)s -= r; for (var a = o; a < Un; a += n)for (var u = s; u < Un; u += r)i.drawImage(t, a, u); return this._getImagePixels(e, Un, Un) }, Zr.prototype._getImagePixels = function (t, e, i) { var n; if (0 === e || 0 === i) n = new Uint8Array(0); else { (this._imageCanvas.width < e || this._imageCanvas.height < i) && (this._imageCanvas.width = e, this._imageCanvas.height = i); var r = this._imageCanvasContext; rr(this._imageCanvas, r, e, i); try { r.drawImage(t, 0, 0, e, i) } catch (t) { } n = r.getImageData(0, 0, e, i).data } return { width: e, height: i, pixels: n, filter: 3 } }, Zr.prototype._getPieChartPixels = function (t) { var e = Xr, i = this._imageCanvasContext, n = e / 2, r = e / 2; return rr(this._imageCanvas, i, e, e), i.save(), i.rect(0, 0, e, e), i.clip(), zr(i, t, n, r, e), i.restore(), { width: e, height: e, pixels: i.getImageData(0, 0, e, e).data, filter: 1 } }, Zr.prototype._getTextPixels = function (t, e, i, n, r, o) { var s = this._imageCanvasContext, a = r * this._pixelRatio; or(s, i, a, n); var u = s.measureText(e).width; 0 === u && (u = a); var l = 0, d = 0; 3 === t || (l = 2 * Math.ceil(1.5 * a / 2), d = 2 * Math.ceil(1.2 * u / 2)); var h = Math.ceil(u + d), c = Math.ceil(a + l), f = this._imageCanvas.height < c || this._imageCanvas.width < h; return this._imageCanvas.height < c && (this._imageCanvas.height = c), this._imageCanvas.width < h && (this._imageCanvas.width = h), f && or(s, i, a, n), s.clearRect(0, 0, h, c), s.fillStyle = "black", s.textBaseline = "middle", s.textAlign = "left", s.fillText(e, o + d / 2, c / 2), { width: h, height: c, pixels: s.getImageData(0, 0, h, c).data, filter: t } }, Zr.prototype._getRegularTextPixels = function (t, e, i, n, r) { return this._getTextPixels(0, t, e, i, n, r) }, Zr.prototype._getIconPixels = function (t, e, i) { return this._getTextPixels(3, t, e, i, Wr, 0) }, Zr.prototype._getBadgeIconPixels = function (t, e, i) { return this._getSdfTextPixels(t, e, i) }, Zr.prototype._getSdfTextPixels = function (t, e, i) { for (var n = this._sdfGenerator.draw(t, e, i), r = n.width, o = n.height, distance = n.distance, s = new Uint8Array(r * o * 4), a = 0; a < distance.length; ++a)s[4 * a + 3] = distance[a]; return { width: r, height: o, pixels: s, filter: 2 } }, Zr); function Zr(t, e) { this._patternIdToInfoTexture = new Uint8Array(262144), this._glTextureInfo = null, this._glTextures = [], this._textureSizes = [], this._pixelRatio = 1, this._gl = t, this._glUnit = e, this._imageCanvas = nr(), this._imageCanvas.width = Un, this._imageCanvas.height = Un, this._imageCanvasContext = this._imageCanvas.getContext("2d"), this._canvasForDuplicatedImage = null, this._sdfGenerator = new jr({ fontSize: 24 }), this._maxTextureSize = Math.min(4096, t.getParameter(t.MAX_TEXTURE_SIZE)) } function Kr() { var t = yt(), e = t.styleSheets; if (!e || !t.location) return Promise.resolve([]); for (var i = Wt(t), n = [], r = [], o = 0; o < e.length; o++) { var s = e[o]; null === s.href ? n.push({ href: i, content: s.ownerNode.textContent }) : r.push(s.href) } var a = /@font-face\s*\{[^}]+\}/g; return Promise.all(r.map(function (e) { return Bt(e).then(function (t) { return { href: e, content: t } }).catch(function () { return null }) })).then(function (t) { return t.concat(n) }).then(function (t) { for (var e = [], i = 0; i < t.length; i++) { var n = t[i]; if (null !== n) { var r = n.href, o = n.content.match(a); if (o) { var s = $r(o, r); e.push.apply(e, s) } } } return e }) } function Qr(t, n) { return Promise.all(t.map(function (t) { var e = t.formats, o = t.originalRule; return Promise.all(e.map(function (t) { var e = t.format, i = t.url; return n ? Gt(i).then(function (t) { return { format: e, src: t } }).catch(function () { return null }) : { format: e, src: i } })).then(function (t) { for (var e = [], i = 0; i < t.length; i++) { var n = t[i]; null !== n && e.push("url('" + n.src + "') format('" + n.format + "')") } if (0 === e.length) return o; var r = "src: " + e.join(",") + ";"; return o.replace(/src\s*:[^;]+;/g, r) }) })) } var Jr = { "embedded-opentype": !0, svg: !0 }; function $r(t, e) { for (var i = /url\(['"]?([^'")]+)['"]?\)\s+format\(['"]?([^'")]+)['"]?\)/g, n = /font-family\s*:\s*['"]?([^;'"]+)['"]?;/, r = [], o = 0; o < t.length; o++) { for (var s = t[o], a = s.match(n)[1], u = [], l = void 0; l = i.exec(s);) { var d = l[1], h = l[2]; Jr[h.toLowerCase()] || u.push({ format: h, url: to(d, e) }) } r.push({ name: a, formats: u, originalRule: s }) } return r } function to(t, e) { if (/^http(s)?:/.test(t)) return t; if ("/" === t[0]) { var i = e.match(/((\w+:\/\/)([^/]+))/); return i ? i[1] + t : t } var n = t.split("/"), r = e.split("/"); for ("/" !== e[e.length - 1] && r.pop(); ".." === n[0];)n.shift(), r.pop(); return r.concat(n).join("/").replace(/[\w](\/{2,})/g, function (t) { return t[0] + "/" }) } function eo(t) { if (t.keys) return Array.from(t.keys()); var i = []; return t.forEach(function (t, e) { return i.push(e) }), i } function io(t) { if (t.values) return Array.from(t.values()); var e = []; return t.forEach(function (value) { return e.push(value) }), e } var no = (ro.prototype.reserve = function (t) { if (this._capacity < t) { t = Math.pow(2, Math.ceil(Math.log2(t + 1))); var e = new Uint32Array(t); e.set(this._array), this._capacity = t, this._array = e } }, ro.prototype.has = function (value) { var t = oo(this._array, value, 0, this.length); return t < this.length && this._array[t] === value }, ro.prototype.add = function (value) { var t = oo(this._array, value, 0, this.length), e = t < this.length && this._array[t] === value; return e || (this.length === this._capacity && this.reserve(this.length + 1), this._array.copyWithin(t + 1, t, this.length), this._array[t] = value, this.length += 1), !e }, ro.prototype.remove = function (value) { var t = oo(this._array, value, 0, this.length), e = t < this.length && this._array[t] === value; return e && (this._array.copyWithin(t, t + 1, this.length), --this.length), e }, ro.prototype.removeByPosition = function (t) { return !(t >= this.length || (this._array.copyWithin(t, t + 1, this.length), --this.length, 0)) }, ro.prototype.get = function (t) { return this._array[t] }, ro.prototype.clear = function () { this.length = 0 }, ro.prototype.slice = function () { return this._array.slice(0, this.length) }, ro); function ro() { this._array = new Uint32Array(8), this._capacity = 8, this.length = 0, this._array = new Uint32Array(8), this._capacity = 8, this.length = 0 } function oo(t, e, i, n) { if (i === n) return i; var r = i + ((n - i) / 2 | 0), o = e - t[r]; return 0 == o ? r : o < 0 ? oo(t, e, i, r) : oo(t, e, r + 1, n) } var so = "undefined" == typeof HTMLElement ? function (t) { return !1 } : function (t) { return t instanceof HTMLElement }, ao = function (t) { return "object" != typeof t || null === t || I(t) || ((e = t) instanceof RegExp || e instanceof Date); var e }; function uo(t, e, i) { if (void 0 === e && (e = []), void 0 === i && (i = []), !so(t)) { if (ao(t)) e.push({ path: i.slice(), value: t }); else for (var n = Object.keys(t), r = 0; r < n.length; ++r) { var o = n[r], s = i.slice(); s.push(o), uo(t[o], e, s) } return e } } var lo = (Object.defineProperty(ho.prototype, "size", { get: function () { return this._size }, enumerable: !0, configurable: !0 }), ho.prototype.set = function (t, value) { var e = this._getIndex(t); -1 !== e ? this._values[e] = value : (co(this._cachedPath, t) && (this._cachedIndex = this._keys.length), this._keys.push(t), this._values.push(value), this._size += 1) }, ho.prototype.get = function (t) { var e = this._getIndex(t); if (-1 !== e) return this._values[e] }, ho.prototype.has = function (t) { return -1 !== this._getIndex(t) }, ho.prototype.keys = function () { return this._keys.slice() }, ho.prototype._getIndex = function (t) { if (co(t, this._cachedPath)) return this._cachedIndex; this._cachedPath = t.slice(); for (var e = this._keys, i = 0; i < e.length; ++i)if (co(e[i], t)) return this._cachedIndex = i; return this._cachedIndex = -1 }, ho); function ho() { this._keys = [], this._values = [], this._size = 0, this._cachedPath = [], this._cachedIndex = -1 } function co(t, e) { if (t.length !== e.length) return !1; for (var i = 0; i < t.length; ++i)if (t[i] !== e[i]) return !1; return !0 } var fo = Set.prototype.keys ? function (t) { return Array.from(t.keys()) } : function (t) { var e = []; return t.forEach(function (t) { return e.push(t) }), e }, go = Set.prototype.values ? function (t) { return Array.from(t.values()) } : function (t) { var e = []; return t.forEach(function (t, value) { return e.push(value) }), e }, po = M("webworker-threads"), _o = po ? po.Worker : null; function vo(t) { return _o ? function t(e) { { if (ArrayBuffer.isView(e)) return Array.from(e); if (Array.isArray(e)) { for (var i = 0; i < e.length; ++i)e[i] = t(e[i]); return e } if (J(e)) { for (var n = Object.keys(e), r = 0, o = n; r < o.length; r++) { var s = o[r]; e[s] = t(e[s]) } return e } } return e }(t) : t } function mo(t) { return _o ? new _o(new Function(t)) : "undefined" == typeof URL || -1 !== navigator.appVersion.indexOf("MSIE 10") ? new yo(t) : function (e) { try { var t = new Blob([e], { type: "application/javascript" }), i = URL.createObjectURL(t); return new Worker(i) } catch (t) { return new yo(e) } }(t) } var yo = (bo.prototype.terminate = function () { this._terminated = !1, this._otherSide._terminated = !0 }, bo.prototype.addEventListener = function (t, e) { this._listeners.push(e) }, bo.prototype.postMessage = function (t) { setTimeout(So, 0, this._otherSide, { data: t }) }, bo); function bo(t) { this._main = !0, this._listeners = [], this._terminated = !1, this._f = new Function("self", t), this._otherSide = new Eo(this), this._f(this._otherSide) } var xo, Eo = (Ao.prototype.addEventListener = function (t, e) { this._listeners.push(e) }, Ao.prototype.postMessage = function (t) { setTimeout(So, 0, this._otherSide, { data: t }) }, Ao); function Ao(t) { this._listeners = [], this._main = !1, this._terminated = !1, this._otherSide = t } function So(t, e) { if (!t._terminated) for (var i = 0; i < t._listeners.length; ++i)t._listeners[i](e) } var wo = M("xmldom"); xo = "undefined" != typeof XMLSerializer ? XMLSerializer : wo ? wo.XMLSerializer : null; var To = (Co.prototype.setAttribute = function (t, value) { this._attributes[t] = value }, Co.prototype.appendChild = function (t) { this._children.push(t) }, Object.defineProperty(Co.prototype, "tagName", { get: function () { return this._name }, enumerable: !0, configurable: !0 }), Object.defineProperty(Co.prototype, "children", { get: function () { return this._children }, enumerable: !0, configurable: !0 }), Object.defineProperty(Co.prototype, "childNodes", { get: function () { return this._children }, enumerable: !0, configurable: !0 }), Object.defineProperty(Co.prototype, "firstChild", { get: function () { return this._children[0] || null }, enumerable: !0, configurable: !0 }), Co.prototype.serialize = function () { var t = this._name, e = this._attributes, i = this._children, n = Object.keys(e).filter(function (t) { return void 0 !== e[t] }).map(function (t) { return " " + t + '="' + e[t] + '"' }).join(""), r = i.map(function (t) { return t.serialize() }).join(""); return r.length ? "<" + t + n + ">" + r + "</" + t + ">" : "<" + t + n + "/>" }, Co.prototype.cloneNode = function (t) { for (var e = new Co(this._name), i = 0, n = Object.keys(this._attributes); i < n.length; i++) { var r = n[i]; e.setAttribute(r, this._attributes[r]) } if (t) for (var o = 0; o < this._children.length; o++)e.appendChild(this._children[o].cloneNode(t)); return e }, Co); function Co(t) { this._attributes = {}, this._children = [], this._name = t } var Mo = (Io.prototype.serialize = function () { return this._text }, Io.prototype.cloneNode = function () { return new Io(this._text) }, Io); function Io(t) { this._text = t } var Lo = (No.prototype.appendChild = function (t) { this._children.push(t) }, No.prototype.serialize = function () { return this._meta.concat(this._children.map(function (t) { return t.serialize() })).join("") }, No.prototype.createElement = function (t) { return new To(t) }, No.prototype.createTextNode = function (t) { return new Mo(t) }, No); function No() { this._children = [], this._meta = [], this._children = [], this._meta = [] } function ko() { return new Lo } function Oo(t) { return (new xo).serializeToString(t) } function Fo() { return yt().implementation.createDocument("", "", null) } var Ro = (Po.prototype.add = function (t) { var e = this._keyToIndex[t]; -1 === e && (e = this._size++ , this._heap[e] = t), this._keyToIndex[t] = this._bubble(e) }, Po.prototype.removeMin = function () { if (0 === this._size) return NaN; var t = this._heap[0]; return this._heap[0] = this._heap[--this._size], this._bubble(0), t }, Po.prototype.isEmpty = function () { return 0 === this._size }, Po.prototype.has = function (t) { return -1 !== this._keyToIndex[t] }, Po.prototype._bubble = function (t) { var value = this._indexToValue(t), e = this._getParentIndex(t), i = this._indexToValue(e), n = t; if (0 !== t && value < i) n = this._swap(t, e); else { var r = this._getLeftChildIndex(t), o = this._getRightChildIndex(t), s = this._indexToValue(r), a = this._indexToValue(o), u = Math.min(value, s, a); u === value || (n = u === s ? this._swap(t, r) : this._swap(t, o)) } return n === t ? t : this._bubble(n) }, Po.prototype._indexToValue = function (t) { return t >= this._size ? 1 / 0 : this._keyToValue[this._heap[t]] }, Po.prototype._getParentIndex = function (t) { return (t - 1) / 2 | 0 }, Po.prototype._getLeftChildIndex = function (t) { return 2 * t + 1 }, Po.prototype._getRightChildIndex = function (t) { return 2 * t + 2 }, Po.prototype._swap = function (t, e) { var i = this._heap[t], n = this._heap[e]; return this._heap[t] = n, this._heap[e] = i, this._keyToIndex[i] = e, this._keyToIndex[n] = t, e }, Po); function Po(t) { this._heap = [], this._size = 0, this._keyToValue = t, this._keyToIndex = new Int32Array(t.length), this._keyToIndex.fill(-1) } var Do = (zo.prototype._get = function (t) { return t.isNode ? this._nodes : this._edges }, zo.prototype.addOrRemoveElements = function (t, e) { return e ? this.addElements(t) : this.removeElements(t) }, zo.prototype.addElements = function (t) { for (var e = this._get(t), i = e.elementList, n = e.flexArray, r = e.indexList, o = r.getLength(), s = 0; s < t._indexes.length; s++) { var a = t._indexes[s]; 1 !== n.get(a) && (n.set(a, 1), r.pushUnchecked(a)) } return i(r.slice(o)) }, zo.prototype.removeElements = function (t) { for (var e = this._get(t), i = e.elementList, n = e.flexArray, r = e.indexList, o = r.getLength(), s = r.getBuffer(), a = 0, u = 0; u < t._indexes.length; u++) { var l = t._indexes[u]; 0 !== n.get(l) && (n.set(l, 0), a += 1) } if (a === o) return i(r.sliceAndReset()); if (0 === a) return i(); var d = this._graph.acquireIndexList(t.isNode), h = 0; for (u = 0; u < o; ++u)l = s[u], 0 === n.get(l) ? (h += 1, d.pushUnchecked(l)) : s[u - h] = l; return r.setLength(o - a), i(d.sliceAndReset()) }, zo.prototype.hasElement = function (t) { return !!this._get(t).flexArray.get(t._index) }, zo.prototype.clear = function () { this._nodes.indexList.isEmpty() || (this._nodes.indexList.reset(), this._nodes.flexArray.reset()), this._edges.indexList.isEmpty() || (this._edges.indexList.reset(), this._edges.flexArray.reset()) }, zo.prototype.isEmpty = function () { return this._nodes.indexList.isEmpty() && this._edges.indexList.isEmpty() }, zo.prototype.getElements = function () { return { nodes: this._nodes.elementList(this._nodes.indexList.slice()), edges: this._edges.elementList(this._edges.indexList.slice()) } }, zo); function zo(t, e) { this._graph = t, this._nodes = { elementList: t.nodeList, flexArray: t.createNodeAttribute({ storage: 1, name: e }), indexList: t.createIndexList(!0) }, this._edges = { elementList: t.edgeList, flexArray: t.createEdgeAttribute({ storage: 1, name: e }), indexList: t.createIndexList(!1) } } var Bo = function () { return { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } }, Uo = (Vo.prototype.reset = function () { return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.minScaledSize = 1 / 0, this.maxScaledSize = -1 / 0, this.minFixedSize = 1 / 0, this.maxFixedSize = -1 / 0, this.width = 0, this.height = 0, this.cx = 0, this.cy = 0, this }, Vo.prototype.addPoint = function (t, e, i, n) { return this.minX = Math.min(this.minX, t), this.minY = Math.min(this.minY, e), this.maxX = Math.max(this.maxX, t), this.maxY = Math.max(this.maxY, e), void 0 !== i && void 0 !== n && ("scaled" === n ? (this.minScaledSize = Math.min(this.minScaledSize, i), this.maxScaledSize = Math.max(this.maxScaledSize, i)) : (this.minFixedSize = Math.min(this.minFixedSize, i), this.maxFixedSize = Math.max(this.maxFixedSize, i))), this.cx = this.minX + (this.maxX - this.minX) / 2, this.cy = this.minY + (this.maxY - this.minY) / 2, this.width = this.maxX - this.minX, this.height = this.maxY - this.minY, this }, Vo.prototype.computeForZoom = function (t) { var e = Math.max(this.maxScaledSize, this.maxFixedSize / t); return Vo.from({ minX: this.minX - e / 2, minY: this.minY - e / 2, maxX: this.maxX + e / 2, maxY: this.maxY + e / 2, width: this.width + e, height: this.height + e }) }, Vo.from = function (t) { var e = void 0 === t ? {} : t, i = e.minX, n = e.minY, r = e.maxX, o = e.maxY, s = e.width, a = e.height, u = new Vo; return u.minX = i, u.minY = n, u.maxX = r, u.maxY = o, u.width = s || (r - i) / 2, u.height = a || (o - n) / 2, u.cx = (i + r) / 2, u.cy = (n + o) / 2, u }, Vo.fromValues = function (t, e, i) { for (var n = 1 / 0, r = 1 / 0, o = -1 / 0, s = -1 / 0, a = -1 / 0, u = 0; u < t.length; u++) { var l = t[u], d = e[u], h = i[u]; l - h < n && (n = l - h), d - h < r && (r = d - h), o < l + h && (o = l + h), s < d + h && (s = d + h), a < h && (a = h) } var c = Vo.from({ minX: n, minY: r, maxX: o, maxY: s }); return c.maxScaledSize = a, c }, Vo.prototype.pad = function (value) { return this.minX -= value, this.minY -= value, this.maxX += value, this.maxY += value, this.width += 2 * value, this.height += 2 * value, this }, Vo.prototype.isValid = function () { return isFinite(this.width) && isFinite(this.height) }, Vo.prototype.extend = function (t) { return this.addPoint(t.minX, t.minY), this.addPoint(t.maxX, t.maxY), this }, Vo.prototype.bottomLeft = function () { return { x: this.minX, y: this.minY } }, Vo.prototype.topRight = function () { return { x: this.maxX, y: this.maxY } }, Vo); function Vo(t) { void 0 === t && (t = {}); var e = t.xValues, i = void 0 === e ? [] : e, n = t.yValues, r = void 0 === n ? [] : n, o = t.scaledSizeValues, s = void 0 === o ? [] : o, a = t.fixedSizeValues, u = void 0 === a ? [] : a; this.minX = Qe(i), this.minY = Qe(r), this.maxX = Ke(i), this.maxY = Ke(r), this.minScaledSize = Qe(s), this.maxScaledSize = Ke(s), this.minFixedSize = Qe(u), this.maxFixedSize = Ke(u), this.cx = this.minX + (this.maxX - this.minX) / 2, this.cy = this.minY + (this.maxY - this.minY) / 2, this.width = this.maxX - this.minX, this.height = this.maxY - this.minY } var jo = (Go.prototype.on = function (t, e) { if ("string" != typeof t) throw new TypeError("Event name must be string"); if ("function" != typeof e) throw new TypeError("Event handler must be function"); var i = this._events = this._events || {}; return (i[t] = i[t] || []).push(e), this }, Go.prototype.off = function (t, e) { if ("string" != typeof t) throw new TypeError("Event name must be string"); var i = this._events = this._events || {}, n = i[t]; if (I(n)) if ("function" != typeof e) i[t] = null; else { var r = n.indexOf(e); -1 !== r && n.splice(r, 1), 0 === n.length && (i[t] = null) } return this }, Go.prototype.fire = function (t) { for (var e = arguments, i = [], n = 1; n < arguments.length; n++)i[n - 1] = e[n]; if ("string" != typeof t) throw new TypeError("Event name must be string"); var r = (this._events = this._events || {})[t]; if (I(r)) for (var o = i, s = 0; s < r.length; s++) { var a = r[s]; a && a.apply(this, o) } return this }, Go.prototype.once = function (n, r) { var o = this, s = function () { for (var t = arguments, e = [], i = 0; i < arguments.length; i++)e[i] = t[i]; r.apply(o, e), o.off(n, s) }; return s.handler = r, this.on(n, s) }, Go.prototype.hasListener = function (t, e) { if (!t || !e) return !1; var i = (this._events = this._events || {})[t]; if (I(i)) for (var n = 0, r = i.length; n < r; n++) { var o = i[n]; if (o === e || o.handler === e) return !0 } return !1 }, Go.prototype.getListeners = function (t) { return (this._events = this._events || {})[t] }, Go); function Go() { } var Ho = Object.freeze({ __proto__: null, BoundingBox: Uo, FlexArray: Ve, EventTarget: jo, ColorManager: _n, Table: oi, setKeys: fo, setValues: go, requestAnimFrame: rt, cancelAnimFrame: ot, DummyCanvas: Jn, DummyCanvasRenderingContext2D: tr, createCanvas: nr, clearCanvas: rr, setCtxFont: or, isWebGLSupported: sr, getWebglContext: ar, getDocumentFontRules: Kr, getEmbeddedFontRules: Qr, resolvePath: to, IndexList: $e, mapKeys: eo, mapValues: io, isInteger: function (t) { return "number" == typeof t && t % 1 == 0 }, toPropertyPath: F, throttle: R, debounce: function (e, i, n) { var r, o, s, a, u; function l() { var t = Date.now() - a; t < i && 0 <= t ? r = setTimeout(l, i - t) : (r = null, n || (u = e.apply(s, o), s = o = null)) } function t() { s = this, o = arguments, a = Date.now(); var t = n && !r; return r = r || setTimeout(l, i), t && (u = e.apply(s, o), s = o = null), u } return 0 !== i && void 0 !== i || (i = 100), t.clear = function () { r && (clearTimeout(r), r = null) }, t.flush = function () { r && (u = e.apply(s, o), s = o = null, clearTimeout(r), r = null) }, t }, processQueue: function (i, n) { return new Promise(function (t, e) { return function e(i, n, r, o, s) { r(i[n], n, i, o, s).then(function (t) { n === i.length - 1 ? o(t) : e(i, n + 1, r, o, s) }).catch(s) }(i, 0, n, t, e) }) }, isLittleEndian: P, promiseQueue: D, hash8: z, isRawObject: B, getValues: U, forEach: V, deepCopy: j, updateObject: function e(i, t) { V(t, function (t, value) { "object" == typeof value && null !== value ? ("object" == typeof i[t] && null !== i[t] || (i[t] = {}), e(i[t], value)) : i[t] = value }) }, extendList: function (e, t) { t.forEach(function (t) { -1 === e.indexOf(t) && e.push(t) }) }, setProperty: G, getProperty: H, flatten: q, unflatten: W, getFlattenedKeys: Y, getLeafValues: Z, ensureTransferable: K, getOptions: Q, isObject: J, mergeValues: $, pick: tt, objToValueList: uo, PathMap: lo, smartRequire: M, getDocument: yt, getStyle: bt, DummyDomElement: xt, createDummyDomElement: St, getPixelRatio: wt, dataUrlToBlob: Tt, createBlob: Mt, isBlob: function (t) { return "undefined" != typeof Blob && t instanceof Blob || t instanceof Ct }, promptDownload: It, resizeElement: Lt, setAttributes: Nt, SVG_NS: kt, XML_NS: Ot, XLINK: Ft, createSvgElement: Rt, createTextNode: Pt, getImage: Dt, fetch: Bt, isHTMLElement: Ut, applyCursorStyle: Vt, fetchBinary: jt, fetchBinaryAsBase64: Gt, escapeDOMAttribute: Ht, BUTTON_MAPPING: qt, baseURI: Wt, fadeElement: Xt, getCurrentTime: Kt, getDate: Qt, getTime: Jt, formatWorkerMessage: vo, createWorker: mo, insertSortAsc: X, insertSortDesc: At, isArray: I, toArray: L, flattenArray: N, concatenateArrays: function () { for (var t = arguments, e = [], i = 0; i < arguments.length; i++)e[i] = t[i]; if (0 === e.length) return []; for (var n = e[0].constructor, r = 0, o = 0, s = e; o < s.length; o++) { r += (h = s[o]).length } for (var a = new n(r), u = 0, l = 0, d = e; l < d.length; l++) { for (var h = d[l], c = 0; c < h.length; c++)a[u + c] = h[c]; u += h.length } return a }, removeFromArray: k, binaryIndexOf: O, parseColorRgba: hn, toHexa: cn, componentsToRGBA: fn, parseColorHex: gn, createDummyXmlDocument: ko, serializeXMLDocument: Oo, createXmlDocument: Fo, PrioritySet: Ro, nextPowerOfTwo: qe, computeSum: We, clamp: Xe, mix: Ye, lerp: Ze, computeMax: Ke, computeMin: Qe, getBaseLog: Je, ElementSet: Do, displayPixelsOnScreen: function (t, e, i, n) { void 0 === n && (n = 0), void 0 === e && (e = i = Math.sqrt(t.length / 4)), void 0 === i && (i = e); var r = document.createElement("canvas"), o = r.getContext("2d"), s = o.createImageData(e, i); r.style.imageRendering = "pixelated", r.style.border = "1px solid black", r.style.margin = "2px", r.style.position = "absolute", r.style.top = r.style.left = "0px", r.width = e, r.height = i, s.data.set(t), o.putImageData(s, 0, 0); var a = document.getElementById("graph-container"); a && (a.style.position = "static"), setTimeout(function () { return document.body.appendChild(r) }, n) } }), qo = { byte: 1, ubyte: 1, short: 2, ushort: 2, float: 4 }, Wo = { byte: "BYTE", ubyte: "UNSIGNED_BYTE", short: "SHORT", ushort: "UNSIGNED_SHORT", float: "FLOAT" }, Xo = (Yo.prototype._finishInit = function () { var e = this, i = this._gl, t = this._ext, n = this._programWrapper.getError(); if (n) throw new Error('WebGL compilation at step "' + n.step + ":\n" + n.message + '"'); var r = this._programWrapper.getProgram(); this._program = r, i.useProgram(r), this._metaData.attributes.forEach(function (t) { t.location = i.getAttribLocation(e._program, t.name), t.byteSize = t.size * qo[t.type], t.glType = Wo[t.type] }), this._specialAttributes = this._createSpecialAttributesFunctions(); for (var o = [], s = [], a = 0, u = this._metaData.attributes; a < u.length; a++) { var l = u[a]; -1 !== l.location && (l.name.startsWith("a_text") ? s.push(l) : o.push(l)) } this._baseAttributes = Ko(o, i, t), this._textAttributes = Ko(s, i, t), this._setupUniforms = function (t, e, i) { for (var n = {}, r = [], o = 0; o < t.length; ++o) { var s = t[o], a = s.id, u = s.name, l = s.type, d = e.getUniformLocation(i, u), h = Zo[l](a); n[a] = d, r.push(h) } var c = new Function("gl", "l", "u", r.join("\n")); return function (t) { return c(e, n, t) } }(this._metaData.uniforms, i, r) }, Yo.prototype._createSpecialAttributesFunctions = function () { return Ko([{ location: this._gl.getAttribLocation(this._program, this._metaData.vertexInfoAttribute), size: 3, glType: "BYTE", byteSize: 3, type: "byte", name: "special" }], this._gl, this._ext) }, Yo.prototype.startPass = function (t) { this._program || this._finishInit(), this._gl.useProgram(this._program), this._resetStencil(), this._setupUniforms(t), this._specialAttributes.enable(), this._specialAttributes.setup(this._specialGlBuffers.vertexInfo, null, 0) }, Yo.prototype._setupAttributes = function (t, e) { var i = e.glBuffer, n = e.dataBuffer, r = e.divisor; t.enabled && !i ? t.disable() : !t.enabled && i && t.enable(), i && t.setup(i, n, r) }, Yo.prototype.setupBaseAttributes = function (t) { this._setupAttributes(this._baseAttributes, t) }, Yo.prototype.setupTextAttributes = function (t) { this._setupAttributes(this._textAttributes, t) }, Yo.prototype._resetStencil = function () { var t = this._gl; this._stencilUsage = 1, t.disable(t.STENCIL_TEST) }, Yo.prototype.setupStencil = function (t) { if (t !== this._stencilUsage) { var e = this._gl; 1 !== t ? (e.enable(e.STENCIL_TEST), 2 === t ? (e.stencilOp(e.KEEP, e.KEEP, e.REPLACE), e.stencilFunc(e.ALWAYS, 1, 1)) : 3 === t && (e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.stencilFunc(e.EQUAL, 0, 1))) : e.disable(e.STENCIL_TEST), this._stencilUsage = t } }, Yo.prototype.endPass = function () { this._specialAttributes.disable(), this._baseAttributes.disable(), this._textAttributes.disable() }, Yo); function Yo(t) { var e = t.gl, i = t.ext, n = t.specialGlBuffers, r = t.metaData, o = t.programWrapper; this._setupUniforms = null, this._specialAttributes = null, this._baseAttributes = null, this._textAttributes = null, this._stencilUsage = 1, this._gl = e, this._ext = i, this._specialGlBuffers = n, this._metaData = j(r), this._programWrapper = o } var Zo = { int: function (t) { return "gl.uniform1i(l." + t + ", u." + t + ");" }, sampler2D: function (t) { return "gl.uniform1i(l." + t + ", u." + t + ");" }, float: function (t) { return "gl.uniform1f(l." + t + ", u." + t + ");" }, vec2: function (t) { return "gl.uniform2f(l." + t + ", u." + t + "[0], u." + t + "[1]);" }, vec3: function (t) { return "gl.uniform3f(l." + t + ", u." + t + "[0], u." + t + "[1], u." + t + "[2]);" }, vec4: function (t) { return "gl.uniform4f(l." + t + ", u." + t + "[0], u." + t + "[1], u." + t + "[2], u." + t + "[3]);" } }; function Ko(t, e, i) { var n, r, o, s, a, u, l, d, h, c, f, g, p, _ = (n = e, r = t.map(function (t) { return "gl.enableVertexAttribArray(" + t.location + ");" }).join("\n"), o = new Function("gl", r), function () { return o(n) }), v = (s = e, a = t.map(function (t) { return "gl.disableVertexAttribArray(" + t.location + ");" }).join("\n"), u = new Function("gl", a), function () { return u(s) }); return { enable: function () { _(), this.enabled = !0 }, disable: function () { v(), this.enabled = !1 }, setup: (d = e, h = i, c = (l = t).reduce(function (t, e) { return t + e.byteSize }, 0), f = 0, g = ["gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);", "if (dataBuffer) gl.bufferData(gl.ARRAY_BUFFER, dataBuffer, gl.STATIC_DRAW);"].concat(l.map(function (t) { var e = t.location, i = t.size, n = t.glType, r = t.byteSize, o = "gl.vertexAttribPointer(\n        " + e + ", " + i + ", gl." + n + ",\n        false, " + c + ", " + f + "\n      );"; return f += r, o }), l.map(function (t) { return "ext.vertexAttribDivisorANGLE(" + t.location + ", divisor);" })).join("\n"), p = new Function("gl", "ext", "glBuffer", "dataBuffer", "divisor", g), function (t, e, i) { return p(d, h, t, e, i) }), enabled: !1 } } var Qo = (Jo.prototype.setDataBuffer = function (t) { this._dataBuffer !== t && (this._program = t.isAnimated() ? this._animationProgram : this._staticProgram, this._dataBuffer = t, this._dataBufferChanged = !0, t.hasSideData() && !this._sideGlBuffer ? this._sideGlBuffer = this._gl.createBuffer() : !t.hasSideData() && this._sideGlBuffer && (this._gl.deleteBuffer(this._sideGlBuffer), this._sideGlBuffer = null)) }, Jo.prototype.markAsUnused = function () { return this._used = !1, this }, Jo.prototype.getProgram = function () { return this._program }, Jo.prototype.markAsUsed = function () { return this._used = !0, this }, Jo.prototype.isUsed = function () { return this._used }, Jo.prototype.draw = function () { var t = this._gl, e = this._dataBuffer.getElementType(), i = 2 === e, n = i ? this._dataBuffer.getNbSideElementsPerMainElement() : 1, r = 3 === e ? 41 : 1, o = this._dataBuffer.getSize(), s = this._dataBuffer.getStencilUsage(), a = this._dataBuffer.getVersion(), u = this._version !== a || this._dataBufferChanged; this._program.setupBaseAttributes({ glBuffer: this._glBuffer, dataBuffer: u ? this._dataBuffer.getByteArray() : null, divisor: n }), this._program.setupTextAttributes({ glBuffer: this._sideGlBuffer, dataBuffer: u && i ? this._dataBuffer.getSideByteArray() : null, divisor: 1 }), this._program.setupStencil(s), u && (this._version = a, this._dataBufferChanged = !1), this._ext.drawArraysInstancedANGLE(t.TRIANGLES, 0, 6 * r, o * n) }, Jo.prototype.destroy = function () { this._gl.deleteBuffer(this._glBuffer), this._sideGlBuffer && this._gl.deleteBuffer(this._sideGlBuffer) }, Jo); function Jo(t) { var e = t.gl, i = t.ext, n = t.staticProgram, r = t.animationProgram; this._program = null, this._dataBuffer = null, this._version = 0, this._used = !1, this._dataBufferChanged = !1, this._glBuffer = null, this._sideGlBuffer = null, this._gl = e, this._ext = i, this._staticProgram = n, this._animationProgram = r, this._glBuffer = this._gl.createBuffer() } function $o(t, e) { if (e < 2) return t; for (var i = t.split("\n"), n = [], r = 0; r < i.length; ++r) { var o = i[r]; if (o.length < e) n.push(o); else for (var s = ts(i[r], e), a = 0; a < s.length; ++a)n.push(s[a]) } return n.join("\n") } function ts(t, e) { for (var i = t.split(" "), n = [], r = 0, o = -1, s = [], a = !0, u = 0; u < i.length; ++u)if (a) { if (i[u].length > e) { for (var l = es(i[u], e), d = 0; d < l.length; ++d)n.push([l[d]]), ++o; r = l[l.length - 1].length } else n.push([i[u]]), ++o, r = i[u].length + 1; a = !1 } else r + i[u].length <= e ? (n[o].push(i[u]), r += i[u].length + 1) : (a = !0, --u); for (u = 0; u < n.length; ++u)s.push(n[u].join(" ")); return s } function es(t, e) { for (var i = [], n = 0; n < t.length; n += e - 1)i.push(t.substr(n, e - 1) + "-"); var r = i[i.length - 1].length; return i[i.length - 1] = i[i.length - 1].substr(0, r - 1) + " ", i } function is(t, e) { if (null === t) return null; for (var i = (t = t.toString()).split("\n"), n = [], r = 0, o = 0; o < i.length; o++) { var s = i[o]; if (!e || e <= 1 || s.length < e) n.push(s), r = Math.max(r, s.length); else for (var a = ts(i[o], e), u = 0; u < a.length; u++)s = a[u], n.push(s), r = Math.max(r, s.length) } return { data: n, maxLength: r, lines: n.length } } function ns() { var t = M("@mapbox/mapbox-gl-rtl-text") || M("mapbox-gl-rtl-text"), e = t ? t.processBidirectionalText : ct ? window.processBidirectionalText : null, i = t ? t.applyArabicShaping : ct ? window.applyArabicShaping : null; return { processBidirectionalText: e ? function (t) { return e(t, []).join("") } : function (t) { return t }, applyArabicShaping: i ? function (t) { return null === t ? null : "number" == typeof t ? t.toString() : i(t) } : function (t) { return null === t ? null : t.toString() } } } var rs = P(), os = "\n".charCodeAt(0), ss = (as.prototype._init_ = function () { this._mustClear = !1, this._byFont = {}, this._widthAtlases = { normal: {}, bold: {}, italic: {} } }, as.prototype.reset = function () { this._init_() }, as.prototype.clear = function () { this._mustClear = !0 }, as.prototype._measureChar = function (t, e, i) { return or(this._ctx, e, 12, i), this._ctx.measureText(t).width / 12 }, as.prototype._getAtlas = function (t, e, i) { var n = "sdf" === i ? 0 : i, r = this._byFont[t] || (this._byFont[t] = {}), o = r[e] || (r[e] = new Array(50)); return o[n] || (o[n] = new Array(256)) }, as.prototype._getMeasurementAtlas = function (t, e) { var i = this._widthAtlases[e]; return i[t] || (i[t] = new Array(256)) }, as.prototype.measureText = function (t, e, i, n) { if (void 0 === n && (n = 1), !e) return this._textDimensions.width = 0, this._textDimensions.height = 0, this._textDimensions; for (var r = this._getMeasurementAtlas(e, i), o = 0, s = 0, a = 1, u = 0; u < t.length; ++u) { var l = t.charCodeAt(u); if (l === os) o < s && (o = s), s = 0, a += 1; else { var d = r[l]; void 0 === d && (d = this._measureChar(t[u], e, i), r[l] = d), s += d } } return o < s && (o = s), this._textDimensions.width = o * n, this._textDimensions.height = a * n, this._textDimensions }, as.prototype._getCharInfo = function (t, e, i, n, r, o) { var s = t[e]; if (!s) { var a = String.fromCharCode(e), u = "sdf" === r ? 1 : 3; s = { ratio: this._measureChar(a, i, n), patternId: new Array(u) }; for (var l = 0; l < u; ++l) { var d = l / u; s.patternId[l] = this._patternManager.getIdFromDefinition({ id: 0, type: 3, attributes: { text: a, font: i, style: n, size: r, align: o, offset: d } }) } t[e] = s } return s }, as.prototype.storeTextInDataView = function (t, e, i, n) { var r = e; if (n && n.type === An) { var o = n.attributes, s = o.text, a = o.font, u = o.style, l = o.size, d = o.align, h = "center" === d, c = this._getAtlas(a, u, l), f = 0, g = 1, p = 0, _ = 0, v = this._lineWidthList; s = this._processBidirectionalText(s); for (var m = 0; m < s.length; ++m)(I = s.charCodeAt(m)) === os ? (f < p && (f = p), v[_] = p, _ += 1, p = 0, g += 1) : p += (A = this._getCharInfo(c, I, a, u, l, d)).ratio; if (f < (v[_] = p) && (f = p), "sdf" === l) { var y = 0, b = -(h ? v[y] : f) / 2, x = (1 - g) / 2, E = 0; for (m = 0; m < s.length; ++m) { var A = c[I = s.charCodeAt(m)]; if (I === os) y += 1, b = -(h ? v[y] : f) / 2, x += 1, E = 0; else { var S = A.ratio, w = A.patternId[0]; b += (S + E) / 2, E = S; var T = ls(20.44 * b), C = us(2 * x); t.setUint16(r, w, rs), t.setUint16(r + 2, (T << 6) + C, rs), r += 4 } } } else { var M = 0; for (b = Math.ceil(-(h ? v[M] : f) * l / 2), x = (1 - g) / 2, m = 0; m < s.length; ++m) { var I; if (A = c[I = s.charCodeAt(m)], I === os) M += 1, b = Math.ceil(-(h ? v[M] : f) * l / 2), x += 1; else { var L = A.ratio * l, N = Math.floor(b), k = b - N, O = Math.round(3 * k); 3 === O && (O = 0, N += 1), N += Math.ceil(L / 2), b += L, w = A.patternId[O], T = ls(N), C = us(2 * x), t.setUint16(r, w, rs), t.setUint16(r + 2, (T << 6) + C, rs), r += 4 } } } } this._fillWithZeros(t, r, i) }, as.prototype.extractTextFromDataView = function (t, e, i) { for (var n = t, r = rs, o = n.getUint16(e, r), s = this._textPattern, a = this._patternManager.getDefinitionFromId(o).attributes, u = a.font, l = a.style, d = a.size, h = a.align, c = this._getAtlas(u, l, d), f = [], g = 0, p = 0, _ = 0, v = null, m = e; m < i; m += 4) { var y = n.getUint16(m, r); if (!y) break; var b = n.getUint16(m + 2, r) % 64 - 32, x = this._patternManager.getDefinitionFromId(y); if (!x) break; var E = x.attributes.text.charCodeAt(0), A = c[E]; null === v ? v = b : v < b && (p < g && (p = g), g = 0, _ += 1, f.push(os), v = b), f.push(E), A && (g += A.ratio) } p < g && (p = g); var S = String.fromCharCode.apply(null, f); return s.attributes.style = l, s.attributes.font = u, s.attributes.size = d, s.attributes.align = h, s.attributes.text = this._processBidirectionalText(S), s.dimensions.width = p, s.dimensions.height = _, s }, as.prototype._fillWithZeros = function (t, e, i) { for (var n = e; n < i; n += 4)t.setUint16(n, 0) }, as.prototype._clear = function () { this._byFont = {}, this._widthAtlases = { normal: {}, bold: {}, italic: {} } }, as.prototype.update = function () { this._mustClear && (this._clear(), this._mustClear = !1) }, as.prototype.getVersion = function () { return 0 }, as); function as(t) { this._patternManager = t, this._canvas = nr(), this._ctx = this._canvas.getContext("2d"), this._processBidirectionalText = ns().processBidirectionalText, this._textPattern = { id: 0, type: An, attributes: { text: "", font: "", size: 0, style: "normal", align: "center" }, dimensions: { width: 0, height: 0 } }, this._textDimensions = { width: 0, height: 0 }, this._lineWidthList = new Array(64), this._init_() } function us(value) { return Xe(value + 32, 0, 63) } function ls(value) { return Xe(value + 512, 0, 1023) } var ds, hs = sr(), cs = { stencil: !0, antialias: !1, alpha: !0, premultipliedAlpha: !0, failIfMajorPerformanceCaveat: !("undefined" != typeof window && window.FORCE_WEBGL) }, fs = { NO_WEBGL: 'Unable to create a WebGL context: `canvas.getContext("webgl")` and `canvas.getContext("experimental-webgl")` returned `null`', NO_ANGLE_INSTANCED_ARRAYS: 'WebGL extension "ANGLE_instanced_arrays" unavailable: `gl.getExtension("ANGLE_instanced_arrays")` returned `null`' }, gs = (b(ps, ds = Error), ps); function ps() { return null !== ds && ds.apply(this, arguments) || this } function _s(value, t) { if (!value) { var e = new gs(fs[t]); throw e.code = t, e } } var vs, ms = (b(ys, vs = cr), ys.isAvailable = function () { return hs }, ys.createInitData = function () { var t = nr(), e = ar(t, cs), i = e && "function" == typeof e.getExtension ? e.getExtension("ANGLE_instanced_arrays") : null, n = { BYTES_TO_OFFSET_ANGLE: 2 * Math.PI / 8, BYTES_TO_COLOR: 1 / 15, SDF_FONT_SIZE: 24, CURVATURE_RATIO: Vn, PATTERN_MARGIN: Bn, TEXT_WIDTH_MULTIPLIER: 1.2, TEXT_HEIGHT_MULTIPLIER: 1.5, SELF_LOOP_CURVATURE_MULTIPLIER: jn, EDGE_ARROW_SIZE_RATIO: 3, NB_PIECES_PER_CURVE: 41, PIECE_NODE_COMPONENT: Sn, PIECE_EDGE_BODY: wn, PIECE_EDGE_HEAD: Tn, PIECE_EDGE_TAIL: Cn, PIECE_EDGE_TEXT: Mn, MAX_TEXT_SIZE: 25, BYTES_TO_TEXT_OFFSET: 1 / 20.44, FILTER_NEAREST: 0, FILTER_LINEAR: 1, FILTER_LINEAR_SDF: 2, FILTER_MIPMAP: 3, SHAPE_TEXTURE_SIZE: Dn, SIMPLE_SHAPE_SAMPLING_SIZE: 32, COMPLEX_SHAPE_SAMPLING_SIZE: Rn, SHAPE_SAMPLING_BUFFER_RATIO: 1 / 16, MAX_NB_SHAPES: 15..toString(), FIRST_COMPLEX_SHAPE_ID: 8, SELF_LOOP_TO_CIRCLE_APPROX: .9721 }, r = new mr(e, { vertex: _r, fragment: vr, constants: n, macros: { ANIMATED: 0 } }), o = new mr(e, { vertex: _r, fragment: vr, constants: n, macros: { ANIMATED: 1 } }); return e && i && (r.compile(), e.flush()), { canvas: t, gl: e, ext: i, staticProgramWrapper: r, animationProgramWrapper: o } }, ys.getName = function () { return "WebGL" }, ys.prototype._afterFirstFrame = function () { this._animationProgramWrapper.getState() === gr.INIT && this._animationProgramWrapper.compile() }, ys.prototype.ensureAnimationsReady = function () { var t = this._animationProgramWrapper.getState(); t !== gr.DONE && (t === gr.INIT && this._animationProgramWrapper.compile(), this._animationProgramWrapper.getError()) }, ys.prototype.getDomElement = function () { return this._glCanvas }, ys.prototype._initGl = function () { var t = this._gl; t.clearColor(0, 0, 0, 0), t.enable(t.BLEND), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA) }, ys.prototype._computeShaderInfo = function () { var t, e; this._shaderMetadata = (t = vr, xs(e = { vertexInfoAttribute: "a_vertexInfo", attributes: [], uniforms: [] }, _r), xs(e, t), e) }, ys.prototype._initGlPrograms = function () { this._staticProgram = new Xo({ gl: this._gl, ext: this._ext, specialGlBuffers: this._specialGlBuffers, metaData: this._shaderMetadata, programWrapper: this._staticProgramWrapper }), this._animationProgram = new Xo({ gl: this._gl, ext: this._ext, specialGlBuffers: this._specialGlBuffers, metaData: this._shaderMetadata, programWrapper: this._animationProgramWrapper }) }, ys.prototype._initSpecialGlBuffers = function () { for (var t = this._gl, e = t.createBuffer(), i = new Int8Array(738), n = 0; n < 41; ++n)for (var r = [-1, -1, n, 1, -1, n, 1, 1, n, -1, -1, n, -1, 1, n, 1, 1, n], o = n * r.length, s = 0; s < r.length; s++)i[s + o] = r[s]; t.bindBuffer(t.ARRAY_BUFFER, e), t.bufferData(t.ARRAY_BUFFER, i, t.STATIC_DRAW), this._specialGlBuffers = { vertexInfo: e } }, ys.prototype._computeUniforms = function () { return { viewWidth: this._width, viewHeight: this._height, viewX: this._viewX, viewY: this._viewY, viewZoom: this._viewZoom, viewAngle: this._viewAngle, currentTime: this._currentTime, pixelRatio: this._pixelRatio, backgroundColor: this._backgroundRgba, patternInfoTexture: this._patternTexture.getInfoTextureUnit(), patternNearestTexture: this._patternTexture.getNearestTextureUnit(), patternLinearTexture: this._patternTexture.getLinearTextureUnit(), patternLinearSdfTexture: this._patternTexture.getLinearSdfTextureUnit(), patternMipmapTexture: this._patternTexture.getMipmapTextureUnit(), shapeTexture: this._shapeTexture.getTextureUnit(), BYTES_TO_COORD: this._scales.bytesToActualCoord, BYTES_TO_SCALED_SIZE: this._scales.bytesToActualScaledSize, BYTES_TO_MIN_VISIBLE_SIZE: this._scales.bytesToActualMinVisibleSize, BYTES_TO_SYMBOLIC_SIZE: this._scales.bytesToActualSymbolicSize, BYTES_TO_DASH_LENGTH: this._scales.bytesToActualDashLength, BYTES_TO_GAP_LENGTH: this._scales.bytesToActualGapLength, BYTES_TO_PATTERN_SCALE: this._scales.bytesToActualPatternScale, PATTERN_INFO_TEXTURE_SIZE: this._patternTexture.getInfoTextureSize(), PATTERN_NEAREST_TEXTURE_SIZE: this._patternTexture.getNearestTextureSize(), PATTERN_LINEAR_TEXTURE_SIZE: this._patternTexture.getLinearTextureSize(), PATTERN_LINEAR_SDF_TEXTURE_SIZE: this._patternTexture.getLinearSdfTextureSize(), PATTERN_MIPMAP_TEXTURE_SIZE: this._patternTexture.getMipmapTextureSize(), PATTERN_POSITION_GRANULARITY: this._patternTexture.getGranularity(), SHAPE_TEXTURE_SIZE: this._shapeTexture.getTextureSize(), SHAPE_SAMPLING_SIZE: this._shapeTexture.getSamplingSize(), SHAPE_SAMPLING_BUFFER_RATIO: this._shapeTexture.getBufferRatio(), NB_SHAPES_BY_SIDE: this._shapeTexture.getTextureSize() / this._shapeTexture.getSamplingSize(), SHAPE_DIMENSIONS: this._shapeTexture.getSamplingSize() / this._shapeTexture.getTextureSize(), SHAPE_ACTUAL_RATIO: 1 - this._shapeTexture.getBufferRatio() } }, ys.prototype._render = function (t) { var e = t.shapesChanged, i = t.patternsChanged, n = t.dimensionsChanged, r = t.backgroundColorChanged, o = this._gl; if (e && (this._shapeTexture.refresh(this._shapeManager), this._patternTexture.bindMetDataTexture()), i && this._patternTexture.refresh(this._patternManager), n && (this._mustResize = !0), r) { var s = this._renderBackground ? this._backgroundRgba : [0, 0, 0, 0], a = s[0], u = s[1], l = s[2], d = s[3]; o.clearColor(a * d, u * d, l * d, d) } var h = this._computeUniforms(), c = this._startFrame(); this._mustResize && c.length && (Lt(this._glCanvas, this._width, this._height, this._pixelRatio), o.viewport(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio), this._mustResize = !1), o.clear(o.COLOR_BUFFER_BIT | o.STENCIL_BUFFER_BIT); for (var f = 0; f < c.length; ++f)this._displayBuffer(c[f], h); this._endFrame() }, ys.prototype._displayBuffer = function (t, e) { var i = t.getProgram(); i !== this._currentProgram && (this._currentProgram && this._currentProgram.endPass(), this._currentProgram = i, this._currentProgram.startPass(e)), t.markAsUsed(), t.draw() }, ys.prototype._startFrame = function () { for (var t = this._bufferList.getBuffersByAscendingDepth(), e = [], i = 0; i < this._glBuffers.length; ++i)(r = this._glBuffers[i]) && r.markAsUnused(); for (i = 0; i < t.length; ++i) { var n = t[i]; (r = this._getAssociatedGlBuffer(n)).markAsUsed(), !n.isEmpty() && this._isBufferDisplayable(n) && e.push(r) } for (i = 0; i < this._glBuffers.length; ++i) { var r; (r = this._glBuffers[i]) && !r.isUsed() && (r.destroy(), this._glBuffers[i] = void 0) } return e }, ys.prototype._endFrame = function () { this._currentProgram && (this._currentProgram.endPass(), this._currentProgram = null) }, ys.prototype._getAssociatedGlBuffer = function (t) { var e = t.getId(), i = this._glBuffers[e]; if (!i) { for (; this._glBuffers.length <= e;)this._glBuffers.push(void 0); i = new Qo({ gl: this._gl, ext: this._ext, staticProgram: this._staticProgram, animationProgram: this._animationProgram }), this._glBuffers[e] = i } return i.setDataBuffer(t), i }, ys.prototype.destroy = function () { var t = this._gl.getExtension("WEBGL_lose_context"); t && t.loseContext() }, ys.prototype.getImageData = function () { var t = this._glCanvas.width, e = this._glCanvas.height; return (this._2dcanvas.width < t || this._2dcanvas.height < e) && (this._2dcanvas.width = t, this._2dcanvas.height = e), this._ctx.drawImage(this._glCanvas, 0, 0), this._ctx.getImageData(0, 0, t, e) }, ys.prototype._getImageDataFlippedYAxis = function () { var t = this._gl, e = this._glCanvas.width, i = this._glCanvas.height, n = this._ctx.createImageData(e, i), r = new Uint8Array(n.data.buffer); return t.readPixels(0, 0, e, i, t.RGBA, t.UNSIGNED_BYTE, r), n }, ys); function ys(t) { var e = vs.call(this, t) || this; e._2dcanvas = nr(), e._ctx = e._2dcanvas.getContext("2d"), e._glBuffers = [], e._staticProgram = null, e._animationProgram = null, e._currentProgram = null, e._specialGlBuffers = null, e._shaderMetadata = null, e._mustResize = !1; var i = t.initData || ys.createInitData(), n = i.canvas, r = i.gl, o = i.ext, s = i.staticProgramWrapper, a = i.animationProgramWrapper; return _s(r, "NO_WEBGL"), _s(o, "NO_ANGLE_INSTANCED_ARRAYS"), e._glCanvas = n, e._gl = r, e._ext = o, e._staticProgramWrapper = s, e._animationProgramWrapper = a, e._shapeTexture = new Br(e._gl, 0), e._patternTexture = new Yr(e._gl, 1), e._initCanvas(e._glCanvas), e._computeShaderInfo(), e._initSpecialGlBuffers(), e._initGlPrograms(), e._initGl(), e } var bs = { float: 1, vec2: 2, vec3: 3, vec4: 4 }; function xs(t, e) { for (var i = /(?:attribute\s+\/\*\s*(byte|ubyte|short|ushort|float)\s*\*\/\s*(float|vec2|vec3|vec4)\s+(\w+)\s*;)|(?:#if\s*(\w+))|(?:#endif)/g, n = /uniform\s+(float|vec2|vec3|vec4|sampler2D|int)\s+(\w+)\s*;/g, r = [], o = i.exec(e); o;) { var s = o[0]; "#endif" === s ? r.pop() : s.startsWith("#if") ? r.push(o[4]) : t.attributes.push({ name: o[3], size: bs[o[2]], type: o[1], tags: r.slice(), location: null, byteSize: null, glType: null }), o = i.exec(e) } for (o = n.exec(e); o;) { if (!t.uniforms.some(function (t) { return t.id === o[1] })) { var a = o[1], u = o[2], l = u.replace("u_", ""); t.uniforms.push({ id: l, name: u, type: a }) } o = n.exec(e) } } var Es = 0, As = 1, Ss = 2, ws = 3, Ts = 0, Cs = 1, Ms = 2, Is = 3, Ls = 4, Ns = 5, ks = 6, Os = Math.PI, Fs = 2 * Math.PI, Rs = Os * (5 / 4), Ps = Os * (7 / 4), Ds = .75 * Os, zs = .25 * Os, Bs = 1.1, Us = .07, Vs = 1, js = 1, Gs = .17, Hs = 1, qs = -Os / 2, Ws = Os / 2, Xs = 2 / 3, Ys = { plain: { dash: 0, gap: 0 }, dashed: { dash: 3, gap: 1 }, dotted: { dash: 1, gap: 3 } }, Zs = { right: 0, top: -Math.PI / 2, left: Math.PI, bottom: Math.PI / 2, center: 0 }, Ks = { right: Math.PI, top: -Math.PI / 2, left: 0, bottom: Math.PI / 2, center: 0 }; function Qs(t, e, i, n, r) { var o = 1 - r; return o * o * o * t + 3 * r * o * o * e + 3 * r * r * o * i + r * r * r * n } function Js(t, e, i, n) { var r = 1 - n; return r * r * t + 2 * r * n * e + n * n * i } function $s(t, e, i, n, r, o) { var s = o || { x: 0, y: 0 }, a = (t + i) / 2, u = (e + n) / 2, l = t - i, d = e - n, distance = Math.sqrt(l * l + d * d); if (0 === distance) return s.x = a, s.y = u, s; var h = d / distance, c = -l / distance, f = -distance * r / Vn; return s.x = a + h * f, s.y = u + c * f, s } function ta(t, e, i, n, r, o) { var s = o || { x1: 0, y1: 0, x2: 0, y2: 0 }, a = (n + n / jn * i) * jn, u = -r + Os, l = Os / 2 - r; return s.x1 = t + Math.cos(u) * a, s.y1 = e + Math.sin(u) * a, s.x2 = t + Math.cos(l) * a, s.y2 = e + Math.sin(l) * a, s } var ea, ia = (b(na, ea = cr), na.prototype._resetCachePoints = function () { this._nextCachePoint = 0 }, na.prototype._point = function (t, e) { var i = this._cachePoints[this._nextCachePoint++]; return i || (i = { x: 0, y: 0 }, this._cachePoints.push(i)), i.x = t, i.y = e, i }, na.prototype.setViewportClipping = function (t) { this._clipViewport = t }, na.prototype._formatAngle = function (t) { return t < -Math.PI ? t + 2 * Math.PI : t > Math.PI ? t - 2 * Math.PI : t }, na.prototype._computeAnimationRatio = function (t) { var e = t.beginTime, i = t.duration, n = t.easing, r = (this._currentTime - e) / i, o = r * r, s = o * r, a = this._easingManager.getCoefficients(n), u = r < .5 ? 0 : 4; return Xe(a[u] + a[1 + u] * r + a[2 + u] * o + a[3 + u] * s, 0, 1) }, na.prototype._mixColor = function (t, e, i, n) { if (t === e) return t; var r = this._colorManager.parseColor(t), o = r[0], s = r[1], a = r[2], u = r[3], l = this._colorManager.parseColor(e), d = l[0], h = l[1], c = l[2], f = l[3]; return "rgba(" + Math.round(255 * Ze(o, d, i)) + "," + Math.round(255 * Ze(s, h, i)) + "," + Math.round(255 * Ze(a, c, i)) + "," + Ze(u, f, n) + ")" }, na.prototype._displayBuffer = function (t) { for (var e = t.getSize(), i = t.isAnimated(), n = 0; n < e; ++n) { var r = this.extractElement(t, n); r.valid && this._displayElement(r, i) } }, na.prototype._mixAttributes = function (t, e, i) { var n = this._computeAnimationRatio(i); return t.dashLength = Ze(e.dashLength, t.dashLength, n), t.gapLength = Ze(e.gapLength, t.gapLength, n), t.offsetAngle = Ze(e.offsetAngle, t.offsetAngle, n), t.opacity = Ze(e.opacity, t.opacity, n), t.globalMinVisibleSize = Ze(e.globalMinVisibleSize, t.globalMinVisibleSize, n), t.strokeMinVisibleSize = Ze(e.strokeMinVisibleSize, t.strokeMinVisibleSize, n), t.patternMinVisibleSize = Ze(e.patternMinVisibleSize, t.patternMinVisibleSize, n), t.symbolicSize = Ze(e.symbolicSize, t.symbolicSize, n), t.curvature = Ze(e.curvature, t.curvature, n), t.fillColor = this._mixColor(e.fillColor, t.fillColor, n, n), t.strokeColor = this._mixColor(e.strokeColor, t.strokeColor, n, n), t.patternColor = this._mixColor(e.patternColor, t.patternColor, n, n), t.x1 = Ze(e.x1, t.x1, n), t.y1 = Ze(e.y1, t.y1, n), t.x2 = Ze(e.x2, t.x2, n), t.y2 = Ze(e.y2, t.y2, n), t.rectWidthOrSourceRadiusScaled = Ze(e.rectWidthOrSourceRadiusScaled, t.rectWidthOrSourceRadiusScaled, n), t.rectWidthOrSourceRadiusFixed = Ze(e.rectWidthOrSourceRadiusFixed, t.rectWidthOrSourceRadiusFixed, n), t.rectHeightOrTargetRadiusScaled = Ze(e.rectHeightOrTargetRadiusScaled, t.rectHeightOrTargetRadiusScaled, n), t.rectHeightOrTargetRadiusFixed = Ze(e.rectHeightOrTargetRadiusFixed, t.rectHeightOrTargetRadiusFixed, n), t.thicknessOrFontSizeScaled = Ze(e.thicknessOrFontSizeScaled, t.thicknessOrFontSizeScaled, n), t.thicknessOrFontSizeFixed = Ze(e.thicknessOrFontSizeFixed, t.thicknessOrFontSizeFixed, n), t.strokeWidthScaled = Ze(e.strokeWidthScaled, t.strokeWidthScaled, n), t.strokeWidthFixed = Ze(e.strokeWidthFixed, t.strokeWidthFixed, n), t.offsetScaled = Ze(e.offsetScaled, t.offsetScaled, n), t.offsetFixed = Ze(e.offsetFixed, t.offsetFixed, n), t }, na.prototype._computeRenderInfo = function (t) { var e = this._viewZoom, i = this._point(t.x1, t.y1), n = this._point(t.x2, t.y2); return { shape: this._shapeManager.getDefinitionFromName(t.shape), pieceId: t.pieceId, dashLength: t.dashLength, gapLength: t.gapLength, hasHead: t.hasHead, hasTail: t.hasTail, isBodyTriangle: t.isBodyTriangle, isSelfLoop: t.isSelfLoop, patternScale: t.patternScale, offsetAngle: this._formatAngle(t.offsetAngle), isText: t.isText, adjustTextAngle: t.adjustTextAngle, unusedFlag1: t.unusedFlag1, unusedFlag2: t.unusedFlag2, unusedFlag3: t.unusedFlag3, opacity: t.opacity, globalMinVisibleSize: t.globalMinVisibleSize, strokeMinVisibleSize: t.strokeMinVisibleSize, patternMinVisibleSize: t.patternMinVisibleSize, symbolicSize: 0 === t.symbolicSize ? 1 / 0 : t.symbolicSize * e, curvature: t.curvature, pattern: t.pattern, fillColor: t.fillColor, strokeColor: t.strokeColor, patternColor: t.patternColor, pos1OnGraph: i, pos2OnGraph: n, pos1: this._graphToScreenCoordinates(i), pos2: this._graphToScreenCoordinates(n), rectWidthOrSourceRadius: t.rectWidthOrSourceRadiusScaled * e + t.rectWidthOrSourceRadiusFixed, rectHeightOrTargetRadius: t.rectHeightOrTargetRadiusScaled * e + t.rectHeightOrTargetRadiusFixed, thicknessOrFontSize: t.thicknessOrFontSizeScaled * e + t.thicknessOrFontSizeFixed, strokeWidth: t.strokeWidthScaled * e + t.strokeWidthFixed, offset: t.offsetScaled * e + t.offsetFixed } }, na.prototype._applyBackgroundBlending = function (t) { 1 !== t.opacity && (t.fillColor = this._blendColor(t.fillColor, t.opacity), t.strokeColor = this._blendColor(t.strokeColor, t.opacity), t.textColor = this._blendColor(t.textColor, t.opacity)) }, na.prototype._pointArray = function (t) { var e = this._pointCopies[t]; if (!e) { e = new Array(t), this._pointCopies[t] = e; for (var i = 0; i < t; ++i)e[i] = { x: 0, y: 0, r: 0 } } return e }, na.prototype._scalePoints = function (t, e, i, n) { for (var r = t.shape.points.length, o = this._pointArray(r), s = 0; s < r; ++s) { var a = t.shape.points[s], u = o[s]; u.x = e.x + a.x * i, u.y = e.y + a.y * n, u.r = a.r * i } var l = t.pos2OnGraph.x - t.pos1OnGraph.x, d = t.pos2OnGraph.y - t.pos1OnGraph.y; if (0 != l || 0 != d) for (var h = Math.sqrt(l * l + d * d), c = l / h, f = d / h, g = 0, p = o; g < p.length; g++) { var _ = p[g], v = _.x - e.x, m = _.y - e.y; _.x = e.x + c * v + f * m, _.y = e.y - f * v + c * m } return o }, na.prototype._drawPoints = function (t) { 1 === t.length ? this._drawCircle(t[0], t[0].r) : this._drawPolygon(t) }, na.prototype._computeCenter = function (t) { var e = Math.cos(t.offsetAngle), i = Math.sin(t.offsetAngle), n = (t.pos1.x + t.pos2.x) / 2 + e * t.offset, r = (t.pos1.y + t.pos2.y) / 2 + i * t.offset; return this._point(n, r) }, na.prototype._displayNodeComponent = function (e, t, i, n) { var r = this, o = this._computeCenter(e); if (e.pattern.type !== An) { var s = e.rectWidthOrSourceRadius / 2, a = e.rectHeightOrTargetRadius / 2, u = this._scalePoints(e, o, s, a); if ((t || n) && this._drawPoints(u), t && this._fill(e.fillColor), n) { if (this._startClip(), e.pattern.type === bn) { var l = e.pattern.attributes.colorArray; 1 !== e.opacity && (l = l.map(function (t) { return r._blendColor(t, e.opacity) })), this._displayPieChart(o, s, l) } else if (e.pattern.type === xn || e.pattern.type === En) { var d = 0, h = Math.round(e.rectHeightOrTargetRadius * e.patternScale), c = e.pattern.attributes.text, f = e.patternColor, g = e.pattern.attributes.font, p = e.pattern.attributes.style, _ = e.pattern.attributes.align, v = e.rectWidthOrSourceRadius; this._displayText(o, d, c, f, g, h, p, _, v) } else if (e.pattern.type === yn) { var m = e.pattern.attributes.image; if (m.isDummy || m.width && m.height) { var y = e.pattern.attributes.duplicated, b = y ? 1 : e.patternScale, x = e.rectWidthOrSourceRadius * b, E = e.rectHeightOrTargetRadius * b, A = e.pattern.attributes.scaled, S = e.opacity; this._displayImage(o, x, E, m, A, y, S) } } this._endClip() } if (i) { var w = e.strokeWidth / 2, T = this._scalePoints(e, o, s + w, a + w); this._drawPoints(T), this._stroke(e.strokeColor, e.strokeWidth) } } else n && (d = 0, h = e.thicknessOrFontSize, c = e.pattern.attributes.text, f = e.patternColor, g = e.pattern.attributes.font, p = e.pattern.attributes.style, _ = e.pattern.attributes.align, v = e.rectWidthOrSourceRadius, this._displayText(o, d, c, f, g, h, p, _, v)) }, na.prototype._displayElement = function (t, e) { if (t.end.shape && t.end.pieceId) { this._resetCachePoints(); var i = e ? this._mixAttributes(t.end, t.start, t.animation) : t.end, n = this._computeRenderInfo(i); if (!(n.symbolicSize < n.globalMinVisibleSize || 0 === n.opacity)) { this._applyBackgroundBlending(n); var r, o, s, a, u, l, d, h, c, f, g, p, _, v, m, y, b, x, E, A, S, w, T = n.strokeColor && 0 < n.strokeWidth && n.symbolicSize >= n.strokeMinVisibleSize, C = 1 !== n.pattern.type && n.symbolicSize >= n.patternMinVisibleSize, M = !!n.fillColor; if (n.pieceId === Sn) this._displayNodeComponent(n, M, T, C); else { var I = n.pos2.x - n.pos1.x, L = n.pos2.y - n.pos1.y, N = Math.sqrt(I * I + L * L), k = null, O = null, F = null; if (n.isSelfLoop) { var R = n.pieceId === Mn ? n.strokeWidth / 2 : n.rectWidthOrSourceRadius, P = this._getSelfLoopControlPoints(n.pos1, n.curvature, R), D = P.x1, z = P.y1, B = P.x2, U = P.y2; k = this._point(D, z), O = this._point(B, U), g = n.pos1, p = k, _ = O, n.pos2, v = 1, m = (g.x + p.x + _.x) / 3, y = (g.y + p.y + _.y) / 3, b = m - p.x, x = y - p.y, E = p.x - _.x, A = p.y - _.y, S = b * b + x * x, w = (E * E + A * A) / 4, F = 1.9442 * Math.sqrt(S - w) * 3.14159265359 * v } else F = n.curvature ? (k = this._getQuadraticCurveControlPoint(n), r = n.curvature, o = N, s = 1, a = Math.abs(r) / Vn + 1e-6, d = (l = s - .5) * l, h = 1 / (16 * (u = a * a)), c = Math.sqrt(d + h), f = .5 / a * Math.sqrt(.25 + u), Math.abs(2 * a) * (l * c + .5 * f + h * Math.log(Math.abs((l + c) / (f - .5)))) * o) : N; if (n.pieceId === Mn) { var V = n.strokeWidth, j = this._getPointOnLine(n.pos1, k, O, n.pos2, .5), G = this._getTangentOnLine(n.pos1, k, O, n.pos2, .5); n.adjustTextAngle && !n.isSelfLoop && n.rectWidthOrSourceRadius >= F - V && (G.x = 1, G.y = 0, n.offset = 0); var H = -Math.atan2(G.y, G.x), q = this._formatAngle(n.offsetAngle - H); (!n.isSelfLoop && q < 0 || n.isSelfLoop && n.offsetAngle < 0) && (G.x *= -1, G.y *= -1), (H > Math.PI / 2 || H < -Math.PI / 2) && (H += Math.PI); var W = this._getOrthogonal(G), X = j.x + W.x * n.offset, Y = j.y + W.y * n.offset; if (n.fillColor) { var Z = this._pointArray(4), K = n.rectWidthOrSourceRadius / 2, Q = n.rectHeightOrTargetRadius / 2, J = G.x * K, $ = G.y * K, tt = W.x * Q, et = W.y * Q, it = Z[0], nt = Z[1], rt = Z[2], ot = Z[3]; it.x = X + J + tt, it.y = Y + $ + et, nt.x = X + J - tt, nt.y = Y + $ - et, rt.x = X - J - tt, rt.y = Y - $ - et, ot.x = X - J + tt, ot.y = Y - $ + et, this._drawPoints(Z), this._fill(n.fillColor) } else { var st = this._point(X, Y), at = H, ut = n.thicknessOrFontSize, lt = n.pattern.attributes.text, dt = n.patternColor, ht = n.pattern.attributes.font, ct = n.pattern.attributes.style, ft = n.pattern.attributes.align, gt = n.rectWidthOrSourceRadius; this._displayText(st, at, lt, dt, ht, ut, ct, ft, gt) } } else { var pt = n.pieceId === Tn, _t = n.pieceId === Cn, vt = Math.cos(n.offsetAngle), mt = Math.sin(n.offsetAngle); n.pos1.x += vt * n.offset, n.pos1.y += mt * n.offset, n.pos2.x += vt * n.offset, n.pos2.y += mt * n.offset; var yt = "line" === n.shape.name, bt = n.thicknessOrFontSize, xt = n.rectWidthOrSourceRadius, Et = n.rectHeightOrTargetRadius, At = +n.hasHead, St = +n.hasTail, wt = +n.isBodyTriangle, Tt = At + St, Ct = 3 * bt, Mt = At * Ct, It = St * Ct, Lt = n.isSelfLoop ? 1 / 0 : N - xt - Et, Nt = Math.min(Lt / Tt, Ct), kt = St * (Ct + Math.max(xt + Nt - It, 0)) + (1 - St) * wt * xt, Ot = At * (Ct + Math.max(Et + Nt - Mt, 0)) + (1 - At) * wt * Et; if (pt || _t) { var Ft = _t ? -1 : 1, Rt = (pt ? F - Ot : kt) - Ft, Pt = null, Dt = null; if (n.isSelfLoop) { var zt = this._getTFromLengthOnCubicCurve(n.pos1, k, O, n.pos2, Rt - n.strokeWidth / 2 * Ft); Pt = this._getPointOnCubicCurve(n.pos1, k, O, n.pos2, zt), Dt = this._getTangentOnCubicCurve(n.pos1, k, O, n.pos2, zt) } else Dt = n.curvature ? (zt = this._getTFromLengthOnQuadraticCurve(n.pos1, k, n.pos2, Rt - n.strokeWidth / 2 * Ft), Pt = this._getPointOnQuadraticCurve(n.pos1, k, n.pos2, zt), this._getTangentOnQuadraticCurve(n.pos1, k, n.pos2, zt)) : (zt = Rt / F, Pt = this._mixPoints(n.pos1, n.pos2, zt), this._point(I / N, L / N)); if (Dt.x *= Ft, Dt.y *= Ft, M) { if (n.shape.hole) { var Bt = this._makeEdgeExtremityPoints(Pt, Dt, Ct, n.shape.hole); this._drawPoints(Bt), this._startReverseClip() } Z = this._makeEdgeExtremityPoints(Pt, Dt, Ct, n.shape.points), this._drawPoints(Z), this._fill(n.fillColor), n.shape.hole && this._endReverseClip() } if (T) { n.shape.hole && (Bt = this._makeEdgeExtremityPoints(Pt, Dt, Ct, n.shape.hole), this._drawPoints(Bt), this._stroke(n.strokeColor, n.strokeWidth)); var Ut = Ct + n.strokeWidth / 2; Z = this._makeEdgeExtremityPoints(Pt, Dt, Ut, n.shape.points), this._drawPoints(Z), this._stroke(n.strokeColor, n.strokeWidth) } } else { if (F - kt - Ot <= 0) return; if (yt) { var Vt = function (t, e, i, n, r, o) { var s = []; if (i && s.push(0, i), r && o) { for (var a = r * e, u = o * e, l = a + u, d = t - n - i - l, h = 0; h < d;)s.push(a, u), h += l; var c = t - n - i - h, f = Math.min(a, c), g = Math.max(c - f, 0); s.push(f, g) } else s.push(t - n - i, 0); return n && s.push(0, n), s }(F, bt, kt, Ot, n.dashLength, n.gapLength); T && (this._drawLine(n.pos1, k, O, n.pos2), this._stroke(n.strokeColor, bt + 2 * n.strokeWidth, Vt)), M && (this._drawLine(n.pos1, k, O, n.pos2), this._stroke(n.fillColor, bt, Vt)) } else { var jt = kt, Gt = F - Ot; T && (Z = this._makeTriangleEdgeBody(n.pos1, k, O, n.pos2, jt, Gt, bt + n.strokeWidth / 2, n.strokeWidth / 2), this._drawPoints(Z), this._stroke(n.strokeColor, n.strokeWidth)), M && (Z = this._makeTriangleEdgeBody(n.pos1, k, O, n.pos2, jt, Gt, bt, 0), this._drawPoints(Z), this._fill(n.fillColor)) } } } } } } }, na.prototype._makeTriangleEdgeBody = function (t, e, i, n, r, o, s, a) { return e ? i ? this._makeSelfLoopTriangleEdge(t, e, i, n, r, o, s, a) : this._makeCurveTriangleEdge(t, e, n, r, o, s, a) : this._makeStraightTriangleEdge(t, n, r, o, s, a) }, na.prototype._makeCurveTriangleEdge = function (t, e, i, n, r, o, s) { for (var a = this._pointArray(84), u = this._getTFromLengthOnQuadraticCurve(t, e, i, n), l = (this._getTFromLengthOnQuadraticCurve(t, e, i, r) - u) / 41, d = (s - o) / 41 / 2, h = o / 2, c = u, f = 0; f <= 41; ++f) { var g = this._getPointOnQuadraticCurve(t, e, i, c), p = this._getTangentOnQuadraticCurve(t, e, i, c), _ = this._getOrthogonal(p), v = _.x * h, m = _.y * h, y = a[f], b = a[83 - f]; y.x = g.x + v, y.y = g.y + m, b.x = g.x - v, b.y = g.y - m, c += l, h += d } return a }, na.prototype._makeSelfLoopTriangleEdge = function (t, e, i, n, r, o, s, a) { for (var u = this._pointArray(84), l = this._getTFromLengthOnCubicCurve(t, e, i, n, r), d = (this._getTFromLengthOnCubicCurve(t, e, i, n, o) - l) / 41, h = (a - s) / 41 / 2, c = s / 2, f = l, g = 0; g <= 41; ++g) { var p = this._getPointOnCubicCurve(t, e, i, n, f), _ = this._getTangentOnCubicCurve(t, e, i, n, f), v = this._getOrthogonal(_), m = v.x * c, y = v.y * c, b = u[g], x = u[83 - g]; b.x = p.x + m, b.y = p.y + y, x.x = p.x - m, x.y = p.y - y, f += d, c += h } return u }, na.prototype._makeStraightTriangleEdge = function (t, e, i, n, r, o) { var s = e.x - t.x, a = e.y - t.y, u = Math.sqrt(s * s + a * a), l = this._point(s / u, a / u), d = this._getOrthogonal(l), h = r / 2, c = o / 2, f = this._pointArray(4), g = f[0], p = f[1], _ = f[2], v = f[3], m = t.x + l.x * i, y = t.y + l.y * i, b = t.x + l.x * n, x = t.y + l.y * n, E = d.x * h, A = d.y * h, S = d.x * c, w = d.y * c; return g.x = m + E, g.y = y + A, p.x = m - E, p.y = y - A, _.x = b - S, _.y = x - w, v.x = b + S, v.y = x + w, f }, na.prototype._makeEdgeExtremityPoints = function (t, e, i, n) { for (var r = this._pointArray(n.length), o = i / 2, s = t.x + e.x * o, a = t.y + e.y * o, u = e.x, l = e.y, d = 0; d < n.length; ++d) { var h = n[d], c = r[d], f = (u * h.x - l * h.y) * o, g = (l * h.x + u * h.y) * o; c.x = s + f, c.y = a + g, c.r = h.r * o } return r }, na.prototype._drawLine = function (t, e, i, n) { e ? i ? this._drawCubicCurve(t, e, i, n) : this._drawQuadraticCurve(t, e, n) : this._drawStraightLine(t, n) }, na.prototype._getSelfLoopControlPoints = function (t, e, i) { return ta(t.x, t.y, e, i, this._viewAngle, this._tmp) }, na.prototype._getQuadraticCurveControlPoint = function (t) { return $s(t.pos1.x, t.pos1.y, t.pos2.x, t.pos2.y, t.curvature, this._point(0, 0)) }, na.prototype._graphToScreenCoordinates = function (t) { var e = this._width / 2, i = this._height / 2, n = (t.x - this._viewX) * this._viewZoom, r = (t.y - this._viewY) * this._viewZoom, o = this._viewAngleCos, s = this._viewAngleSin, a = o * n + s * r + e, u = -s * n + o * r + i; return this._point(a, u) }, na.prototype._blendColor = function (t, e) { return t ? this._mixColor(this._backgroundColor, t, e, 1) : null }, na.prototype._getTangentOnLine = function (t, e, i, n, r) { return e ? i ? this._getTangentOnCubicCurve(t, e, i, n, r) : this._getTangentOnQuadraticCurve(t, e, n, r) : this._getTangentOnStraightLine(t, n) }, na.prototype._getTangentOnStraightLine = function (t, e) { var i = e.x - t.x, n = e.y - t.y, r = Math.sqrt(i * i + n * n); return this._point(i / r, n / r) }, na.prototype._getTangentOnQuadraticCurve = function (t, e, i, n) { var r = 1 - n, o = r * e.x + n * i.x - (r * t.x + n * e.x), s = r * e.y + n * i.y - (r * t.y + n * e.y), a = Math.sqrt(o * o + s * s); return this._point(o / a, s / a) }, na.prototype._getTangentOnCubicCurve = function (t, e, i, n, r) { var o = 1 - r, s = o * o, a = r * r, u = s * (e.x - t.x) + 2 * o * r * (i.x - e.x) + a * (n.x - i.x), l = s * (e.y - t.y) + 2 * o * r * (i.y - e.y) + a * (n.y - i.y), d = Math.sqrt(u * u + l * l); return this._point(u / d, l / d) }, na.prototype._mixPoints = function (t, e, i) { var n = Ze(t.x, e.x, i), r = Ze(t.y, e.y, i); return this._point(n, r) }, na.prototype._getOrthogonal = function (t) { return this._point(-t.y, t.x) }, na.prototype._getPointOnLine = function (t, e, i, n, r) { return e ? i ? this._getPointOnCubicCurve(t, e, i, n, r) : this._getPointOnQuadraticCurve(t, e, n, r) : this._mixPoints(t, n, r) }, na.prototype._getPointOnQuadraticCurve = function (t, e, i, n) { var r = Js(t.x, e.x, i.x, n), o = Js(t.y, e.y, i.y, n); return this._point(r, o) }, na.prototype._getPointOnCubicCurve = function (t, e, i, n, r) { var o = Qs(t.x, e.x, i.x, n.x, r), s = Qs(t.y, e.y, i.y, n.y, r); return this._point(o, s) }, na.prototype._getTFromLengthOnCubicCurve = function (t, e, i, n, r) { for (var o = t.x, s = t.y, a = 0, u = 0, l = 0; l < 41; ++l) { a += 1 / 41; var d = Qs(t.x, e.x, i.x, n.x, a), h = Qs(t.y, e.y, i.y, n.y, a), c = d - o, f = h - s, g = Math.sqrt(c * c + f * f), p = u + g; if (r < p) return a - 1 / 41 * ((p - r) / g); u = p, o = d, s = h } return 1 }, na.prototype._getTFromLengthOnQuadraticCurve = function (t, e, i, n) { for (var r = t.x, o = t.y, s = 0, a = 0, u = 0; u < 41; ++u) { s += 1 / 41; var l = Js(t.x, e.x, i.x, s), d = Js(t.y, e.y, i.y, s), h = l - r, c = d - o, f = Math.sqrt(h * h + c * c), g = a + f; if (n < g) return s - 1 / 41 * ((g - n) / f); a = g, r = l, o = d } return 1 }, na); function na(t) { var e = ea.call(this, t) || this; return e._cachePoints = [], e._nextCachePoint = 0, e._tmp = { x1: 0, y1: 0, x2: 0, y2: 0 }, e._pointCopies = Array(128), e._clipViewport = !0, e } var ra, oa = !nr().__dummy, sa = (b(aa, ra = ia), aa.getName = function () { return "Canvas" }, aa.isAvailable = function () { return oa }, aa.prototype.getDomElement = function () { return this._canvas }, aa.prototype._render = function (t) { t.dimensionsChanged && hr(this._canvas, this._width, this._height, this._pixelRatio); var e = this._ctx, i = this._width * this._pixelRatio, n = this._height * this._pixelRatio; e.clearRect(0, 0, i, n), this._backgroundColor && this._renderBackground && (e.fillStyle = this._backgroundColor, e.fillRect(0, 0, i, n)); for (var r = this._bufferList.getBuffersByAscendingDepth(), o = 0; o < r.length; ++o) { var s = r[o]; this._isBufferDisplayable(s) && this._displayBuffer(s) } }, aa.prototype._drawCircle = function (t, e) { var i = this._ctx, n = this._pixelRatio, r = t.x * n, o = t.y * n, s = e * n; i.beginPath(), i.arc(r, o, s, 0, 2 * Math.PI) }, aa.prototype._drawPolygon = function (t) { var e = this._ctx, i = this._pixelRatio; e.beginPath(); var n = t[0]; e.moveTo(n.x * i, n.y * i); for (var r = 1; r < t.length; ++r) { var o = t[r]; e.lineTo(o.x * i, o.y * i) } e.closePath() }, aa.prototype._drawStraightLine = function (t, e) { var i = this._ctx, n = this._pixelRatio; i.beginPath(), i.moveTo(t.x * n, t.y * n), i.lineTo(e.x * n, e.y * n) }, aa.prototype._drawQuadraticCurve = function (t, e, i) { var n = this._ctx, r = this._pixelRatio; n.beginPath(), n.moveTo(t.x * r, t.y * r), n.quadraticCurveTo(e.x * r, e.y * r, i.x * r, i.y * r) }, aa.prototype._drawCubicCurve = function (t, e, i, n) { var r = this._ctx, o = this._pixelRatio; r.beginPath(), r.moveTo(t.x * o, t.y * o), r.bezierCurveTo(e.x * o, e.y * o, i.x * o, i.y * o, n.x * o, n.y * o) }, aa.prototype._fill = function (t) { var e = this._ctx; e.fillStyle = t, e.fill() }, aa.prototype._stroke = function (t, e, i) { var n = this; void 0 === i && (i = []); var r = this._ctx; r.setLineDash(i.map(function (t) { return t * n._pixelRatio })), r.lineWidth = e, r.strokeStyle = t, r.stroke() }, aa.prototype._startClip = function () { this._ctx.save(), this._ctx.clip() }, aa.prototype._endClip = function () { this._ctx.restore() }, aa.prototype._startReverseClip = function () { this._ctx.save(), this._ctx.rect(0, 0, this._canvas.width, this._canvas.height), this._ctx.clip("evenodd") }, aa.prototype._endReverseClip = function () { this._ctx.restore() }, aa.prototype._displayText = function (t, e, i, n, r, o, s, a, u) { var l = this._ctx, d = this._pixelRatio, h = t.x * d, c = t.y * d, f = o * d, g = "center" === a ? 0 : -u / 2; if (l.save(), l.translate(h, c), l.rotate(-e), l.textAlign = a, l.textBaseline = "middle", or(l, r, f, s), l.fillStyle = n, -1 !== i.indexOf("\n")) for (var p = i.split("\n"), _ = p.length, v = (1 - _) / 2 * f, m = 0; m < _; ++m)l.fillText(p[m], g, v), v += f; else l.fillText(i, g, -1); l.restore() }, aa.prototype._displayImage = function (t, e, i, n, r, o, s) { if (!(this._hideImages || "isDummy" in n)) { var a = n; 1 !== s && (a = this._blendImageOnBackground(n, s)); var u = this._ctx, l = this._pixelRatio, d = t.x * l, h = t.y * l, c = e * l, f = i * l, g = a.width * l, p = a.height * l; if (r) u.drawImage(a, d - c / 2, h - f / 2, c, f); else if (o) { for (var _ = d - c / 2, v = h - f / 2, m = d + c / 2, y = h + f / 2, b = d - g / 2, x = h - p / 2; _ < b;)b -= g; for (; v < x;)x -= p; for (var E = x; b < m;) { for (; x < y;)u.drawImage(a, b, x, g, p), x += p; b += g, x = E } } else u.drawImage(a, d - g / 2, h - p / 2, g, p) } }, aa.prototype._displayPieChart = function (t, e, i) { var n = this._ctx, r = this._pixelRatio, o = t.x * r, s = t.y * r, a = e * r * 2, u = 2 * a; 1 === i.length ? (n.fillStyle = i[0], n.fillRect(o - a, s - a, u, u)) : 2 === i.length ? (n.fillStyle = i[0], n.fillRect(o - a, s, u, a), n.fillStyle = i[1], n.fillRect(o - a, s - a, u, a)) : zr(n, i, o, s, a) }, aa.prototype._blendImageOnBackground = function (t, e) { var i = this._backgroundRgba, n = "rgb(" + Math.round(255 * i[0]) + "," + Math.round(255 * i[1]) + "," + Math.round(255 * i[2]) + ")"; return this._imgCanvas.width = t.width, this._imgCanvas.height = t.height, this._imgCtx.clearRect(0, 0, t.width, t.height), this._imgCtx.globalAlpha = 1, this._imgCtx.fillStyle = n, this._imgCtx.fillRect(0, 0, t.width, t.height), this._imgCtx.globalAlpha = e, this._imgCtx.drawImage(t, 0, 0), this._imgCanvas }, aa.prototype.getImageData = function () { return this._ctx.getImageData(0, 0, this._canvas.width, this._canvas.height) }, aa); function aa(t) { var e = ra.call(this, t) || this; return e._canvas = nr(), e._imgCanvas = nr(), e._initCanvas(e._canvas), e._ctx = e._canvas.getContext("2d"), e._imgCtx = e._imgCanvas.getContext("2d"), e } var ua = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; function la(t, e, i, n, r, o) { void 0 === o && (o = { x: 0, y: 0 }); var s = Math.cos(r), a = Math.sin(r), u = t - i, l = e - n; return o.x = s * u - a * l + i, o.y = a * u + s * l + n, o } function distance(t, e, i, n) { return Math.sqrt((t - i) * (t - i) + (e - n) * (e - n)) } function da(t, e, i, n) { var r = t - i, o = e - n; return r * r + o * o } function ha(t) { return 180 * t / Math.PI } var ca = !1; try { ca = !!Rt("svg") } catch (t) { } var fa = "none", ga = { left: "start", center: "middle", right: "end" }, pa = "data-element-id"; function _a(t) { return Math.round(1e3 * t) / 1e3 } function va(t, e, i, n, r, o) { var s = Rt("image"); return s.setAttribute("width", _a(n)), s.setAttribute("height", _a(r)), s.setAttribute("x", _a(e)), s.setAttribute("y", _a(i)), s.setAttribute("href", t), o && o.appendChild(s), s } function ma(t, e, i, n, r, o, s) { void 0 === o && (o = 1); var a = Rt("rect"); return a.setAttribute("x", t), a.setAttribute("y", e), a.setAttribute("width", i), a.setAttribute("height", n), a.setAttribute("fill", r), a.setAttribute("fill-opacity", o), s && s.appendChild(a), a } var ya, ba = (b(xa, ya = ia), xa.getName = function () { return "SVG" }, xa.isAvailable = function () { return ca }, xa.prototype.getDomElement = function () { return this._svg }, xa.prototype._render = function (t) { if (t.dimensionsChanged && Nt(this._svg, { width: this._width, height: this._height }), this._backgroundColor && this._renderBackground) { var e = this._colorManager.rgbaToRgb(this._backgroundColor); this._background.setAttribute("fill", e.color), this._background.setAttribute("fill-opacity", e.opacity) } var i = this._bufferList.getBuffersByAscendingDepth(); this._clear(), this._svg.removeChild(this._container); for (var n = 0; n < i.length; ++n) { var r = i[n]; this._isBufferDisplayable(r) && this._displayBuffer(r) } this._svg.appendChild(this._container) }, xa.prototype._clear = function () { this._container && this._svg.removeChild(this._container), this._container = Rt("g"), this._svg.appendChild(this._container), this._clipPaths && this._defs.removeChild(this._clipPaths), this._clipPaths = Rt("g"), this._defs.appendChild(this._clipPaths), this._filters && this._defs.removeChild(this._filters), this._filters = Rt("g"), this._defs.appendChild(this._filters) }, xa.prototype._displayElement = function (t, e) { this._currentElementId = 0 <= t.id ? "n" + t.id : "e" + -t.id, ya.prototype._displayElement.call(this, t, e) }, xa.prototype._addBackgroundBlendingFilter = function (t) { var e = this._colorManager.parseColor(this._backgroundColor), i = 1 - t, n = [t, 0, 0, 0, e[0] * i, 0, t, 0, 0, e[1] * i, 0, 0, t, 0, e[2] * i, 0, 0, 0, 1, 0].join(" "), r = "filter-" + this._currentElementId, o = Rt("filter", { id: r }), s = Rt("feColorMatrix", { in: "SourceGraphic", type: "matrix", values: n }); return o.appendChild(s), this._filters.appendChild(o), r }, xa.prototype._drawCircle = function (t, e) { var i = "M " + (t.x - e) + ", " + t.y + " a " + e + "," + e + " 0 1,0 " + 2 * e + ",0 a " + e + "," + e + " 0 1,0 -" + 2 * e + ",0", n = Rt("path"); n.setAttribute("d", i), n.setAttribute("fill", fa), n.setAttribute(pa, this._currentElementId), this._container.appendChild(n), this._element = n }, xa.prototype._drawPolygon = function (t) { for (var e = Rt("path"), i = "", n = 0; n < t.length; n++) { var r = t[n]; i += (0 === n ? "M" : "L") + r.x + "," + r.y + " " } i += "Z", e.setAttribute("d", i), e.setAttribute(pa, this._currentElementId), e.setAttribute("fill", fa), this._container.appendChild(e), this._element = e }, xa.prototype._drawStraightLine = function (t, e) { var i = Rt("path"), n = "M " + t.x + "," + t.y + " L" + e.x + "," + e.y; i.setAttribute("d", n), i.setAttribute(pa, this._currentElementId), this._container.appendChild(i), this._element = i }, xa.prototype._drawQuadraticCurve = function (t, e, i) { var n = Rt("path"), r = "M " + t.x + "," + t.y + " Q" + e.x + "," + e.y + " " + i.x + "," + i.y; n.setAttribute("d", r), n.setAttribute("fill", fa), n.setAttribute(pa, this._currentElementId), this._container.appendChild(n), this._element = n }, xa.prototype._drawCubicCurve = function (t, e, i, n) { var r = Rt("path"), o = "M " + t.x + "," + t.y + " C" + e.x + "," + e.y + " " + i.x + "," + i.y + " " + n.x + "," + n.y; r.setAttribute("d", o), r.setAttribute("fill", fa), r.setAttribute(pa, this._currentElementId), this._container.appendChild(r), this._element = r }, xa.prototype._fill = function (t) { var e = this._colorManager.rgbaToRgb(t); this._element.setAttribute("fill", e.color), this._element.setAttribute("fill-opacity", e.opacity), this._currentClipPathId && this._element.setAttribute("clip-path", "url(#" + this._currentClipPathId + ")") }, xa.prototype._stroke = function (t, e, i) { void 0 === i && (i = []); var n = this._element; n.setAttribute("stroke-width", e); var r = this._colorManager.rgbaToRgb(t); n.setAttribute("stroke", r.color), n.setAttribute("stroke-opacity", r.opacity), 0 < i.length && n.setAttribute("stroke-dasharray", i.map(_a).toString()) }, xa.prototype._startClip = function () { var t = Rt("clipPath"), e = this._element.cloneNode(!1); this._currentClipPathId = "clip-path-" + this._clipPathCounter++ , t.appendChild(e), this._clipPaths.appendChild(t), t.setAttribute("id", this._currentClipPathId) }, xa.prototype._endClip = function () { this._currentClipPathId = null }, xa.prototype._startReverseClip = function () { var t = Rt("clipPath"), e = this._element.cloneNode(!1), i = e.getAttribute("d"); e.setAttribute("clip-rule", "evenodd"), e.setAttribute("d", i + " M 0 0 L " + this._width + " 0 L " + this._width + " " + this._height + " L 0 " + this._height), this._currentClipPathId = "clip-path-" + this._clipPathCounter++ , t.appendChild(e), this._clipPaths.appendChild(t), t.setAttribute("id", this._currentClipPathId) }, xa.prototype._endReverseClip = function () { this._currentClipPathId = null }, xa.prototype._displayText = function (t, e, i, n, r, o, s, a, u) { var l = Rt("text"); l.setAttribute(pa, this._currentElementId); var d = this._colorManager.rgbaToRgb(n), h = d.opacity, c = this._colorManager.rgbaToRgb(d.color), f = t.x, g = t.y; s = s || "normal"; var p = _a(f); l.setAttribute("x", p), l.setAttribute("font-family", r), l.setAttribute("font-size", o), "bold" === s ? l.setAttribute("font-weight", s) : l.setAttribute("font-style", s), l.setAttribute("fill", c.color), l.setAttribute("fill-opacity", h), e && l.setAttribute("transform", "rotate(" + ha(-e) + " " + f + ", " + g + ")"), l.setAttribute("text-anchor", ga[a] || "middle"); var _ = i.split("\n"), v = _.length, m = (v + 1) / 2 - 1 / 3; l.setAttribute("y", _a(g - m * o)); for (var y = 0; y < v; y++) { var b = Rt("tspan"); b.appendChild(Pt(_[y])), b.setAttribute("x", p), b.setAttribute("dy", o), l.appendChild(b) } this._currentClipPathId && l.setAttribute("clip-path", "url(#" + this._currentClipPathId + ")"), this._container.appendChild(l) }, xa.prototype._displayImage = function (t, e, i, n, r, o, s) { var a = t.x, u = t.y; if (!this._hideImages && ("isDummy" in n || n.width && n.height)) { var l, d = n.width, h = n.height; if (r && (d = e, h = i), o) { var c = a - e / 2, f = u - i / 2, g = a + e / 2, p = u + i / 2, _ = a - d / 2, v = u - h / 2; for ((l = Rt("g")).setAttribute(pa, this._currentElementId); c < _;)_ -= d; for (; f < v;)v -= h; for (var m = v; _ < g;) { for (; v < p;)va(n.src, _, v, d, h, l), v += h; v = m, _ += d } } else (l = va(n.src, a - d / 2, u - h / 2, d, h)).setAttribute(pa, this._currentElementId); if (this._currentClipPathId && l.setAttribute("clip-path", "url(#" + this._currentClipPathId + ")"), 1 !== s) { var y = this._addBackgroundBlendingFilter(s); l.setAttribute("filter", "url(#" + y + ")") } this._container.appendChild(l) } }, xa.prototype._displayPieChart = function (t, l, e) { var d, i = 2 * l, n = 2 * i, h = t.x, c = t.y, f = Rt("g"); f.setAttribute(pa, this._currentElementId), 1 === e.length ? d = ma(h - i, c - i, n, n, e[0], 1, f) : 2 === e.length ? (d = ma(h - i, c, n, i, e[0], 1, f), d = ma(h - i, c - i, n, i, e[1], 1, f)) : Dr(e, function (t, e, i) { var n = h + l * Math.cos(i), r = c + l * Math.sin(i), o = h + l * Math.cos(e), s = c + l * Math.sin(e), a = i - e <= Math.PI ? 0 : 1, u = "M " + n + "," + r + " A " + l + "," + l + " 0 " + a + " 0 " + o + "," + s + " L " + h + "," + c + " L " + n + "," + r; (d = Rt("path")).setAttribute("d", u), d.setAttribute("fill", t), d.setAttribute("stroke-width", 0), f.appendChild(d) }), this._currentClipPathId && f.setAttribute("clip-path", "url(#" + this._currentClipPathId + ")"), this._container.appendChild(f) }, xa); function xa(t) { var e = ya.call(this, t) || this; return e._svg = Rt("svg"), e._defs = Rt("defs"), e._styles = Rt("g", { class: "styles" }), e._background = Rt("rect", { width: "100%", height: "100%", fill: "none", class: "ogma-svg-background" }), e._currentElementId = "0", e._currentClipPathId = null, e._clipPathCounter = 1, e._defs.appendChild(e._styles), e._svg.setAttribute("pointer-events", "none"), e._svg.style.userSelect = "none", e._svg.appendChild(e._defs), e._svg.appendChild(e._background), e._clear(), e } var Ea = (Aa.prototype.reset = function () { this._initialize() }, Aa.prototype._initialize = function () { this._mustUpdate = !0, this.maxCoord = 0, this.maxScaledSize = 0, this.maxMinVisibleSize = 0, this.maxSymbolicSize = 0, this.maxDashLength = 0, this.maxGapLength = 0, this.maxPatternScale = 0 }, Aa.prototype.set = function (t) { var e = t.maxCoord, i = t.maxScaledSize, n = t.maxMinVisibleSize, r = t.maxSymbolicSize, o = t.maxDashLength, s = t.maxGapLength, a = t.maxPatternScale, u = this.maxCoord < e || this.maxScaledSize < i || this.maxMinVisibleSize < n || this.maxSymbolicSize < r || this.maxDashLength < o || this.maxGapLength < s || this.maxPatternScale < a; return u && (this.maxCoord = e, this.maxScaledSize = i, this.maxMinVisibleSize = n, this.maxSymbolicSize = r, this.maxDashLength = o, this.maxGapLength = s, this.maxPatternScale = a, this._mustUpdate = !0), u }, Aa.prototype.update = function () { return this._mustUpdate && (this._version += 1, this._mustUpdate = !1), this }, Aa.prototype.getVersion = function () { return this._version }, Aa); function Aa() { this._version = 0, this._initialize() } var Sa = { linear: [0, 1, 0, 0], quadraticIn: [0, 0, 1, 0], quadraticOut: [0, 2, -1, 0], quadraticInOut: [0, 0, 2, 0, -1, 4, -2, 0], cubicIn: [0, 0, 0, 1], cubicOut: [0, 3, -3, 1], cubicInOut: [0, 0, 0, 4, -3, 12, -12, 4] }, wa = (Ta.prototype.add = function (n) { var r = this; Object.keys(n).forEach(function (t) { var e = n[t].slice(); e.length < 8 && (e[4] = e[0], e[5] = e[1], e[6] = e[2], e[7] = e[3]); var i = z(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7]); r._nameToPolygon[t] = e, r._polygonToName[i] = t }) }, Ta.prototype.getCoefficients = function (t) { return this._nameToPolygon[t] || this._linearEasing }, Ta.prototype.getName = function (t, e, i, n, r, o, s, a) { var u = z(t, e, i, n, r, o, s, a); return this._polygonToName[u] || "linear" }, Ta); function Ta() { this._linearEasing = [0, 1, 0, 0, 0, 1, 0, 0], this._nameToPolygon = {}, this._polygonToName = {}, this.add(Sa) } var Ca = (Ma.prototype.resizeBoundaries = function (t, e, i, n, r, o) { this._maxScaledSize = t, this._maxMinVisibleSize = e, this._maxSymbolicSize = i, this._maxDashLength = n, this._maxGapLength = r, this._maxPatternScale = o, this._actualScaledSizeToBytes = 65535 / t, this._actualMinVisibleSizeToBytes = 15 / e, this._actualSymbolicSizeToBytes = 255 / i, this._actualDashLengthToBytes = 3 / n, this._actualGapLengthToBytes = 3 / r, this._actualPatternScaleToBytes = 255 / o }, Ma.prototype.storeGenericObject = function (t, e, i) { var n = this._shapeManager.getIdFromName(i.shape), r = i.pieceId, o = this._dashLengthToBytes(i.dashLength), s = this._gapLengthToBytes(i.gapLength), a = +i.hasHead, u = +i.hasTail, l = +i.isBodyTriangle, d = +i.isSelfLoop, h = this._patternScaleToBytes(i.patternScale), c = this._offsetAngleToBytes(i.offsetAngle), f = +i.isText, g = +i.adjustTextAngle, p = +i.unusedFlag1, _ = +i.unusedFlag2, v = +i.unusedFlag3, m = this._opacityToBytes(i.opacity), y = this._minVisibleSizeToBytes(i.globalMinVisibleSize), b = this._minVisibleSizeToBytes(i.strokeMinVisibleSize), x = this._minVisibleSizeToBytes(i.patternMinVisibleSize), E = this._symbolicSizeToBytes(i.symbolicSize), A = this._curvatureToBytes(i.curvature), S = this._patternManager.getIdFromDefinition(i.pattern), w = this._colorToBytes(i.fillColor), T = this._colorToBytes(i.strokeColor), C = this._colorToBytes(i.patternColor), M = this._coordToBytes(i.x1), I = this._coordToBytes(i.y1), L = this._coordToBytes(i.x2), N = this._coordToBytes(i.y2), k = this._scaledSizeToBytes(i.rectWidthOrSourceRadiusScaled), O = this._fixedSizeToBytes(i.rectWidthOrSourceRadiusFixed), F = this._scaledSizeToBytes(i.rectHeightOrTargetRadiusScaled), R = this._fixedSizeToBytes(i.rectHeightOrTargetRadiusFixed), P = this._scaledSizeToBytes(i.thicknessOrFontSizeScaled), D = this._fixedSizeToBytes(i.thicknessOrFontSizeFixed), z = this._scaledSizeToBytes(i.strokeWidthScaled), B = this._fixedSizeToBytes(i.strokeWidthFixed), U = this._scaledSizeToBytes(i.offsetScaled), V = this._fixedSizeToBytes(i.offsetFixed), j = n + (r << 4) + (o << 8) + (s << 10) + (a << 12) + (u << 13) + (l << 14) + (d << 15), G = h + (c << 8) + (f << 11) + (g << 12) + (p << 13) + (_ << 14) + (v << 15), H = m + (y << 4) + (b << 8) + (x << 12), q = E + (A << 8); this._setUint16(t, e + 0, j), this._setUint16(t, e + 2, G), this._setUint16(t, e + 4, H), this._setUint16(t, e + 6, q), this._setUint16(t, e + 8, S), this._setUint16(t, e + 10, w), this._setUint16(t, e + 12, T), this._setUint16(t, e + 14, C), this._setFloat32(t, e + 16, M), this._setFloat32(t, e + 20, I), this._setFloat32(t, e + 24, L), this._setFloat32(t, e + 28, N), this._setUint16(t, e + 32, k), this._setUint16(t, e + 34, O), this._setUint16(t, e + 36, F), this._setUint16(t, e + 38, R), this._setUint16(t, e + 40, P), this._setUint16(t, e + 42, D), this._setUint16(t, e + 44, z), this._setUint16(t, e + 46, B), this._setUint16(t, e + 48, U), this._setUint16(t, e + 50, V) }, Ma.prototype._setUint16 = function (t, e, value) { t.setUint16(e, value, this._littleEndian) }, Ma.prototype._setFloat32 = function (t, e, value) { t.setFloat32(e, value, this._littleEndian) }, Ma.prototype._colorToBytes = function (t) { var e = this._colorParser(t); return Math.round(15 * e[0]) + (Math.round(15 * e[1]) << 4) + (Math.round(15 * e[2]) << 8) + (Math.round(15 * e[3]) << 12) }, Ma.prototype._coordToBytes = function (value) { return value }, Ma.prototype._scaledSizeToBytes = function (value) { return Math.ceil(Math.min(value, this._maxScaledSize) * this._actualScaledSizeToBytes) }, Ma.prototype._fixedSizeToBytes = function (value) { return value }, Ma.prototype._minVisibleSizeToBytes = function (value) { return Math.round(Math.min(value, this._maxMinVisibleSize) * this._actualMinVisibleSizeToBytes) }, Ma.prototype._symbolicSizeToBytes = function (value) { return Math.round(Math.min(value, this._maxSymbolicSize) * this._actualSymbolicSizeToBytes) }, Ma.prototype._dashLengthToBytes = function (value) { return Math.round(Math.min(value, this._maxDashLength) * this._actualDashLengthToBytes) }, Ma.prototype._gapLengthToBytes = function (value) { return Math.round(Math.min(value, this._maxGapLength) * this._actualGapLengthToBytes) }, Ma.prototype._patternScaleToBytes = function (value) { return Math.round(Math.min(value, this._maxPatternScale) * this._actualPatternScaleToBytes) }, Ma.prototype._offsetAngleToBytes = function (value) { return Math.round((value + Fs) % Fs * (8 / Fs)) }, Ma.prototype._opacityToBytes = function (value) { return Math.round(15 * Math.min(value, 1)) }, Ma.prototype._curvatureToBytes = function (value) { return this._signedToUnsignedByte(value) }, Ma.prototype._signedToUnsignedByte = function (value) { return Xe(value, -128, 127) + 128 }, Ma.prototype.storeAnimationInformation = function (t, e, i, n) { var r = i.beginTime, o = i.duration; this._setAnimationBeginTime(t, e, r), this._setAnimationDuration(t, e, o), this._setAnimationEasing(t, e, n) }, Ma.prototype._setAnimationBeginTime = function (t, e, i) { this._setFloat32(t, e, i) }, Ma.prototype._setAnimationDuration = function (t, e, i) { this._setFloat32(t, e + 4, i) }, Ma.prototype._setAnimationEasing = function (t, e, i) { this._setUint16(t, e + 8, (i[0] + 128 << 8) + (i[4] + 128)), this._setUint16(t, e + 10, (i[1] + 128 << 8) + (i[5] + 128)), this._setUint16(t, e + 12, (i[2] + 128 << 8) + (i[6] + 128)), this._setUint16(t, e + 14, (i[3] + 128 << 8) + (i[7] + 128)) }, Ma.prototype.extractGenericElement = function (t, e, i) { var n = t.getElementType(), r = t.isAnimated(), o = t.getDataView(), s = e * t.getElementSize(), a = this._genericObject; if (a.valid = !1, o.getUint16(s) && (a.valid = !0, this._extractGenericObject(a.end, o, s, i), r && (this._extractGenericObject(a.start, o, 52 + s, i), this._extractAnimationInformation(a.animation, o, 104 + s)), a.id = this._idRecorder.get(t, e), 2 === n)) { var u = t.getSideDataView(), l = e * t.getTotalSideElementsSize(), d = l + t.getTotalSideElementsSize(), h = a.end; this._extractTextCharacters(h, u, l, d) } return a }, Ma.prototype._extractGenericObject = function (t, e, i, n) { var r = n.bytesToActualCoord, o = n.bytesToActualScaledSize, s = n.bytesToActualMinVisibleSize, a = n.bytesToActualPatternScale, u = n.bytesToActualSymbolicSize, l = n.bytesToActualDashLength, d = n.bytesToActualGapLength, h = e, c = i, f = this._littleEndian, g = h.getUint16(c, f), p = Ia(g, 0, 4), _ = Ia(g, 4, 8), v = Ia(g, 8, 10), m = Ia(g, 10, 12), y = Ia(g, 12, 13), b = Ia(g, 13, 14), x = Ia(g, 14, 15), E = Ia(g, 15, 16), A = h.getUint16(c + 2, f), S = Ia(A, 0, 8), w = Ia(A, 8, 11), T = Ia(A, 11, 12), C = Ia(A, 12, 13), M = Ia(A, 13, 14), I = Ia(A, 14, 15), L = Ia(A, 15, 16), N = h.getUint16(c + 4, f), k = Ia(N, 0, 4), O = Ia(N, 4, 8), F = Ia(N, 8, 12), R = Ia(N, 12, 16), P = h.getUint16(c + 6, f), D = Ia(P, 0, 8), z = Ia(P, 8, 16), B = h.getUint16(c + 8, f), U = h.getUint16(c + 10, f), V = h.getUint16(c + 12, f), j = h.getUint16(c + 14, f), G = h.getFloat32(c + 16, f), H = h.getFloat32(c + 20, f), q = h.getFloat32(c + 24, f), W = h.getFloat32(c + 28, f), X = h.getUint16(c + 32, f), Y = h.getUint16(c + 34, f), Z = h.getUint16(c + 36, f), K = h.getUint16(c + 38, f), Q = h.getUint16(c + 40, f), J = h.getUint16(c + 42, f), $ = h.getUint16(c + 44, f), tt = h.getUint16(c + 46, f), et = h.getUint16(c + 48, f), it = h.getUint16(c + 50, f); t.pieceId = _, t.shape = this._shapeManager.getNameFromId(p), t.x1 = La(G, r), t.y1 = La(H, r), t.x2 = La(q, r), t.y2 = La(W, r), t.rectWidthOrSourceRadiusScaled = La(X, o), t.rectWidthOrSourceRadiusFixed = Y, t.rectHeightOrTargetRadiusScaled = La(Z, o), t.rectHeightOrTargetRadiusFixed = K, t.thicknessOrFontSizeScaled = La(Q, o), t.thicknessOrFontSizeFixed = J, t.strokeWidthScaled = La($, o), t.strokeWidthFixed = tt, t.offsetScaled = La(et, o), t.offsetFixed = it, t.pattern = this._patternManager.getDefinitionFromId(B), t.opacity = k / 15, t.fillColor = ka(U), t.strokeColor = ka(V), t.patternColor = ka(j), t.globalMinVisibleSize = La(O, s), t.strokeMinVisibleSize = La(F, s), t.patternMinVisibleSize = La(R, s), t.offsetAngle = w * (2 * Math.PI / 8), t.patternScale = S * a, t.symbolicSize = D * u, t.curvature = z - 128, t.dashLength = v * l, t.gapLength = m * d, t.hasHead = !!y, t.hasTail = !!b, t.isBodyTriangle = !!x, t.isSelfLoop = !!E, t.isText = !!T, t.adjustTextAngle = !!C, t.unusedFlag1 = !!M, t.unusedFlag2 = !!I, t.unusedFlag3 = !!L }, Ma.prototype._extractAnimationInformation = function (t, e, i) { var n = e, r = i, o = this._littleEndian, s = n.getFloat32(r, o), a = n.getFloat32(r + 4, o), u = n.getUint16(r + 8, o), l = n.getUint16(r + 10, o), d = n.getUint16(r + 12, o), h = n.getUint16(r + 14, o), c = (u >> 8) - 128, f = (l >> 8) - 128, g = (d >> 8) - 128, p = (h >> 8) - 128, _ = u % 256 - 128, v = l % 256 - 128, m = d % 256 - 128, y = h % 256 - 128; t.beginTime = s, t.duration = a, t.easing = this._easingManager.getName(c, f, g, p, _, v, m, y) }, Ma.prototype._extractTextCharacters = function (t, e, i, n) { t.pattern = this._textManager.extractTextFromDataView(e, i, n) }, Ma); function Ma(t, e, i, n, r, o) { this._littleEndian = P(), this._maxScaledSize = 0, this._maxMinVisibleSize = 0, this._maxSymbolicSize = 0, this._maxDashLength = 0, this._maxGapLength = 0, this._maxPatternScale = 0, this._actualScaledSizeToBytes = 32767, this._actualMinVisibleSizeToBytes = 15, this._actualSymbolicSizeToBytes = 255, this._actualDashLengthToBytes = 3, this._actualGapLengthToBytes = 3, this._actualPatternScaleToBytes = 255, this._genericObject = dr(), this._shapeManager = e, this._patternManager = t, this._textManager = i, this._idRecorder = n, this._easingManager = r, this._colorParser = o } function Ia(value, t, e) { return value % (1 << e) >> t } function La(value, t) { return value * t } var Na = new Array(65535); function ka(value) { var t = Na[value]; if (!t) { var e = Ia(value, 0, 4) / 15, i = Ia(value, 4, 8) / 15, n = Ia(value, 8, 12) / 15, r = Ia(value, 12, 16) / 15; t = "rgba(" + (255 * e | 0) + ", " + (255 * i | 0) + ", " + (255 * n | 0) + ", " + r + ")", e + i + n + r == 0 && (t = null), Na[value] = t } return t } var Oa = (Fa.prototype.setDepth = function (t) { return this._depth = t, this }, Fa.prototype.reset = function (t, e, i, n) { return this._elementType = t, this._animated = e, this._depth = i, this._id = n, this._stencilUsage = 1, this._size = 0, this }, Fa.prototype.setStencilUsage = function (t) { this._stencilUsage = t }, Fa.prototype.next = function () { if (this._size >= this._capacity) throw new Error("internal error: block.next() was called on a full block"); return this._list[this._size++] }, Fa.prototype.nextAndReset = function () { var t, e = this.next(); return lr(e.end), lr(e.start), (t = e.animation).duration = 0, t.beginTime = -1, t.easing = "linear", e }, Fa.prototype.forEach = function (t) { this._list.forEach(t) }, Fa.prototype.getElement = function (t) { return this._list[t] }, Fa.prototype.getCurrentElement = function () { return this._list[this._size - 1] }, Fa.prototype.getSize = function () { return this._size }, Fa.prototype.getDepth = function () { return this._depth }, Fa.prototype.getElements = function () { return this._list }, Fa.prototype.getType = function () { return this._elementType }, Fa.prototype.getId = function () { return this._id }, Fa.prototype.isAnimated = function () { return this._animated }, Fa.prototype.getStencilUsage = function () { return this._stencilUsage }, Fa.prototype.setGlobalAnimation = function (t, e, i) { for (var n = 0; n < this._size; ++n) { var r = this._list[n].animation; r.duration = t, r.beginTime = e, r.easing = i } }, Fa); function Fa() { this._elementType = 1, this._animated = !1, this._size = 0, this._capacity = 128, this._depth = 0, this._id = 0, this._stencilUsage = 1, this._list = Array(this._capacity); for (var t = 0; t < this._capacity; ++t)this._list[t] = dr() } var Ra = (Pa.prototype.reset = function () { this._maps = [] }, Pa.prototype.set = function (t, e, i) { for (var n = t.getId(); this._maps.length <= n;)this._maps.push(new Array(512)); this._maps[n][e] = i }, Pa.prototype.get = function (t, e) { return this._maps[t.getId()][e] }, Pa); function Pa() { this._maps = [] } var Da = { x: 0, y: 0, zoom: 1, angle: 0, width: 80, height: 60, pixelRatio: 1, backgroundColor: null, currentTime: 0, isBufferDisplayable: function () { return !0 }, hideImages: !1, renderBackground: !1 }, za = { webgl: ms, canvas: sa, svg: ba }, Ba = [0, 0, 0, 0], Ua = { webgl: null, svg: null, canvas: null }, Va = (ja.createInitData = function () { var t = {}; for (var e in za) t[e] = za[e].createInitData(); return t }, ja.cacheInitData = function (t) { Ua = t }, ja.getCachedInitData = function () { return Ua }, ja.clearCachedInitData = function () { Ua = { webgl: null, svg: null, canvas: null } }, ja.prototype.addCanvas = function (t) { t.style.touchAction = "none", t.style.msContentZooming = "none", this._resizeCanvas(t), this._additionalCanvases.push(t), this._updateDomElement() }, ja.prototype.removeCanvas = function (t) { t.style.touchAction = "", t.style.msContentZooming = "", k(this._additionalCanvases, t), this._updateDomElement() }, ja.prototype._ensureDomElementsFitParent = function () { if (this._domElement.offsetWidth !== this._view.width || this._domElement.offsetHeight !== this._view.height) { this._domElement.style.width = this._view.width + "px", this._domElement.style.height = this._view.height + "px"; for (var t = 0; t < this._additionalCanvases.length; ++t)this._resizeCanvas(this._additionalCanvases[t]) } }, ja.prototype._ensureCorrectBackgroundColor = function () { this._backgroundColor !== this._view.backgroundColor && (this._domElement.style.backgroundColor = this._view.backgroundColor, this._backgroundColor = this._view.backgroundColor) }, ja.prototype.createBlock = function () { return new Oa }, ja.prototype.parseColor = function (t) { return this._colorManager.parseColor(t) }, ja.prototype.clear = function () { this._blockIdToAddress.fill(0), this._patternManager.reset(), this._boundariesManager.reset(), this._textManager.reset(), this._bufferList.reset(), this._idRecorder.reset() }, ja.prototype.notifyFontsReloaded = function () { this._patternManager.notifyUpdate(), this._textManager.clear(), this._refreshTexts = !0 }, ja.prototype.notifyPatternUpdate = function () { this._patternManager.notifyUpdate() }, ja.prototype.getShapePoints = function (t) { return this._shapeManager.getDefinitionFromName(t).points }, ja.prototype.checkShapeHit = function (t, e, i) { var n = this._shapeManager.getDefinitionFromName(t), r = n.getDistanceFromStrokeVertically, o = n.getDistanceFromStrokeHorizontally; return 0 <= Math.min(r(e, i), o(e, i)) }, ja.prototype.setGlobalBoundaries = function (t) { var e = t.maxBlockId, i = void 0 === e ? 0 : e, n = t.maxScaledSize, r = t.maxMinVisibleSize, o = t.maxSymbolicSize, s = t.maxDashLength, a = t.maxGapLength, u = t.maxPatternScale; return i > this._blockIdToAddress.length && this._resizeBlockArray(i), !!this._boundariesManager.set(t) && (this._memoryManager.resizeBoundaries(n, r, o, s, a, u), !0) }, ja.prototype._resizeBlockArray = function (t) { var e = new Uint32Array(t); e.set(this._blockIdToAddress), this._blockIdToAddress = e }, ja.prototype.registerShape = function (t, e) { this._shapeManager.register(t, e) }, ja.prototype._bindBlock = function (t, e, i, n, r, o, s) { this._checkBlockId(t); var a = this._blockIdToAddress[t], u = this._bufferList.allocateBlock(a, e, i, n, r, o, s); return this._blockIdToAddress[t] = u.address, this._currentDataView = u.buffer.getDataView(), this._currentElementSize = u.buffer.getElementSize(), this._currentBlockOffset = u.offset, this._currentByteOffset = this._currentBlockOffset * this._currentElementSize, this._currentSideDataView = u.buffer.getSideDataView(), this._currentSideElementSize = u.buffer.getTotalSideElementsSize(), this._currentSideByteOffset = this._currentBlockOffset * this._currentSideElementSize, u }, ja.prototype._setItemIndex = function (t) { var e = this._currentBlockOffset + t; this._currentByteOffset = e * this._currentElementSize, this._currentSideByteOffset = e * this._currentSideElementSize }, ja.prototype._freeBlock = function (t) { this._checkBlockId(t); var e = this._blockIdToAddress[t], i = this._bufferList.freeBlock(e); return this._blockIdToAddress[t] = i }, ja.prototype._checkBlockId = function (t) { t >= this._blockIdToAddress.length && this._resizeBlockArray(qe(t + 1)) }, ja.prototype._setTextCharacters = function (t) { this._textManager.storeTextInDataView(this._currentSideDataView, this._currentSideByteOffset, this._currentSideByteOffset + this._currentSideElementSize, t) }, ja.prototype._storeElement = function (t, e) { this._memoryManager.storeGenericObject(this._currentDataView, this._currentByteOffset, t.end), e && (this._memoryManager.storeGenericObject(this._currentDataView, this._currentByteOffset + 52, t.start), this._memoryManager.storeAnimationInformation(this._currentDataView, this._currentByteOffset + 104, t.animation, this._easingManager.getCoefficients(t.animation.easing))) }, ja.prototype.storeBlock = function (t, e) { if (!e || !e.getSize()) return this._freeBlock(t); var i = e.getType(), n = e.getDepth(), r = e.getSize(), o = e.getElements(), s = e.isAnimated(), a = e.getStencilUsage(), u = e.getId(), l = 0; if (2 === i) for (var d = 0; d < r; ++d)(f = o[d]).end.pattern.type === An && (l = Math.max(l, f.end.pattern.attributes.text.length)), s && f.start.pattern.type === An && (l = Math.max(l, f.start.pattern.attributes.text.length)); var h = this._bindBlock(t, i, s, n, r, l, a); for (d = 0; d < r; ++d) { var c = o[d]; this._setItemIndex(d), this._storeElement(c, s), this._idRecorder.set(h.buffer, h.offset + d, u) } if (2 === i) for (d = 0; d < r; ++d) { var f = o[d]; this._setItemIndex(d), this._setTextCharacters(f.end.pattern) } return h.address }, ja.prototype.freeBlock = function (t) { return this._freeBlock(t) }, ja.prototype._refreshTextElements = function () { for (var t = 0, e = this._bufferList.getBuffers(); t < e.length; t++) { var i = e[t]; if (i && 2 === i.getElementType()) { for (var n = i.getSideDataView(), r = i.getTotalSideElementsSize(), o = i.getSize(), s = 0, a = r, u = 0; u < o; ++u) { var l = this._textManager.extractTextFromDataView(n, s, a); this._textManager.storeTextInDataView(n, s, a, l), s = a, a += r } i.triggerUpdate() } } }, ja.prototype._extractElement = function (t, e) { if (!t) return null; var i = this._bufferList.getBlockInfo(t); return this._renderer.extractElement(i.buffer, i.offset + e) }, ja.prototype.extractElement = function (t, e) { return void 0 === e && (e = 0), this._extractElement(t, e) }, ja.prototype.getDomElement = function () { return this._domElement }, ja.prototype.measureText = function (t, e, i, n) { return void 0 === n && (n = 1), this._textManager.measureText(t, e, i, n) }, ja.prototype.setRenderType = function (t) { this._renderType !== t && (this._renderType = t, this._switchMainRenderer = !0) }, ja.prototype._ensureMainRendererReady = function () { if (this._switchMainRenderer) { var t = za[this._renderType]; t && t.isAvailable() || (this._renderType = "canvas"), this._renderer = this._renderersByType[this._renderType], this._renderer || (this._renderer = this._instanciateRenderer(this._renderType), this._renderersByType[this._renderType] = this._renderer), this._updateDomElement() } }, ja.prototype._updateDomElement = function () { for (var t = this._renderer && this._renderer.getDomElement(); this._domElement.firstChild;)this._domElement.removeChild(this._domElement.firstChild); t && this._appendDomChild(t); for (var e = 0; e < this._additionalCanvases.length; ++e)this._appendDomChild(this._additionalCanvases[e]) }, ja.prototype._appendDomChild = function (t) { t.style.position = "absolute", t.style.left = "0", t.style.top = "0", this._domElement.appendChild(t) }, ja.prototype._instanciateRenderer = function (t) { return new (za[t] || cr)({ initData: this._initData[t], bufferList: this._bufferList, shapeManager: this._shapeManager, patternManager: this._patternManager, boundariesManager: this._boundariesManager, textManager: this._textManager, colorManager: this._colorManager, easingManager: this._easingManager, memoryManager: this._memoryManager }) }, ja.prototype.setView = function (t) { this._view = C({}, this._view, t) }, ja.prototype._updateManagers = function () { this._patternManager.setPixelRatio(this._view.pixelRatio), this._shapeManager.update(), this._patternManager.update(), this._textManager.update(), this._boundariesManager.update(), this._bufferList.update(), this._refreshTexts && (this._refreshTexts = !1, this._refreshTextElements()) }, ja.prototype._resizeCanvas = function (t) { hr(t, this._view.width, this._view.height, this._view.pixelRatio) }, ja.prototype.render = function () { this._ensureMainRendererReady(), this._ensureDomElementsFitParent(), this._ensureCorrectBackgroundColor(), this._updateManagers(), this._renderer.renderFrame(this._view) }, ja.prototype.ensureAnimationsReady = function () { this._ensureMainRendererReady(), this._renderer.ensureAnimationsReady() }, ja.prototype.export = function (t, e, i) { var n = this._instanciateRenderer(t), r = C({}, this._view, e); return "setViewportClipping" in n && n.setViewportClipping(!1), r.renderBackground = !0, this._updateManagers(), n.renderFrame(r), n.export(i).then(function () { return n.getDomElement() }) }, ja.prototype.getCurrentTime = function () { return Kt() }, ja.prototype.getImageData = function () { return this._renderer && this._renderer.getImageData() }, ja.prototype.destroy = function () { for (var t = 0, e = Object.keys(this._renderersByType); t < e.length; t++) { var i = e[t], n = this._renderersByType[i]; n && n.destroy() } }, ja.prototype.transparentify = function (t) { var e = this.parseColor(t) || Ba; return "rgba(" + Math.round(255 * e[0]) + "," + Math.round(255 * e[1]) + "," + Math.round(255 * e[2]) + ",0)" }, ja.prototype.initDebugRenderingLoop = function (t) { var e = this, i = void 0 === t ? {} : t, n = i.triggerKey, r = void 0 === n ? "r" : n, o = i.start, s = void 0 === o || o; document.addEventListener("keydown", function (t) { t.key === r && (s = !s) }); var a = function (force) { (s || force) && (e.setView({ currentTime: Kt() }), e.render()), window.requestAnimationFrame(function () { a() }) }; window.requestAnimationFrame(function () { document.body.appendChild(e.getDomElement()), a(!0) }) }, ja); function ja(t) { var e = this; this._view = j(Da), this._domElement = ht ? document.createElement("div") : St(), this._currentDataView = null, this._currentElementSize = 0, this._currentBlockOffset = 0, this._currentByteOffset = 0, this._blockIdToAddress = new Uint32Array(0), this._renderersByType = {}, this._switchMainRenderer = !0, this._renderer = null, this._additionalCanvases = [], this._refreshTexts = !1, this._backgroundColor = null, this._initData = t || {}, this._colorManager = new _n, this._easingManager = new wa, this._patternManager = new Ln, this._shapeManager = new Hn, this._boundariesManager = new Ea, this._textManager = new ss(this._patternManager), this._idRecorder = new Ra, this._memoryManager = new Ca(this._patternManager, this._shapeManager, this._textManager, this._idRecorder, this._easingManager, function (t) { return e.parseColor(t) || Ba }), this._bufferList = new Yn } var Ga, Ha = (b(qa, Ga = jo), Object.defineProperty(qa.prototype, "src", { get: function () { return this._src }, set: function (t) { var e = this; t && (this._src = t, setTimeout(function () { e.onload && e.onload.call(e), e.width = 1, e.height = 1, e.fire("load") }, 10)) }, enumerable: !0, configurable: !0 }), qa.prototype.addEventListener = function (t, e) { this.on(t, e) }, qa); function qa(t, e) { var i = Ga.call(this) || this; return i.isDummy = !0, i.width = 0, i.height = 0, i } var Wa = (Xa.prototype.setImgCrossOrigin = function (t) { this._crossOrigin = t }, Xa.prototype.clear = function () { this._images = {}, this._nbLoaded = 0, this._nbToLoad = 0 }, Xa.prototype.getImage = function (t) { var e, i, n = this, r = this._images[t]; return void 0 === r && (this._nbToLoad += 1, (r = new ("undefined" != typeof Image ? Image : Ha)(e, i)).crossOrigin = this._crossOrigin, r.onload = function () { return n._onImgLoad(t) }, r.onerror = function () { n._onImgLoad(t), n._images[t] = null }, r.src = t, this._images[t] = r), r }, Xa.prototype._onImgLoad = function (e) { this._nbLoaded += 1, this._onFetch.forEach(function (t) { return t(e) }), this._nbLoaded === this._nbToLoad && (this._whenReady.forEach(function (t) { return t() }), this._whenReady = []) }, Xa.prototype.onFetch = function (t) { this._onFetch.push(t) }, Xa.prototype.whenReady = function () { var e = this; return this._nbLoaded === this._nbToLoad ? Promise.resolve() : new Promise(function (t) { return e._whenReady.push(t) }) }, Xa.prototype.destroy = function () { this._whenReady = [], this._onFetch = [] }, Xa); function Xa() { this._images = {}, this._crossOrigin = "anonymous", this._whenReady = [], this._onFetch = [], this._nbLoaded = 0, this._nbToLoad = 0 } function Ya(t, e, i, n, r, o, s, a, u) { void 0 === a && (a = 0), void 0 === u && (u = !1); var l = distance(i, n, r, o), d = (s / 2 * (u ? distance(t, e, r, o) / l : 1) + a) / l, h = (r - i) * d, c = (o - n) * d, f = i + c, g = n - h, p = t - f, _ = e - g, v = i - c - f, m = n + h - g, y = r + c - f, b = o - h - g, x = p * v + _ * m, E = p * y + _ * b; return 0 < x && x < v * v + m * m && 0 < E && E < y * y + b * b } function Za(t, e) { return t.x === e.x && t.y === e.y } function Ka(t, e, i, n) { return Math.atan2(n - e, i - t) } function Qa(t, e, i, n, r, o, s, a) { var u = t - i, l = e - n, d = r - s, h = o - a, c = u * h - d * l, f = (l * (t - r) - u * (e - o)) / c; if (f < 0 || 1 < f) return null; var g = (d * (o - e) + h * (t - r)) / c; return 0 <= g && g <= 1 ? { x: t - g * u, y: e - g * l } : null } function Ja(t, e, i, n, r, o, s, a) { var u, l = []; return (u = Qa(t, e, i, n, r, o, r, a)) && l.push(u), (u = Qa(t, e, i, n, r, a, s, a)) && l.push(u), (u = Qa(t, e, i, n, s, a, s, o)) && l.push(u), (u = Qa(t, e, i, n, s, o, r, o)) && l.push(u), l } function $a(t, e, i, n, r, o, s, a) { var u = ((s - r) * (e - o) - (a - o) * (t - r)) / ((a - o) * (i - t) - (s - r) * (n - e)), l = ((i - t) * (e - o) - (n - e) * (t - r)) / ((a - o) * (i - t) - (s - r) * (n - e)); return 0 <= u && u <= 1 && 0 <= l && l <= 1 } function tu(t, e, i, n, r, o, s, a) { return r <= t && o <= e && t <= s && e <= a || (r <= i && o <= n && i <= s && n <= a || (!!$a(t, e, i, n, r, o, r, a) || (!!$a(t, e, i, n, s, o, s, a) || (!!$a(t, e, i, n, r, o, s, o) || !!$a(t, e, i, n, r, a, s, a))))) } function eu(t, e, i) { return Math.sqrt(iu(t.x, t.y, e.x, e.y, i.x, i.y)) } function iu(t, e, i, n, r, o) { var s = da(i, n, r, o); if (0 === s) return da(t, e, i, n); var a = ((t - i) * (r - i) + (e - n) * (o - n)) / s; return da(t, e, i + (a = Math.max(0, Math.min(1, a))) * (r - i), n + a * (o - n)) } function nu(t, e, i, n, r, o) { var s = r - i, a = o - n; if (0 == s && 0 == a) return { x: i, y: n }; var u = ((t - i) * s + (e - n) * a) / (s * s + a * a); return u < 0 ? { x: i, y: n } : 1 < u ? { x: r, y: o } : { x: i + u * s, y: n + u * a } } var ru = 1e-6, ou = 1e-12; function su() { for (var t = arguments, e = t.length - 1, i = e, n = [], r = 0; r <= e && Math.abs(t[r]) <= ou; r++)e--; switch (e) { case 1: !function (t, e, i) { void 0 === i && (i = []); 0 !== e && i.push(-t / e) }(t[i], t[i - 1], n); break; case 2: !function (t, e, i, n) { void 0 === n && (n = []); var r = e / i, o = r * r - t / i * 4; if (0 < o) { var s = Math.sqrt(o); n.push(.5 * (-r + s)), n.push(.5 * (-r - s)) } else 0 == o && n.push(.5 * -r) }(t[i], t[i - 1], t[i - 2], n); break; case 3: !function (t, e, i, n, r) { void 0 === r && (r = []); var o, s, a = i / n, u = e / n, l = (3 * u - a * a) / 3, d = (2 * a * a * a - 9 * u * a + t / n * 27) / 27, h = a / 3, c = d * d / 4 + l * l * l / 27, f = d / 2; Math.abs(c) <= ru && (c = 0); if (0 < c) { var g = Math.sqrt(c); s = 0 <= (o = -f + g) ? Math.pow(o, 1 / 3) : -Math.pow(-o, 1 / 3), 0 <= (o = -f - g) ? s += Math.pow(o, 1 / 3) : s -= Math.pow(-o, 1 / 3), r.push(s - h) } else if (c < 0) { var distance = Math.sqrt(-l / 3), p = Math.atan2(Math.sqrt(-c), -f) / 3, _ = Math.cos(p), v = Math.sin(p), m = Math.sqrt(3); r.push(2 * distance * _ - h), r.push(-distance * (_ + m * v) - h), r.push(-distance * (_ - m * v) - h) } else o = 0 <= f ? -Math.pow(f, 1 / 3) : Math.pow(-f, 1 / 3), r.push(2 * o - h), r.push(-o - h) }(t[i], t[i - 1], t[i - 2], t[i - 3], n) }return n } function au(t, e, i, n, r, o, s, a, u, l, d) { var h, c, f = Math.min(s, u), g = Math.min(a, l), p = Math.max(s, u), _ = Math.max(a, l); for (var v = su((h = a - l) * (t + -2 * i + r) + (c = u - s) * (e + -2 * n + o), h * (-2 * t + 2 * i) + c * (-2 * e + 2 * n), h * t + c * e + (s * l - u * a)), m = 0; m < v.length; m++) { var y = v[m]; if (0 <= y && y <= 1) { var b = t + (i - t) * y, x = e + (n - e) * y, E = b + (i + (r - i) * y - b) * y, A = x + (n + (o - n) * y - x) * y; if (s === u) { if (g <= A && A <= _) { if (!d) return 1; d.push(E, A) } } else if (a === l) { if (f <= E && E <= p) { if (!d) return 1; d.push(E, A) } } else if (f <= E && g <= A && E <= p && A <= _) { if (!d) return 1; d.push(E, A) } } } return d ? d.length / 2 : 0 } function uu(t, e, i, n, r, o, s, a, u, l, d) { return d ? (au(t, e, i, n, r, o, s, a, u, a, d), au(t, e, i, n, r, o, u, a, u, l, d), au(t, e, i, n, r, o, s, l, u, l, d), au(t, e, i, n, r, o, s, a, s, l, d), d.length / 2) : s <= t && t <= u && a <= e && e <= l ? 1 : s <= r && r <= u && a <= o && o <= l ? 1 : au(t, e, i, n, r, o, s, a, u, a) ? 1 : au(t, e, i, n, r, o, u, a, u, l) ? 1 : au(t, e, i, n, r, o, s, l, u, l) ? 1 : au(t, e, i, n, r, o, s, a, s, l) ? 1 : 0 } function lu(t, e, i, n, r, o, s, a, u, l, d, h, c) { var f, g, p = Math.min(u, d), _ = Math.min(l, h), v = Math.max(u, d), m = Math.max(l, h); for (var y = su((f = l - h) * (-1 * t + 3 * i + -3 * r + s) + (g = d - u) * (-1 * e + 3 * n + -3 * o + a), f * (3 * t + -6 * i + 3 * r) + g * (3 * e + -6 * n + 3 * o), f * (-3 * t + 3 * i) + g * (-3 * e + 3 * n), f * t + g * e + (u * h - d * l)), b = 0; b < y.length; b++) { var x = y[b]; if (0 <= x && x <= 1) { var E = t + (i - t) * x, A = e + (n - e) * x, S = i + (r - i) * x, w = n + (o - n) * x, T = E + (S - E) * x, C = A + (w - A) * x, M = T + (S + (r + (s - r) * x - S) * x - T) * x, I = C + (w + (o + (a - o) * x - w) * x - C) * x; if (u === d) { if (_ <= I && I <= m) { if (!c) return 1; c.push(M, I) } } else if (l === h) { if (p <= M && M <= v) { if (!c) return 1; c.push(M, I) } } else if (p <= M && _ <= I && M <= v && I <= m) { if (!c) return 1; c.push(M, I) } } } return c ? c.length / 2 : 0 } function du(t, e, i, n, r, o, s, a, u, l, d, h, c) { return c ? (lu(t, e, i, n, r, o, s, a, u, l, d, l, c), lu(t, e, i, n, r, o, s, a, d, l, d, h, c), lu(t, e, i, n, r, o, s, a, u, h, d, h, c), lu(t, e, i, n, r, o, s, a, u, l, u, h, c), c.length / 2) : u <= t && t <= d && l <= e && e <= h ? 1 : u <= s && s <= d && l <= a && a <= h ? 1 : lu(t, e, i, n, r, o, s, a, u, l, d, l) ? 1 : lu(t, e, i, n, r, o, s, a, d, l, d, h) ? 1 : lu(t, e, i, n, r, o, s, a, u, h, d, h) ? 1 : lu(t, e, i, n, r, o, s, a, u, l, u, h) ? 1 : 0 } function hu(t, e, i, n, r, o, s, a) { return void 0 === a && (a = { x: 0, y: 0 }), a.x = (1 - t) * (1 - t) * e + 2 * (1 - t) * t * o + t * t * n, a.y = (1 - t) * (1 - t) * i + 2 * (1 - t) * t * s + t * t * r, a } function cu(t, e, i, n, r, o, s, a, u, l, d) { void 0 === l && (l = 0), void 0 === d && (d = !1); var h = i - 2 * s + r, c = n - 2 * a + o, f = -((i - t) * c - (n - e) * h) / ((2 * s - 2 * i) * c - (2 * a - 2 * n) * h); if (f < 0 || 1 < f) return !1; var g = u / 2; return d && (g *= 1 - f), g += l, distance(Js(i, s, r, f), Js(n, a, o, f), t, e) <= g } function fu(t, e, i, n, r, o, s, a, u, l) { void 0 === l && (l = { x: 0, y: 0 }); var d = (1 - t) * (1 - t) * (1 - t), h = 3 * t * (1 - t) * (1 - t), c = 3 * t * t * (1 - t), f = t * t * t; return l.x = d * e + h * o + c * a + f * n, l.y = d * i + h * s + c * u + f * r, l } function gu(t, e, i, n, r, o, s, a, u, l, d, h) { var c = distance(i, n, s, a); if (Math.abs(t - i) > c || Math.abs(e - n) > c) return !1; for (var f, g = .5, p = distance(t, e, i, n) < distance(t, e, r, o) ? -.01 : .01, _ = 100, v = fu(g, i, n, r, o, s, a, u, l), m = distance(t, e, v.x, v.y), y = d / 2 + h; 0 < _-- && 0 <= g && g <= 1 && y < m && (.001 < p || p < -.001);)f = m, fu(g, i, n, r, o, s, a, u, l, v), f < (m = distance(t, e, v.x, v.y)) ? g += p = -p / 2 : g + p < 0 || 1 < g + p ? (p /= 2, m = f) : g += p; return m < y } function pu(t, e, i, n, r, o, s) { void 0 === s && (s = Bo()); var a = t + 2 / 3 * (i - t), u = e + 2 / 3 * (n - e); return _u(t, e, a, u, a + 1 / 3 * (r - t), u + 1 / 3 * (o - e), r, o, s) } function _u(t, e, i, n, r, o, s, a, u) { void 0 === u && (u = Bo()); var l, d, h, c, f, g = Math.min, p = Math.max, _ = Math.sqrt; u.minX = g(t, s), u.maxX = p(t, s), u.minY = g(e, a), u.maxY = p(e, a); for (var v = void 0, m = void 0, y = void 0, b = void 0, x = void 0, E = void 0, A = void 0, S = 0; S < 2; ++S)if (f = 0 === S ? (d = t, h = i, c = r, s) : (d = e, h = n, c = o, a), m = 6 * d - 12 * h + 6 * c, v = -3 * d + 9 * h - 9 * c + 3 * f, y = 3 * h - 3 * d, m |= 0, y |= 0, 0 !== (v |= 0)) (x = m * m - 4 * y * v) < 0 || (0 < (E = (-m + _(x)) / (2 * v)) && E < 1 && (l = vu(E, d, h, c, f), 0 === S ? (u.minX = g(u.minX, l), u.maxX = p(u.maxX, l)) : (u.minY = g(u.minY, l), u.maxY = p(u.maxY, l))), 0 < (A = (-m - _(x)) / (2 * v)) && A < 1 && (l = vu(A, d, h, c, f), 0 === S ? (u.minX = g(u.minX, l), u.maxX = p(u.maxX, l)) : (u.minY = g(u.minY, l), u.maxY = p(u.maxY, l)))); else { if (0 === m) continue; 0 < (b = -y / m) && b < 1 && (l = vu(b, d, h, c, f), 0 === S ? (u.minX = g(u.minX, l), u.maxX = p(u.maxX, l)) : (u.minY = g(u.minY, l), u.maxY = p(u.maxY, l))) } return u } function vu(t, e, i, n, r) { return Math.pow(1 - t, 3) * e + 3 * Math.pow(1 - t, 2) * t * i + 3 * (1 - t) * Math.pow(t, 2) * n + Math.pow(t, 3) * r } var mu = { left: { x: -1, y: 0 }, right: { x: 1, y: 0 }, top: { x: 0, y: -1 }, bottom: { x: 0, y: 1 }, center: { x: 0, y: 0 } }; var yu = (bu.prototype.getDefinition = function () { return this._attributesManager.getAttributeLayerDefinition(this._id) }, bu.prototype.update = function (t) { this._attributesManager.updateAttributeLayer(this._id, t) }, bu.prototype.destroy = function () { this._attributesManager.destroyAttributeLayer(this._id) }, bu.prototype.updateElements = function (t) { this._attributesManager.updateElementsForAttributeLayer(this._id, t) }, bu.prototype.updateAll = function () { this._attributesManager.updateAllForAttributeLayer(this._id) }, bu.prototype.setAttributeValues = function (t, e, i) { this._attributesManager.setAttributeLayerValues(this._id, t, e, i) }, bu.prototype.getUsedAttributeNames = function (t) { return this._attributesManager.getUsedAttributeLayerAttributes(this._id, t) }, bu.prototype.getFlexArrays = function () { return this._attributesManager.getAttributeLayerFlexArrays(this._id) }, bu); function bu(t, e) { this._attributesManager = t, this._id = e } var xu = { storage: 1, default: 0 }, Eu = (Au.prototype._getAllIndexes = function () { for (var t = this._isNode ? this._graph.getNodeMaxIndex() : this._graph.getEdgeMaxIndex(), e = new Uint32Array(t), i = 1; i <= t; ++i)e[i - 1] = i; return e }, Au.prototype.addAll = function () { this._all = !0 }, Au.prototype.add = function (t) { if (!this._all) for (var e = 0; e < t._indexes.length; e++) { var i = t._indexes[e]; this._addIndex(i) } }, Au.prototype._addIndex = function (t) { 0 === this._flexArray.get(t) && (this._flexArray.set(t, 1), this._indexList.push(t)) }, Au.prototype.isEmpty = function () { return !this._all && this._indexList.isEmpty() }, Au.prototype.isFull = function () { return this._all }, Au.prototype.getListAndClear = function () { var t = this.getList(); return this.clear(), t }, Au.prototype.getList = function () { var t = null; if (this._all && !this._includeRemovedElements) t = this._isNode ? this._graph.getNodes("all") : this._graph.getEdges("all"); else { var e = this._all ? this._getAllIndexes() : this._indexList.slice(); t = this._eltList(e) } return t }, Au.prototype.clear = function () { this._all = !1, this._indexList.isEmpty() || (this._indexList.reset(), this._flexArray.reset()) }, Au.prototype.addSet = function (t) { if (t._all) this.addAll(); else for (var e = t._indexList.getBuffer(), i = t._indexList.getLength(), n = 0; n < i; ++n)this._addIndex(e[n]) }, Au); function Au(t) { var e = t.graph, i = t.isNode, n = t.includeRemovedElements; this._all = !1, this._isNode = i, this._graph = e, this._includeRemovedElements = n, this._eltList = i ? this._graph.nodeList : this._graph.edgeList, this._flexArray = i ? this._graph.createNodeAttribute(xu) : this._graph.createEdgeAttribute(xu), this._all = !1, this._indexList = this._graph.createIndexList(i) } function Su(t) { return "string" == typeof t } function wu(t, e) { return t ? t + "." + e : e } function Tu(t) { return "boolean" == typeof t || 0 === t || 1 === t ? t : void 0 } function Cu(t) { return "number" == typeof t && isFinite(t) ? t : void 0 } function Mu(t) { return "number" == typeof t && isFinite(t) && 0 <= t ? t : void 0 } var Iu = -1, Lu = new Function("x", "return (typeof x === 'number' && isFinite(x) && x % 1 === 0 && x >= " + Iu + " && x <= 4) ? x : undefined;"); function Nu(t) { return null === t || "string" == typeof t || "number" == typeof t ? t : void 0 } function ku(t) { return "fixed" === t || "scaled" === t ? t : void 0 } function Ou(t, e) { return e.parseColor(t) ? t : void 0 } function Fu(t, e) { return "inherit" === t || e.parseColor(t) ? t : void 0 } function Ru(t) { return null === t ? null : "string" == typeof t ? t.split(",").map(function (t) { var e = t.trim(), i = -1 !== e.indexOf(" "), n = e[0]; return i && '"' !== n && "'" !== n ? '"' + e + '"' : e }).join(",") : void 0 } function Pu(t) { return "none" === t ? "normal" : "normal" === t || "italic" === t || "bold" === t || "italic bold" === t ? t : void 0 } function Du(t) { return "left" === t || "center" === t ? t : void 0 } function zu(t) { return [null, "arrow", "circle-hole-arrow", "triangle-hole-arrow", "short-arrow", "sharp-arrow", "circle", "square"].includes(t) ? t : void 0 } function Bu(t) { return new Function("x", ["if (typeof x === 'number') { return (typeof x === 'number' && isFinite(x) && x >= 0) ? x : undefined; }", "else if (typeof x !== 'string' || x.charAt(x.length - 1) !== '%') { return undefined; }", "else { var p = parseFloat(x); return isNaN(p) ? undefined : (" + t + " * p / 100); }"].join("\n")) } function Uu(t) { return { _check: Nu, _set: new Function("flexArrays", "index", "value", ["flexArrays.badges." + t + ".text.content.set(index, value);", "if (value === null || value === undefined) flexArrays.badges." + t + ".image.url.set(index, value);"].join("\n")), _get: new Function("flexArrays", "index", "return flexArrays.badges." + t + ".text.content.get(index);"), color: { _flexArray: "white", _check: Fu }, scale: { _flexArray: .45, _check: Bu(.45) }, positionScale: { _flexArray: 1, _check: Mu }, minVisibleSize: { _flexArray: 12, _check: Bu(12) }, image: { _alias: "badges." + t + ".image.url", url: { _flexArray: null, _check: Nu }, scale: { _flexArray: 1, _check: Bu(1) } }, stroke: { color: { _flexArray: "black", _check: Fu }, width: { _flexArray: 2, _check: Bu(2) }, scalingMethod: { _flexArray: "fixed", _check: ku } }, text: { _alias: "badges." + t + ".text.content", content: { _flexArray: null, _check: Nu }, color: { _flexArray: "black", _check: Fu }, font: { _flexArray: "Arial", _check: Ru }, style: { _flexArray: "normal", _check: Pu }, scale: { _flexArray: .5, _check: Bu(.5) } }, threshold: "badges." + t + ".minVisibleSize" } } var Vu = { _check: Tu, _get: function (t, e) { return 0 === t.opacity.get(e) }, _set: function (t, e, value) { t.opacity.set(e, void 0 === value ? void 0 : +!value) } }, ju = { x: { _flexArray: 0, _check: Cu, _disableMemoryOptimization: !0 }, y: { _flexArray: 0, _check: Cu, _disableMemoryOptimization: !0 }, radius: { _flexArray: 5, _check: Bu(5) }, scalingMethod: { _flexArray: "scaled", _check: ku }, color: { _flexArray: "grey", _check: function (t, e) { if (e.parseColor(t)) return t; if (Array.isArray(t)) { if (t.length < 1) return; for (var i = 0; i < t.length; ++i)if (!e.parseColor(t[i])) return; return t } } }, opacity: { _flexArray: 1, _check: Mu }, hidden: Vu, shape: { _flexArray: "circle", _check: function (t) { return "equilateral" === t ? "pentagon" : "circle" === t || "square" === t || "cross" === t || "diamond" === t || "pentagon" === t || "star" === t ? t : void 0 } }, layer: { _flexArray: 0, _check: Lu }, detectable: { _flexArray: !0, _check: Tu }, draggable: { _flexArray: !0, _check: Tu }, layoutable: { _flexArray: !0, _check: Tu }, innerStroke: { _alias: "innerStroke.color", width: { _flexArray: 2, _check: Bu(2) }, scalingMethod: { _flexArray: "fixed", _check: ku }, color: { _flexArray: "white", _check: Fu }, minVisibleSize: { _flexArray: 12, _check: Bu(12) }, threshold: "innerStroke.minVisibleSize" }, outerStroke: { _alias: "outerStroke.color", width: { _flexArray: 5, _check: Bu(5) }, scalingMethod: { _flexArray: "fixed", _check: ku }, color: { _flexArray: null, _check: Fu }, minVisibleSize: { _flexArray: 0, _check: Bu(0) }, threshold: "outerStroke.minVisibleSize" }, badges: { _check: function (t) { return null === t ? t : void 0 }, _set: function (t, e, value) { t.badges.topLeft.text.content.set(e, value), t.badges.topLeft.image.url.set(e, value), t.badges.topRight.text.content.set(e, value), t.badges.topRight.image.url.set(e, value), t.badges.bottomLeft.text.content.set(e, value), t.badges.bottomLeft.image.url.set(e, value), t.badges.bottomRight.text.content.set(e, value), t.badges.bottomRight.image.url.set(e, value) }, topLeft: Uu("topLeft"), topRight: Uu("topRight"), bottomLeft: Uu("bottomLeft"), bottomRight: Uu("bottomRight") }, halo: { _alias: "halo.color", color: { _flexArray: null, _check: Ou }, width: { _flexArray: 50, _check: Bu(50) }, scalingMethod: { _flexArray: "fixed", _check: ku }, strokeColor: { _flexArray: null, _check: Ou }, strokeWidth: { _flexArray: 1, _check: Bu(1) }, clustering: { _flexArray: !1, _check: Tu }, hideNonAdjacentEdges: { _flexArray: !1, _check: Tu }, size: "halo.width" }, pulse: { enabled: { _flexArray: !1, _check: Tu }, duration: { _flexArray: 1e3, _check: Mu }, interval: { _flexArray: 800, _check: Mu }, startColor: { _flexArray: "rgba(0, 0, 0, 0.6)", _check: Fu }, endColor: { _flexArray: "rgba(0, 0, 0, 0)", _check: Fu }, width: { _flexArray: 50, _check: Mu }, startRatio: { _flexArray: 1, _check: Mu }, endRatio: { _flexArray: 2, _check: Mu } }, icon: { _alias: "icon.content", content: { _flexArray: null, _check: Nu }, font: { _flexArray: "Arial", _check: Ru }, color: { _flexArray: "black", _check: Ou }, scale: { _flexArray: .7, _check: Bu(.7) }, style: { _flexArray: "normal", _check: Pu }, minVisibleSize: { _flexArray: 12, _check: Bu(12) }, threshold: "icon.minVisibleSize" }, image: { _alias: "image.url", url: { _flexArray: null, _check: Nu }, scale: { _flexArray: 1, _check: Bu(1) }, fit: { _flexArray: !0, _check: Tu }, tile: { _flexArray: !1, _check: Tu }, minVisibleSize: { _flexArray: 12, _check: Bu(12) }, rescale: "image.fit", duplicate: "image.tile", threshold: "image.minVisibleSize" }, outline: { _alias: "outline.enabled", enabled: { _flexArray: !1, _check: Tu }, color: { _flexArray: "rgba(0, 0, 0, 0.36)", _check: Ou }, minVisibleSize: { _flexArray: 12, _check: Bu(12) } }, text: { _alias: "text.content", content: { _flexArray: null, _check: Nu }, font: { _flexArray: "Arial", _check: Ru }, color: { _flexArray: "black", _check: Fu }, size: { _flexArray: 12, _check: Bu(12) }, scale: { _flexArray: .1, _check: Mu }, style: { _flexArray: "normal", _check: Pu }, align: { _flexArray: "center", _check: Du }, margin: { _flexArray: 10, _check: Bu(10) }, padding: { _flexArray: 2, _check: Bu(2) }, backgroundColor: { _flexArray: null, _check: Fu }, tip: { _flexArray: !0, _check: Tu }, minVisibleSize: { _flexArray: 24, _check: Bu(24) }, scaling: { _flexArray: !1, _check: Tu }, position: { _flexArray: "bottom", _check: function (t) { return "top" === t || "bottom" === t || "left" === t || "right" === t || "center" === t ? t : void 0 } }, maxLineLength: { _flexArray: 0, _check: Mu }, truncateLength: { _flexArray: 0, _check: Mu }, backgroundArrowBaseSize: "text.margin", backgroundMargin: "text.padding", threshold: "text.minVisibleSize", secondary: { _alias: "text.secondary.content", content: { _flexArray: null, _check: Nu }, font: { _flexArray: "Arial", _check: Ru }, color: { _flexArray: "black", _check: Fu }, size: { _flexArray: 10, _check: Bu(10) }, scale: { _flexArray: .08, _check: Mu }, style: { _flexArray: "normal", _check: Pu }, align: { _flexArray: "center", _check: Du }, margin: { _flexArray: 5, _check: Bu(5) }, padding: { _flexArray: 2, _check: Bu(2) }, backgroundColor: { _flexArray: null, _check: Fu }, minVisibleSize: { _flexArray: 24, _check: Bu(24) }, backgroundArrowBaseSize: "text.secondary.margin", backgroundMargin: "text.secondary.padding", threshold: "text.secondary.minVisibleSize" } } }; var Gu = { width: { _flexArray: 1, _check: Bu(1) }, scalingMethod: { _flexArray: "scaled", _check: ku }, color: { _flexArray: "grey", _check: function (t, e) { return "source" === t || "target" === t || e.parseColor(t) ? t : void 0 } }, opacity: { _flexArray: 1, _check: Mu }, hidden: Vu, minVisibleSize: { _flexArray: 0, _check: Mu }, threshold: "minVisibleSize", layer: { _flexArray: 0, _check: Lu }, detectable: { _flexArray: !0, _check: Tu }, curvature: { _flexArray: 0, _check: Cu }, adjustAnchors: { _flexArray: !0, _check: Tu }, shape: { _check: function (t) { return ["line", "tapered", "arrow", "dashed", "dotted"].includes(t) ? t : void 0 }, _set: function (t, e, value) { var i = void 0, n = void 0, r = void 0, o = void 0; "line" === value ? (i = "line", n = "plain", o = r = null) : "arrow" === value ? (i = "line", n = "plain", r = "arrow", o = null) : "tapered" === value ? (i = "triangle", n = "plain", o = r = null) : "dashed" === value ? (i = "line", n = "dashed", o = r = null) : "dotted" === value && (i = "line", n = "dotted", o = r = null), t.shape.type.set(e, i), t.shape.style.set(e, n), t.shape.head.set(e, r), t.shape.tail.set(e, o) }, type: { _flexArray: "line", _check: function (t) { return "line" === t || "triangle" === t ? t : void 0 } }, head: { _flexArray: null, _check: zu }, tail: { _flexArray: null, _check: zu }, style: { _flexArray: "plain", _check: function (t) { return "plain" === t || "dashed" === t || "dotted" === t ? t : void 0 } } }, stroke: { color: { _flexArray: "inherit", _check: Fu }, width: { _flexArray: 0, _check: Bu(0) }, scalingMethod: { _flexArray: "fixed", _check: ku }, minVisibleSize: { _flexArray: 0, _check: Mu } }, strokeWidth: "stroke.width", halo: { _alias: "halo.color", color: { _flexArray: null, _check: Ou }, width: { _flexArray: 10, _check: Bu(10) }, scalingMethod: { _flexArray: "fixed", _check: ku }, size: "halo.width" }, pulse: { enabled: { _flexArray: !1, _check: Tu }, duration: { _flexArray: 1e3, _check: Mu }, interval: { _flexArray: 800, _check: Mu }, startColor: { _flexArray: "rgba(0, 0, 0, 0.6)", _check: Fu }, endColor: { _flexArray: "rgba(0, 0, 0, 0)", _check: Fu }, width: { _flexArray: 10, _check: Mu }, startRatio: { _flexArray: 1, _check: Mu }, endRatio: { _flexArray: 2, _check: Mu } }, outline: { _alias: "outline.enabled", enabled: { _flexArray: !1, _check: Tu }, color: { _flexArray: "rgba(0, 0, 0, 0.36)", _check: Ou }, minVisibleSize: { _flexArray: 0, _check: Mu } }, text: { _alias: "text.content", content: { _flexArray: null, _check: Nu }, font: { _flexArray: "Arial", _check: Ru }, color: { _flexArray: "black", _check: Ou }, size: { _flexArray: 12, _check: Bu(12) }, scale: { _flexArray: 1, _check: Mu }, style: { _flexArray: "normal", _check: Pu }, align: { _flexArray: "center", _check: Du }, margin: { _flexArray: 2, _check: Bu(2) }, padding: { _flexArray: 2, _check: Bu(2) }, backgroundColor: { _flexArray: null, _check: Fu }, minVisibleSize: { _flexArray: 4, _check: Mu }, threshold: "text.minVisibleSize", adjustAngle: { _flexArray: !0, _check: Tu }, scaling: { _flexArray: !1, _check: Tu }, maxLineLength: { _flexArray: 0, _check: Mu }, secondary: { _alias: "text.secondary.content", content: { _flexArray: null, _check: Nu }, font: { _flexArray: "Arial", _check: Ru }, color: { _flexArray: "black", _check: Ou }, size: { _flexArray: 12, _check: Bu(12) }, scale: { _flexArray: .8, _check: Mu }, style: { _flexArray: "normal", _check: Pu }, align: { _flexArray: "center", _check: Du }, margin: { _flexArray: 2, _check: Bu(2) }, padding: { _flexArray: 2, _check: Bu(2) }, backgroundColor: { _flexArray: null, _check: Fu }, minVisibleSize: { _flexArray: 4, _check: Mu }, threshold: "text.secondary.minVisibleSize" } } }; function Hu() { } function qu() { } function Wu(t, e) { if (!t._check) throw new Error("error somewhere for " + e); return { check: t._check, set: new Function("flexArrays", "index", "value", "flexArrays." + e + ".set(index, value);"), get: new Function("flexArrays", "index", "return flexArrays." + e + ".get(index);"), nested: {} } } function Xu(t, e, i) { if (void 0 !== (e = e || t)._flexArray) return Wu(e, i); var n = { check: null, get: null, set: null, nested: null }; if (Su(e) || e._alias) { var r = Su(e) ? e : e._alias; n = Wu(l = H(t, r), r) } else { if (e._set ? (n.set = e._set, n.check = e._check) : (n.set = Hu, n.check = qu), e._get) n.get = e._get; else { var o = "return " + function t(e, i) { if (void 0 !== e._flexArray) return "flexArrays." + i + ".get(index)"; for (var n = [], r = 0, o = Object.keys(e); r < o.length; r++) { var s = o[r], a = e[s]; if (!s.startsWith("_") && J(a)) { var u = t(e[s], wu(i, s)); u && n.push(s + ": " + u) } } return n.length ? "{\n" + n.join(",\n").split("\n").map(function (t) { return "  " + t }).join("\n") + "\n}" : "" }(e, i) + ";"; n.get = new Function("flexArrays", "index", o) } n.nested = {} } if (!Su(e)) for (var s = 0, a = Object.keys(e); s < a.length; s++) { var u = a[s], l = e[u]; u.startsWith("_") || (n.nested[u] = Xu(t, l, wu(i, u))) } return n } function Yu(t) { return t } function Zu(t) { return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) } var Ku = Xu(ju), Qu = Xu(Gu), Ju = { name: "animationStart", storage: 32, default: 0 }, $u = { name: "animationDuration", storage: 16, default: 0 }, tl = { name: "animationEasing", storage: "resource", default: "linear" }, el = { self: { attributes: "all", tags: [], selection: !0, hover: !1, data: !0 }, adjacentNodes: { attributes: "all", tags: [], selection: !0, hover: !1, data: !0 }, adjacentEdges: { attributes: "all", tags: [], selection: !0, hover: !1, data: !0 }, allNodes: null, allEdges: null }, il = { self: { attributes: "all", tags: [], selection: !0, hover: !1, data: !0 }, extremities: { attributes: "all", tags: [], selection: !0, hover: !1, data: !0 }, parallelEdges: { attributes: "all", tags: [], selection: !0, hover: !1, data: !0 }, allNodes: null, allEdges: null }, nl = { x: 1, y: 1, radius: 1, "halo.hideNonAdjacentEdges": 1 }, rl = Object.freeze({ __proto__: null, linear: Yu, quadraticIn: function (t) { return t * t }, quadraticOut: function (t) { return t * (2 - t) }, quadraticInOut: Zu, cubicIn: function (t) { return t * t * t }, cubicOut: function (t) { return --t * t * t + 1 }, cubicInOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) } }), ol = "_visible", sl = "_data", al = "_hovered", ul = "_hoverExtremityHighlighted", ll = "_selected", dl = "_selectionExtremityHighlighted", hl = "_dragged", cl = "_rewirable", fl = "_export", gl = "_faded", pl = "_transparent", _l = [ll, hl, dl, al, ul, cl, fl, gl, pl], vl = ["hover", "zoom", "panning", "rotation", "gesture", "drag", "selection", "tooltip", "user", "interactions", "resizing", "rewiring", "connectNodes", "lasso"]; function ml(t, e) { return "node" === t.type ? { attributes: yl(t), tags: e ? [e] : [] } : { attributes: yl(t), tags: e ? [e] : [] } } function yl(t) { var value, e, i = null; return void 0 === t.output ? ("function" == typeof t.attributes && (i = "all"), J(t.attributes) && (i = Y(t.attributes))) : i = t.output.attributes, "node" === t.type ? (value = i, e = t.allAttributePaths, wl(value, e)) : wl(i, t.allAttributePaths) } function bl(t, e, i, n, r, o) { !function (t, e, i, n) { if (i < n) for (var r = 0, o = e.attributes; r < o.length; r++)for (var s = o[r], a = 0, u = t.attributes; a < u.length; a++) { if (u[a] === s) return !0 } for (var l = 0, d = e.tags; l < d.length; l++)for (var h = d[l], c = 0, f = t.tags; c < f.length; c++) { if (h === f[c]) return !0 } return !1 }(i, n, r, o) || t.push(e) } function xl(t) { var e = t.dependencies; void 0 === e ? e = el : J(e) || (e = {}); var i = Z(t.attributes).some(function (value) { return "function" == typeof value }), n = t.selector && !t.standaloneSelector, r = i || n, o = e.adjacentEdges; return !o && e.adjacentNodes && (o = !0), { self: Al(e.self, r, t.allAttributePaths), adjacentNodes: Al(e.adjacentNodes, r, t.allAttributePaths), adjacentEdges: Al(o, r, t.allAttributePaths), allNodes: Al(e.allNodes, r, t.allAttributePaths), allEdges: Al(e.allEdges, r, t.allAttributePaths) } } function El(t) { var e = t.dependencies; void 0 === e ? e = il : J(e) || (e = {}); var i = Z(t.attributes).some(function (value) { return "function" == typeof value }), n = t.selector && !t.standaloneSelector, r = i || n; return { self: Al(e.self, r, t.allAttributePaths), extremities: Al(e.extremities, r, t.allAttributePaths), parallelEdges: Al(e.parallelEdges, r, t.allAttributePaths), allNodes: Al(e.allNodes, r, t.allAttributePaths), allEdges: Al(e.allEdges, r, t.allAttributePaths) } } function Al(t, e, i) { if (!e) return { attributes: [], tags: [] }; if (!0 === t) return { attributes: [], tags: [ol] }; var value, n = { attributes: wl((t = t || {}).attributes, i), tags: (value = t.tags, Array.isArray(value) ? value.filter(Su) : []) }; return t.data && n.tags.push(sl), t.selection && n.tags.push(ll), t.hover && n.tags.push(al), n } function Sl(t) { return Array.isArray(t) ? t.join(".") : t } function wl(value, t) { if ("all" === value) return t.slice(); if (!Array.isArray(value)) return []; var i = function (value) { return value.map(Sl).filter(Su) }(value); return t ? t.filter(function (e) { return i.some(function (t) { return e.startsWith(t) }) }) : i } var Tl = (Cl.prototype.clear = function () { this._elementsToRedraw.clear(), this._elementsUpdated.clear(), this._updatedAttributes.clear(), this._updatedAttributesTmp.clear() }, Cl.prototype.getAttributeFlexArrays = function () { return this._finalFlexArraysWrapped }, Cl.prototype.getPrevAttributeFlexArrays = function () { return this._prevFlexArrays }, Cl.prototype.getAnimationInformation = function (t) { for (var e = t._indexes, i = Array(e.length), n = 0; n < e.length; n++) { var r = e[n]; i[n] = { duration: this._finalFlexArraysWrapped.animationDuration.get(r), start: this._finalFlexArraysWrapped.animationStart.get(r), easing: this._finalFlexArraysWrapped.animationEasing.get(r) } } return i }, Cl.prototype.startUpdate = function () { }, Cl.prototype.prepareFlexArraysUpdate = function (t) { this._currentFlexArrays = t.inputFlexArrays }, Cl.prototype.setLastFlexArrays = function (t) { this._lastFlexArrays = t }, Cl.prototype.updateFlexArrays = function (t) { var e = t.attributes, i = t.selector, n = t.context, r = t.outputFlexArrays, o = t.toUpdate, s = t.formattedOutput; this._elementsUpdated.addSet(o), this._elementsToRedraw.addSet(o); var a = o.getListAndClear(); if (e && a.size) { for (var u = Ei(this._graph, a, i, n), l = u.valid, d = u.invalid, h = 0, c = s.attributes; h < c.length; h++)for (var f = H(r, c[h]), g = 0; g < d._indexes.length; g++) { var p = d._indexes[g]; f.set(p, void 0) } this._assignAttributesToFlexArrays(this._accessors, r, l, e, n), this._addUpdatedAttributes(t) } }, Cl.prototype.endUpdate = function () { for (var t = this._elementsUpdated.getList(), e = 0, i = go(this._updatedAttributesTmp); e < i.length; e++)for (var n = i[e], r = H(this._lastFlexArrays, n), o = H(this._finalFlexArrays, n), s = 0; s < t._indexes.length; s++) { var a = t._indexes[s]; o.set(a, r.get(a)) } this._updatedAttributesTmp.clear(), this._currentFlexArrays = this._finalFlexArrays }, Cl.prototype.setAttributeValues = function (t, e, i, n) { var r = t.outputFlexArrays, o = this._accessors; this._assignAttributesToFlexArrays(o, r, e, i, null), this._addUpdatedAttributes(t, n), this._elementsUpdated.add(e), this._elementsToRedraw.add(e) }, Cl.prototype.notifyLayerDestroyed = function (t) { this._addUpdatedAttributes(t) }, Cl.prototype._addUpdatedAttributes = function (t, e) { for (var i = t.outputFlexArrays, n = t.formattedOutput, r = 0, o = Array.isArray(e) ? wl(e) : n.attributes; r < o.length; r++) { var s = o[r]; H(i, s).isInitialized() && (this._updatedAttributes.add(s), this._updatedAttributesTmp.add(s), this._allUsedAttributes.add(s)) } }, Cl.prototype.getUsedAttributeNames = function (t) { return function e(i, n, r) { return void 0 === n && (n = []), void 0 === r && (r = ""), i.constructor === Ve ? i.isInitialized() && n.push(r) : i.constructor === Object && Object.keys(i).forEach(function (t) { e(i[t], n, wu(r, t)) }), n }(t.outputFlexArrays) }, Cl.prototype.redrawElements = function (t) { this._elementsToRedraw.add(t) }, Cl.prototype.redrawAll = function () { this._elementsToRedraw.addAll() }, Cl.prototype.getAndResetElementsToRedraw = function () { return this._elementsToRedraw.getListAndClear() }, Cl.prototype.getAndResetElementsUpdated = function () { return this._elementsUpdated.getListAndClear() }, Cl.prototype.getAndResetAttributesUpdated = function () { var t = go(this._updatedAttributes); return this._updatedAttributes.clear(), t }, Cl.prototype.createFlexArrays = function () { return this._createFlexArrays(this._graph, { named: !1, useDefaultValues: !1 }) }, Cl.prototype.getAttributeValues = function (t, e, i, n) { var r = n ? this._prevFlexArrays : this._currentFlexArrays; return i ? this._getMultipleAttributeValues(t, e, r) : this._getSingleAttributeValues(t, e, r) }, Cl.prototype._getAccessor = function (t) { void 0 === t && (t = ""); for (var e = this._accessors, i = F(t), n = 0, r = i; n < r.length; n++) { var o = r[n]; if (!(e = e.nested[o])) throw new Error(this._eltName + ' attribute "' + i.join("") + '" does not exist') } return e }, Cl.prototype._getSingleAttributeValues = function (t, e, i) { for (var n = this._getAccessor(e), r = t._indexes, o = Array(r.length), s = 0; s < r.length; s++)o[s] = n.get(i, r[s]); return o }, Cl.prototype._getMultipleAttributeValues = function (t, e, i) { if (!e || "all" === e) return this._getSingleAttributeValues(t, "", i); for (var n = Array(t.size), r = 0; r < n.length; ++r)n[r] = {}; for (r = 0; r < e.length; r++)for (var o = e[r], s = this._getSingleAttributeValues(t, o, i), a = 0; a < n.length; ++a)G(n[a], o, s[a]); return n }, Cl.prototype.setAnimationAttributes = function (t, e) { var i = e.duration, n = e.startTime, r = e.easing, o = t._indexes, s = this._finalFlexArraysWrapped.animationDuration, a = this._finalFlexArraysWrapped.animationStart, u = this._finalFlexArraysWrapped.animationEasing, l = go(this._allUsedAttributes); if (i) { for (var d = !1, h = 0, c = l; h < c.length; h++) { var f = c[h]; if ("x" !== f && "y" !== f) for (var g = H(this._finalFlexArrays, f), p = H(this._prevFlexArrays, f), _ = 0; _ < o.length; _++) { var v = o[_]; p.set(v, g.get(v)) } else d = !0 } if (d) { var m = Kt(), y = this._finalFlexArrays.x, b = this._finalFlexArrays.y, x = this._prevFlexArrays.x, E = this._prevFlexArrays.y; for (_ = 0; _ < o.length; _++) { v = o[_]; var A = s.get(v); if (A) { var S = a.get(v), w = u.get(v), T = (rl[w] || Yu)(Math.min((m - S) / A, 1)), C = Ye(x.get(v), y.get(v), T), M = Ye(E.get(v), b.get(v), T); x.set(v, C), E.set(v, M) } else x.set(v, y.get(v)), E.set(v, b.get(v)) } } } s.fill(o, i), a.fill(o, n), u.fill(o, r) }, Cl.prototype.resetAnimationAttributes = function (t) { this._finalFlexArraysWrapped.animationDuration.fill(t._indexes, 0) }, Cl.prototype.getUsedAttributes = function () { return go(this._allUsedAttributes) }, Cl.prototype.getDefaultFlexArrays = function () { return this._defaultFlexArrays }, Cl.prototype._assignAttributesToFlexArrays = function (t, e, i, n, r, o) { if (void 0 === o && (o = []), "function" == typeof n) for (var s = o.join("."), a = 0; a < i.size; ++a) { var u = n(p = i.get(a), r, s); this._assignSingleValueToFlexArray(e, p, t, u, o) } else if (J(n)) { var l = Object.keys(n); for (a = 0; a < l.length; ++a) { var d = l[a]; o.push(d); var h = this._getNestedAccessor(t, d, o), c = n[d]; this._assignAttributesToFlexArrays(h, e, i, c, r, o), o.pop() } } else if ((Array.isArray(n) || ArrayBuffer.isView(n)) && "color" !== o[0]) if (o.length) for (a = 0; a < i.size; ++a) { var f = i._indexes[a], g = t.check(n[a], this._colorManager); t.set(e, f, g) } else for (var a = 0; a < i.size; ++a)this._assignSingleValueToFlexArray(e, i.get(a), t, n[a], o); else for (g = t.check(n, this._colorManager), a = 0; a < i.size; ++a) { var p = i.get(a); t.set(e, p._index, g) } }, Cl.prototype._getNestedAccessor = function (t, e, i) { var n = t.nested[e]; if (!n) throw new Error(this._eltName + ' attribute "' + i.join(".") + '" does not exist'); return n }, Cl.prototype._assignSingleValueToFlexArray = function (t, e, i, value, n) { if (J(value)) for (var r = 0, o = Object.keys(value); r < o.length; r++) { var s = o[r]; n.push(s); var a = value[s], u = this._getNestedAccessor(i, s, n); this._assignSingleValueToFlexArray(t, e, u, a, n), n.pop() } else { var l = i.check(value, this._colorManager); i.set(t, e._index, l) } }, Cl); function Cl(t, e, i, n) { this._lastFlexArrays = null, this._updatedAttributes = new Set, this._updatedAttributesTmp = new Set, this._allUsedAttributes = new Set, this._colorManager = e, this._graph = t, this._eltName = i ? "node" : "edge", this._accessors = i ? Ku : Qu, this._createFlexArrays = n, this._finalFlexArrays = this._createFlexArrays(this._graph, { named: !0, useDefaultValues: !0 }), this._prevFlexArrays = this._createFlexArrays(this._graph, { named: !1, useDefaultValues: !0 }), this._defaultFlexArrays = this._createFlexArrays(this._graph, { named: !1, useDefaultValues: !0 }), this._currentFlexArrays = this._defaultFlexArrays, this.setLastFlexArrays(this._defaultFlexArrays), this._elementsToRedraw = new Eu({ graph: this._graph, isNode: i, includeRemovedElements: !0 }), this._elementsUpdated = new Eu({ graph: this._graph, isNode: i, includeRemovedElements: !1 }), this._finalFlexArraysWrapped = C({}, this._finalFlexArrays, { excluded: this._graph.getAttribute(i, "excluded"), textHidden: this._graph.getAttribute(i, "textHidden"), animationStart: this._graph.createAttribute(i, Ju), animationDuration: this._graph.createAttribute(i, $u), animationEasing: this._graph.createAttribute(i, tl), id: this._graph.getAttribute(i, "id") }, !i && { source: this._graph.getEdgeAttribute("source"), target: this._graph.getEdgeAttribute("target") }) } function Ml(t, e) { var i = e.named, n = e.useDefaultValues, r = "resource"; return { x: t.createAttribute(!0, { storage: "any", default: n ? 0 : void 0, name: i ? "x" : void 0 }), y: t.createAttribute(!0, { storage: "any", default: n ? 0 : void 0, name: i ? "y" : void 0 }), radius: t.createAttribute(!0, { storage: r, default: n ? 5 : void 0, name: i ? "radius" : void 0 }), scalingMethod: t.createAttribute(!0, { storage: r, default: n ? "scaled" : void 0, name: i ? "scalingMethod" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "grey" : void 0, name: i ? "color" : void 0 }), opacity: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "opacity" : void 0 }), shape: t.createAttribute(!0, { storage: r, default: n ? "circle" : void 0, name: i ? "shape" : void 0 }), layer: t.createAttribute(!0, { storage: r, default: n ? 0 : void 0, name: i ? "layer" : void 0 }), detectable: t.createAttribute(!0, { storage: r, default: !!n || void 0, name: i ? "detectable" : void 0 }), draggable: t.createAttribute(!0, { storage: r, default: !!n || void 0, name: i ? "draggable" : void 0 }), layoutable: t.createAttribute(!0, { storage: r, default: !!n || void 0, name: i ? "layoutable" : void 0 }), innerStroke: { width: t.createAttribute(!0, { storage: r, default: n ? 2 : void 0, name: i ? "innerStroke.width" : void 0 }), scalingMethod: t.createAttribute(!0, { storage: r, default: n ? "fixed" : void 0, name: i ? "innerStroke.scalingMethod" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "white" : void 0, name: i ? "innerStroke.color" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 12 : void 0, name: i ? "innerStroke.minVisibleSize" : void 0 }) }, outerStroke: { width: t.createAttribute(!0, { storage: r, default: n ? 5 : void 0, name: i ? "outerStroke.width" : void 0 }), scalingMethod: t.createAttribute(!0, { storage: r, default: n ? "fixed" : void 0, name: i ? "outerStroke.scalingMethod" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "outerStroke.color" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 0 : void 0, name: i ? "outerStroke.minVisibleSize" : void 0 }) }, badges: { topLeft: { color: t.createAttribute(!0, { storage: r, default: n ? "white" : void 0, name: i ? "badges.topLeft.color" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .45 : void 0, name: i ? "badges.topLeft.scale" : void 0 }), positionScale: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "badges.topLeft.positionScale" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 12 : void 0, name: i ? "badges.topLeft.minVisibleSize" : void 0 }), image: { url: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "badges.topLeft.image.url" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "badges.topLeft.image.scale" : void 0 }) }, stroke: { color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "badges.topLeft.stroke.color" : void 0 }), width: t.createAttribute(!0, { storage: r, default: n ? 2 : void 0, name: i ? "badges.topLeft.stroke.width" : void 0 }), scalingMethod: t.createAttribute(!0, { storage: r, default: n ? "fixed" : void 0, name: i ? "badges.topLeft.stroke.scalingMethod" : void 0 }) }, text: { content: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "badges.topLeft.text.content" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "badges.topLeft.text.color" : void 0 }), font: t.createAttribute(!0, { storage: r, default: n ? "Arial" : void 0, name: i ? "badges.topLeft.text.font" : void 0 }), style: t.createAttribute(!0, { storage: r, default: n ? "normal" : void 0, name: i ? "badges.topLeft.text.style" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .5 : void 0, name: i ? "badges.topLeft.text.scale" : void 0 }) } }, topRight: { color: t.createAttribute(!0, { storage: r, default: n ? "white" : void 0, name: i ? "badges.topRight.color" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .45 : void 0, name: i ? "badges.topRight.scale" : void 0 }), positionScale: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "badges.topRight.positionScale" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 12 : void 0, name: i ? "badges.topRight.minVisibleSize" : void 0 }), image: { url: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "badges.topRight.image.url" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "badges.topRight.image.scale" : void 0 }) }, stroke: { color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "badges.topRight.stroke.color" : void 0 }), width: t.createAttribute(!0, { storage: r, default: n ? 2 : void 0, name: i ? "badges.topRight.stroke.width" : void 0 }), scalingMethod: t.createAttribute(!0, { storage: r, default: n ? "fixed" : void 0, name: i ? "badges.topRight.stroke.scalingMethod" : void 0 }) }, text: { content: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "badges.topRight.text.content" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "badges.topRight.text.color" : void 0 }), font: t.createAttribute(!0, { storage: r, default: n ? "Arial" : void 0, name: i ? "badges.topRight.text.font" : void 0 }), style: t.createAttribute(!0, { storage: r, default: n ? "normal" : void 0, name: i ? "badges.topRight.text.style" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .5 : void 0, name: i ? "badges.topRight.text.scale" : void 0 }) } }, bottomLeft: { color: t.createAttribute(!0, { storage: r, default: n ? "white" : void 0, name: i ? "badges.bottomLeft.color" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .45 : void 0, name: i ? "badges.bottomLeft.scale" : void 0 }), positionScale: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "badges.bottomLeft.positionScale" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 12 : void 0, name: i ? "badges.bottomLeft.minVisibleSize" : void 0 }), image: { url: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "badges.bottomLeft.image.url" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "badges.bottomLeft.image.scale" : void 0 }) }, stroke: { color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "badges.bottomLeft.stroke.color" : void 0 }), width: t.createAttribute(!0, { storage: r, default: n ? 2 : void 0, name: i ? "badges.bottomLeft.stroke.width" : void 0 }), scalingMethod: t.createAttribute(!0, { storage: r, default: n ? "fixed" : void 0, name: i ? "badges.bottomLeft.stroke.scalingMethod" : void 0 }) }, text: { content: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "badges.bottomLeft.text.content" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "badges.bottomLeft.text.color" : void 0 }), font: t.createAttribute(!0, { storage: r, default: n ? "Arial" : void 0, name: i ? "badges.bottomLeft.text.font" : void 0 }), style: t.createAttribute(!0, { storage: r, default: n ? "normal" : void 0, name: i ? "badges.bottomLeft.text.style" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .5 : void 0, name: i ? "badges.bottomLeft.text.scale" : void 0 }) } }, bottomRight: { color: t.createAttribute(!0, { storage: r, default: n ? "white" : void 0, name: i ? "badges.bottomRight.color" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .45 : void 0, name: i ? "badges.bottomRight.scale" : void 0 }), positionScale: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "badges.bottomRight.positionScale" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 12 : void 0, name: i ? "badges.bottomRight.minVisibleSize" : void 0 }), image: { url: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "badges.bottomRight.image.url" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "badges.bottomRight.image.scale" : void 0 }) }, stroke: { color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "badges.bottomRight.stroke.color" : void 0 }), width: t.createAttribute(!0, { storage: r, default: n ? 2 : void 0, name: i ? "badges.bottomRight.stroke.width" : void 0 }), scalingMethod: t.createAttribute(!0, { storage: r, default: n ? "fixed" : void 0, name: i ? "badges.bottomRight.stroke.scalingMethod" : void 0 }) }, text: { content: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "badges.bottomRight.text.content" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "badges.bottomRight.text.color" : void 0 }), font: t.createAttribute(!0, { storage: r, default: n ? "Arial" : void 0, name: i ? "badges.bottomRight.text.font" : void 0 }), style: t.createAttribute(!0, { storage: r, default: n ? "normal" : void 0, name: i ? "badges.bottomRight.text.style" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .5 : void 0, name: i ? "badges.bottomRight.text.scale" : void 0 }) } } }, halo: { color: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "halo.color" : void 0 }), width: t.createAttribute(!0, { storage: r, default: n ? 50 : void 0, name: i ? "halo.width" : void 0 }), scalingMethod: t.createAttribute(!0, { storage: r, default: n ? "fixed" : void 0, name: i ? "halo.scalingMethod" : void 0 }), strokeColor: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "halo.strokeColor" : void 0 }), strokeWidth: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "halo.strokeWidth" : void 0 }), clustering: t.createAttribute(!0, { storage: r, default: !n && void 0, name: i ? "halo.clustering" : void 0 }), hideNonAdjacentEdges: t.createAttribute(!0, { storage: r, default: !n && void 0, name: i ? "halo.hideNonAdjacentEdges" : void 0 }) }, pulse: { enabled: t.createAttribute(!0, { storage: r, default: !n && void 0, name: i ? "pulse.enabled" : void 0 }), duration: t.createAttribute(!0, { storage: r, default: n ? 1e3 : void 0, name: i ? "pulse.duration" : void 0 }), interval: t.createAttribute(!0, { storage: r, default: n ? 800 : void 0, name: i ? "pulse.interval" : void 0 }), startColor: t.createAttribute(!0, { storage: r, default: n ? "rgba(0, 0, 0, 0.6)" : void 0, name: i ? "pulse.startColor" : void 0 }), endColor: t.createAttribute(!0, { storage: r, default: n ? "rgba(0, 0, 0, 0)" : void 0, name: i ? "pulse.endColor" : void 0 }), width: t.createAttribute(!0, { storage: r, default: n ? 50 : void 0, name: i ? "pulse.width" : void 0 }), startRatio: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "pulse.startRatio" : void 0 }), endRatio: t.createAttribute(!0, { storage: r, default: n ? 2 : void 0, name: i ? "pulse.endRatio" : void 0 }) }, icon: { content: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "icon.content" : void 0 }), font: t.createAttribute(!0, { storage: r, default: n ? "Arial" : void 0, name: i ? "icon.font" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "icon.color" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .7 : void 0, name: i ? "icon.scale" : void 0 }), style: t.createAttribute(!0, { storage: r, default: n ? "normal" : void 0, name: i ? "icon.style" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 12 : void 0, name: i ? "icon.minVisibleSize" : void 0 }) }, image: { url: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "image.url" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? 1 : void 0, name: i ? "image.scale" : void 0 }), fit: t.createAttribute(!0, { storage: r, default: !!n || void 0, name: i ? "image.fit" : void 0 }), tile: t.createAttribute(!0, { storage: r, default: !n && void 0, name: i ? "image.tile" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 12 : void 0, name: i ? "image.minVisibleSize" : void 0 }) }, outline: { enabled: t.createAttribute(!0, { storage: r, default: !n && void 0, name: i ? "outline.enabled" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "rgba(0, 0, 0, 0.36)" : void 0, name: i ? "outline.color" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 12 : void 0, name: i ? "outline.minVisibleSize" : void 0 }) }, text: { content: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "text.content" : void 0 }), font: t.createAttribute(!0, { storage: r, default: n ? "Arial" : void 0, name: i ? "text.font" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "text.color" : void 0 }), size: t.createAttribute(!0, { storage: r, default: n ? 12 : void 0, name: i ? "text.size" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .1 : void 0, name: i ? "text.scale" : void 0 }), style: t.createAttribute(!0, { storage: r, default: n ? "normal" : void 0, name: i ? "text.style" : void 0 }), align: t.createAttribute(!0, { storage: r, default: n ? "center" : void 0, name: i ? "text.align" : void 0 }), margin: t.createAttribute(!0, { storage: r, default: n ? 10 : void 0, name: i ? "text.margin" : void 0 }), padding: t.createAttribute(!0, { storage: r, default: n ? 2 : void 0, name: i ? "text.padding" : void 0 }), backgroundColor: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "text.backgroundColor" : void 0 }), tip: t.createAttribute(!0, { storage: r, default: !!n || void 0, name: i ? "text.tip" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 24 : void 0, name: i ? "text.minVisibleSize" : void 0 }), scaling: t.createAttribute(!0, { storage: r, default: !n && void 0, name: i ? "text.scaling" : void 0 }), position: t.createAttribute(!0, { storage: r, default: n ? "bottom" : void 0, name: i ? "text.position" : void 0 }), maxLineLength: t.createAttribute(!0, { storage: r, default: n ? 0 : void 0, name: i ? "text.maxLineLength" : void 0 }), truncateLength: t.createAttribute(!0, { storage: r, default: n ? 0 : void 0, name: i ? "text.truncateLength" : void 0 }), secondary: { content: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "text.secondary.content" : void 0 }), font: t.createAttribute(!0, { storage: r, default: n ? "Arial" : void 0, name: i ? "text.secondary.font" : void 0 }), color: t.createAttribute(!0, { storage: r, default: n ? "black" : void 0, name: i ? "text.secondary.color" : void 0 }), size: t.createAttribute(!0, { storage: r, default: n ? 10 : void 0, name: i ? "text.secondary.size" : void 0 }), scale: t.createAttribute(!0, { storage: r, default: n ? .08 : void 0, name: i ? "text.secondary.scale" : void 0 }), style: t.createAttribute(!0, { storage: r, default: n ? "normal" : void 0, name: i ? "text.secondary.style" : void 0 }), align: t.createAttribute(!0, { storage: r, default: n ? "center" : void 0, name: i ? "text.secondary.align" : void 0 }), margin: t.createAttribute(!0, { storage: r, default: n ? 5 : void 0, name: i ? "text.secondary.margin" : void 0 }), padding: t.createAttribute(!0, { storage: r, default: n ? 2 : void 0, name: i ? "text.secondary.padding" : void 0 }), backgroundColor: t.createAttribute(!0, { storage: r, default: n ? null : void 0, name: i ? "text.secondary.backgroundColor" : void 0 }), minVisibleSize: t.createAttribute(!0, { storage: r, default: n ? 24 : void 0, name: i ? "text.secondary.minVisibleSize" : void 0 }) } } } } function Il(t, e) { var i = e.named, n = e.useDefaultValues, r = "resource"; return { width: t.createAttribute(!1, { storage: r, default: n ? 1 : void 0, name: i ? "width" : void 0 }), scalingMethod: t.createAttribute(!1, { storage: r, default: n ? "scaled" : void 0, name: i ? "scalingMethod" : void 0 }), color: t.createAttribute(!1, { storage: r, default: n ? "grey" : void 0, name: i ? "color" : void 0 }), opacity: t.createAttribute(!1, { storage: r, default: n ? 1 : void 0, name: i ? "opacity" : void 0 }), minVisibleSize: t.createAttribute(!1, { storage: r, default: n ? 0 : void 0, name: i ? "minVisibleSize" : void 0 }), layer: t.createAttribute(!1, { storage: r, default: n ? 0 : void 0, name: i ? "layer" : void 0 }), detectable: t.createAttribute(!1, { storage: r, default: !!n || void 0, name: i ? "detectable" : void 0 }), curvature: t.createAttribute(!1, { storage: r, default: n ? 0 : void 0, name: i ? "curvature" : void 0 }), adjustAnchors: t.createAttribute(!1, { storage: r, default: !!n || void 0, name: i ? "adjustAnchors" : void 0 }), shape: { type: t.createAttribute(!1, { storage: r, default: n ? "line" : void 0, name: i ? "shape.type" : void 0 }), head: t.createAttribute(!1, { storage: r, default: n ? null : void 0, name: i ? "shape.head" : void 0 }), tail: t.createAttribute(!1, { storage: r, default: n ? null : void 0, name: i ? "shape.tail" : void 0 }), style: t.createAttribute(!1, { storage: r, default: n ? "plain" : void 0, name: i ? "shape.style" : void 0 }) }, stroke: { color: t.createAttribute(!1, { storage: r, default: n ? "inherit" : void 0, name: i ? "stroke.color" : void 0 }), width: t.createAttribute(!1, { storage: r, default: n ? 0 : void 0, name: i ? "stroke.width" : void 0 }), scalingMethod: t.createAttribute(!1, { storage: r, default: n ? "fixed" : void 0, name: i ? "stroke.scalingMethod" : void 0 }), minVisibleSize: t.createAttribute(!1, { storage: r, default: n ? 0 : void 0, name: i ? "stroke.minVisibleSize" : void 0 }) }, halo: { color: t.createAttribute(!1, { storage: r, default: n ? null : void 0, name: i ? "halo.color" : void 0 }), width: t.createAttribute(!1, { storage: r, default: n ? 10 : void 0, name: i ? "halo.width" : void 0 }), scalingMethod: t.createAttribute(!1, { storage: r, default: n ? "fixed" : void 0, name: i ? "halo.scalingMethod" : void 0 }) }, pulse: { enabled: t.createAttribute(!1, { storage: r, default: !n && void 0, name: i ? "pulse.enabled" : void 0 }), duration: t.createAttribute(!1, { storage: r, default: n ? 1e3 : void 0, name: i ? "pulse.duration" : void 0 }), interval: t.createAttribute(!1, { storage: r, default: n ? 800 : void 0, name: i ? "pulse.interval" : void 0 }), startColor: t.createAttribute(!1, { storage: r, default: n ? "rgba(0, 0, 0, 0.6)" : void 0, name: i ? "pulse.startColor" : void 0 }), endColor: t.createAttribute(!1, { storage: r, default: n ? "rgba(0, 0, 0, 0)" : void 0, name: i ? "pulse.endColor" : void 0 }), width: t.createAttribute(!1, { storage: r, default: n ? 10 : void 0, name: i ? "pulse.width" : void 0 }), startRatio: t.createAttribute(!1, { storage: r, default: n ? 1 : void 0, name: i ? "pulse.startRatio" : void 0 }), endRatio: t.createAttribute(!1, { storage: r, default: n ? 2 : void 0, name: i ? "pulse.endRatio" : void 0 }) }, outline: { enabled: t.createAttribute(!1, { storage: r, default: !n && void 0, name: i ? "outline.enabled" : void 0 }), color: t.createAttribute(!1, { storage: r, default: n ? "rgba(0, 0, 0, 0.36)" : void 0, name: i ? "outline.color" : void 0 }), minVisibleSize: t.createAttribute(!1, { storage: r, default: n ? 0 : void 0, name: i ? "outline.minVisibleSize" : void 0 }) }, text: { content: t.createAttribute(!1, { storage: r, default: n ? null : void 0, name: i ? "text.content" : void 0 }), font: t.createAttribute(!1, { storage: r, default: n ? "Arial" : void 0, name: i ? "text.font" : void 0 }), color: t.createAttribute(!1, { storage: r, default: n ? "black" : void 0, name: i ? "text.color" : void 0 }), size: t.createAttribute(!1, { storage: r, default: n ? 12 : void 0, name: i ? "text.size" : void 0 }), scale: t.createAttribute(!1, { storage: r, default: n ? 1 : void 0, name: i ? "text.scale" : void 0 }), style: t.createAttribute(!1, { storage: r, default: n ? "normal" : void 0, name: i ? "text.style" : void 0 }), align: t.createAttribute(!1, { storage: r, default: n ? "center" : void 0, name: i ? "text.align" : void 0 }), margin: t.createAttribute(!1, { storage: r, default: n ? 2 : void 0, name: i ? "text.margin" : void 0 }), padding: t.createAttribute(!1, { storage: r, default: n ? 2 : void 0, name: i ? "text.padding" : void 0 }), backgroundColor: t.createAttribute(!1, { storage: r, default: n ? null : void 0, name: i ? "text.backgroundColor" : void 0 }), minVisibleSize: t.createAttribute(!1, { storage: r, default: n ? 4 : void 0, name: i ? "text.minVisibleSize" : void 0 }), adjustAngle: t.createAttribute(!1, { storage: r, default: !!n || void 0, name: i ? "text.adjustAngle" : void 0 }), scaling: t.createAttribute(!1, { storage: r, default: !n && void 0, name: i ? "text.scaling" : void 0 }), maxLineLength: t.createAttribute(!1, { storage: r, default: n ? 0 : void 0, name: i ? "text.maxLineLength" : void 0 }), secondary: { content: t.createAttribute(!1, { storage: r, default: n ? null : void 0, name: i ? "text.secondary.content" : void 0 }), font: t.createAttribute(!1, { storage: r, default: n ? "Arial" : void 0, name: i ? "text.secondary.font" : void 0 }), color: t.createAttribute(!1, { storage: r, default: n ? "black" : void 0, name: i ? "text.secondary.color" : void 0 }), size: t.createAttribute(!1, { storage: r, default: n ? 12 : void 0, name: i ? "text.secondary.size" : void 0 }), scale: t.createAttribute(!1, { storage: r, default: n ? .8 : void 0, name: i ? "text.secondary.scale" : void 0 }), style: t.createAttribute(!1, { storage: r, default: n ? "normal" : void 0, name: i ? "text.secondary.style" : void 0 }), align: t.createAttribute(!1, { storage: r, default: n ? "center" : void 0, name: i ? "text.secondary.align" : void 0 }), margin: t.createAttribute(!1, { storage: r, default: n ? 2 : void 0, name: i ? "text.secondary.margin" : void 0 }), padding: t.createAttribute(!1, { storage: r, default: n ? 2 : void 0, name: i ? "text.secondary.padding" : void 0 }), backgroundColor: t.createAttribute(!1, { storage: r, default: n ? null : void 0, name: i ? "text.secondary.backgroundColor" : void 0 }), minVisibleSize: t.createAttribute(!1, { storage: r, default: n ? 4 : void 0, name: i ? "text.secondary.minVisibleSize" : void 0 }) } } } } var Ll = (Nl.prototype._getLayerById = function (t) { for (var e = 0; e < this._layers.length; ++e) { var i = this._layers[e]; if (i.id === t) return i.index = e, i } throw new Error("usage of a destroyed style rule or class") }, Nl.prototype._fetch = function (t) { return t.isNode ? this._nodes : this._edges }, Nl.prototype.getFlexArrays = function () { return { nodes: { current: this._nodes.getAttributeFlexArrays(), previous: this._nodes.getPrevAttributeFlexArrays() }, edges: { current: this._edges.getAttributeFlexArrays(), previous: this._edges.getPrevAttributeFlexArrays() } } }, Nl.prototype.createFlexArrays = function () { return { nodes: this._nodes.createFlexArrays(), edges: this._edges.createFlexArrays() } }, Nl.prototype.clear = function () { this._updateOngoing = !1, this._needUpdate = !1, this._destroyedLayers = [], this._nodes.clear(), this._edges.clear(), this.updateAllForAllAttributeLayers() }, Nl.prototype.redrawElements = function (t) { t.size && (this._fetch(t).redrawElements(t), this._dom.refresh()) }, Nl.prototype.redrawAll = function () { this._nodes.redrawAll(), this._edges.redrawAll(), this._dom.refresh() }, Nl.prototype._triggerUpdate = function () { this._needUpdate = !0, this._dom.refresh() }, Nl.prototype._reconstructAttributeLayersIfNecessary = function () { return !!this._layersNeedUpdate && (this._reconstructAttributeLayers(), this._layersNeedUpdate = !1, this._dom.refresh(), !0) }, Nl.prototype.getAnimationInformation = function (t) { return this._fetch(t).getAnimationInformation(t) }, Nl.prototype.update = function () { if (!this._needUpdate || this._updateOngoing || !this._ogma._token) return !1; this._reconstructAttributeLayersIfNecessary(), this._updateOngoing = !0, this._nodes.startUpdate(), this._edges.startUpdate(); for (var t = 0, e = this._destroyedLayers; t < e.length; t++)(r = e[t]).initialized && (this._nodes.notifyLayerDestroyed(r.nodes), this._edges.notifyLayerDestroyed(r.edges)); for (var i = 0, n = this._layers; i < n.length; i++) { var r, o = (r = n[i]).nodes, s = r.edges; this._nodes.prepareFlexArraysUpdate(o), this._edges.prepareFlexArraysUpdate(s), this._nodes.updateFlexArrays(o), this._edges.updateFlexArrays(s) } return this._nodes.endUpdate(), this._edges.endUpdate(), this._updateOngoing = !1, !(this._needUpdate = !1) }, Nl.prototype.setAttributeLayerValues = function (t, e, i, n) { var r = this._getLayerById(t), o = e.isNode ? r.nodes : r.edges; this._reconstructAttributeLayersIfNecessary(), this._fetch(e).setAttributeValues(o, e, i, n), this._updateElementsForAttributeLayers([r], e) }, Nl.prototype.getAttributeLayerFlexArrays = function (t) { var e = this._getLayerById(t); return { nodes: e.nodes.outputFlexArrays, edges: e.edges.outputFlexArrays } }, Nl.prototype.getUsedAttributeLayerAttributes = function (t, e) { var i = this._getLayerById(t); return this._fetch(e).getUsedAttributeNames(e.isNode ? i.nodes : i.edges) }, Nl.prototype.getAndResetElementsUpdated = function () { return { nodes: this._nodes.getAndResetElementsUpdated(), edges: this._edges.getAndResetElementsUpdated(), nodeAttributes: this._nodes.getAndResetAttributesUpdated(), edgeAttributes: this._edges.getAndResetAttributesUpdated() } }, Nl.prototype.getAndResetElementsToRedraw = function () { return { nodes: this._nodes.getAndResetElementsToRedraw(), edges: this._edges.getAndResetElementsToRedraw() } }, Nl.prototype.addAttributeLayer = function (e) { if (void 0 === e && (e = {}), e.name && this._layers.find(function (t) { return t.name === e.name })) throw new Error('attribute layer with name "' + e.name + '" already exists'); var t = { id: ++this._layerIdCounter, name: e.name, tag: e.tag, priority: 0, depsNodeSelf: [], depsNodeAdjacentNodes: [], depsNodeAdjacentEdges: [], depsNodeAllNodes: [], depsNodeAllEdges: [], depsEdgeSelf: [], depsEdgeExtremities: [], depsEdgeParallelEdges: [], depsEdgeAllNodes: [], depsEdgeAllEdges: [], initialized: !1, nodes: { type: "node", name: e.name, standaloneSelector: !!e.standaloneSelectors, toUpdate: new Eu({ graph: this._graph, isNode: !0, includeRemovedElements: !1 }), outputFlexArrays: this._nodes.createFlexArrays(), inputFlexArrays: null, formattedDependencies: null, formattedOutput: null }, edges: { type: "edge", name: e.name, standaloneSelector: !!e.standaloneSelectors, toUpdate: new Eu({ graph: this._graph, isNode: !1, includeRemovedElements: !1 }), outputFlexArrays: this._edges.createFlexArrays(), inputFlexArrays: null, formattedDependencies: null, formattedOutput: null } }; return this._layers.push(t), this._updateLayer(t, e), new yu(this, this._layerIdCounter) }, Nl.prototype._reconstructAttributeLayers = function () { this._layers.sort(function (t, e) { return t.priority - e.priority }); for (var t = j(this._nodes.getDefaultFlexArrays()), e = j(this._edges.getDefaultFlexArrays()), i = Y(t), n = Y(e), r = 0, o = this._layers; r < o.length; r++)(T = o[r]).nodes.allAttributePaths = i, T.edges.allAttributePaths = n, T.nodes.formattedDependencies = xl(T.nodes), T.edges.formattedDependencies = El(T.edges), T.nodes.formattedOutput = ml(T.nodes, T.tag), T.edges.formattedOutput = ml(T.edges, T.tag), T.nodes.redrawAdjacentEdges = T.nodes.formattedOutput.attributes.some(function (t) { return nl[t] }), T.initialized = !0; for (var s = 0, a = this._layers; s < a.length; s++) { (T = a[s]).nodes.inputFlexArrays = j(t), T.edges.inputFlexArrays = j(e), T.depsNodeSelf = [], T.depsNodeAdjacentNodes = [], T.depsNodeAdjacentEdges = [], T.depsNodeAllNodes = [], T.depsNodeAllEdges = [], T.depsEdgeSelf = [], T.depsEdgeExtremities = [], T.depsEdgeParallelEdges = [], T.depsEdgeAllNodes = [], T.depsEdgeAllEdges = [], T.nodes.toUpdate.addAll(), T.edges.toUpdate.addAll(); for (var u = 0, l = T.nodes.formattedOutput.attributes; u < l.length; u++) { var d = H(t, f = l[u]); (g = H(T.nodes.outputFlexArrays, f)).setFallback(d), G(t, f, g) } for (var h = 0, c = T.edges.formattedOutput.attributes; h < c.length; h++) { var f, g; d = H(e, f = c[h]), (g = H(T.edges.outputFlexArrays, f)).setFallback(d), G(e, f, g) } for (var p = 0, _ = this._layers; p < _.length; p++) { var v = _[p]; if (T !== v) { var m = T.priority, y = v.priority, b = T.nodes.formattedOutput, x = T.edges.formattedOutput, E = v.nodes.formattedDependencies, A = v.edges.formattedDependencies; bl(T.depsNodeSelf, v, b, E.self, m, y), bl(T.depsNodeAdjacentNodes, v, b, E.adjacentNodes, m, y), bl(T.depsNodeAdjacentEdges, v, x, A.extremities, m, y), bl(T.depsNodeAllNodes, v, b, E.allNodes, m, y), bl(T.depsNodeAllEdges, v, x, A.allNodes, m, y), bl(T.depsEdgeSelf, v, x, A.self, m, y), bl(T.depsEdgeExtremities, v, b, E.adjacentEdges, m, y), bl(T.depsEdgeParallelEdges, v, x, A.parallelEdges, m, y), bl(T.depsEdgeAllNodes, v, b, E.allEdges, m, y), bl(T.depsEdgeAllEdges, v, x, A.allEdges, m, y) } } } this._nodes.setLastFlexArrays(t), this._edges.setLastFlexArrays(e); for (var S = 0, w = this._layers; S < w.length; S++) { var T; (T = w[S]).nodes.needAdjacentElements = T.nodes.redrawAdjacentEdges || 0 < T.depsNodeAdjacentNodes.length || 0 < T.depsNodeAdjacentEdges.length, T.edges.needAdjacentElements = 0 < T.depsEdgeExtremities.length || 0 < T.depsEdgeParallelEdges.length } }, Nl.prototype._updateLayer = function (t, e) { void 0 === e && (e = {}); var i = e.priority, n = e.fullOverwrite, r = e.nodeAttributes, o = e.nodeSelector, s = e.nodeContext, a = e.nodeDependencies, u = e.nodeOutput, l = e.edgeAttributes, d = e.edgeSelector, h = e.edgeContext, c = e.edgeDependencies, f = e.edgeOutput; void 0 !== r && (t.nodes.attributes = n ? r : $(t.nodes.attributes, r)), void 0 !== o && (t.nodes.selector = o), void 0 !== s && (t.nodes.context = s), void 0 !== a && (t.nodes.dependencies = a), void 0 !== u && (t.nodes.output = u), void 0 !== l && (t.edges.attributes = n ? l : $(t.edges.attributes, l)), void 0 !== d && (t.edges.selector = d), void 0 !== h && (t.edges.context = h), void 0 !== c && (t.edges.dependencies = c), void 0 !== f && (t.edges.output = f), void 0 !== i && (t.priority = i), this._triggerLayerUpdate() }, Nl.prototype._triggerLayerUpdate = function () { this._layersNeedUpdate = !0, this._triggerUpdate() }, Nl.prototype.updateAllForAttributeLayer = function (t) { var e = this._getLayerById(t); this._updateAllForAttributeLayer(e) }, Nl.prototype.updateAllForAllAttributeLayers = function () { for (var t = 0, e = this._layers; t < e.length; t++) { var i = e[t]; this._updateAllForAttributeLayer(i) } }, Nl.prototype._updateAllForAttributeLayer = function (t, e, i) { if (void 0 === e && (e = !0), void 0 === i && (i = !0), e && !t.nodes.toUpdate.isFull()) { t.nodes.toUpdate.addAll(); for (var n = 0, r = t.depsNodeSelf; n < r.length; n++) { var o = r[n]; this._updateAllForAttributeLayer(o, !0, !1) } for (var s = 0, a = t.depsNodeAdjacentNodes; s < a.length; s++)o = a[s], this._updateAllForAttributeLayer(o, !0, !1); for (var u = 0, l = t.depsNodeAdjacentEdges; u < l.length; u++)o = l[u], this._updateAllForAttributeLayer(o, !1, !0); for (var d = 0, h = t.depsNodeAllNodes; d < h.length; d++)o = h[d], this._updateAllForAttributeLayer(o, !0, !1); for (var c = 0, f = t.depsNodeAllEdges; c < f.length; c++)o = f[c], this._updateAllForAttributeLayer(o, !1, !0) } if (i && !t.edges.toUpdate.isFull()) { t.edges.toUpdate.addAll(); for (var g = 0, p = t.depsEdgeSelf; g < p.length; g++)o = p[g], this._updateAllForAttributeLayer(o, !1, !0); for (var _ = 0, v = t.depsEdgeExtremities; _ < v.length; _++)o = v[_], this._updateAllForAttributeLayer(o, !0, !1); for (var m = 0, y = t.depsEdgeParallelEdges; m < y.length; m++)o = y[m], this._updateAllForAttributeLayer(o, !1, !0); for (var b = 0, x = t.depsEdgeAllNodes; b < x.length; b++)o = x[b], this._updateAllForAttributeLayer(o, !0, !1); for (var E = 0, A = t.depsEdgeAllEdges; E < A.length; E++)o = A[E], this._updateAllForAttributeLayer(o, !1, !0) } this._triggerUpdate() }, Nl.prototype.updateElementsForAttributeLayer = function (t, e) { var i = this._getLayerById(t); this._updateElementsForAttributeLayers([i], e) }, Nl.prototype.updateForAllAttributeLayers = function (t) { this._updateElementsForAttributeLayers(this._layers, t) }, Nl.prototype._updateElementsForAttributeLayers = function (t, e) { var i = null; if (e.isNode) { for (var n = 0, r = t; n < r.length; n++)if (!(m = r[n]).nodes.toUpdate.isFull()) { m.nodes.needAdjacentElements && (i = i || e.fastGetAdjacentElements()), m.nodes.toUpdate.add(e); for (var o = 0, s = m.depsNodeSelf; o < s.length; o++)(f = s[o]).nodes.toUpdate.add(e); for (var a = 0, u = m.depsNodeAdjacentNodes; a < u.length; a++)(f = u[a]).nodes.toUpdate.add(i.nodes); for (var l = 0, d = m.depsNodeAdjacentEdges; l < d.length; l++)(f = d[l]).edges.toUpdate.add(i.edges); for (var h = 0, c = m.depsNodeAllNodes; h < c.length; h++) { var f = c[h]; this._updateAllForAttributeLayer(f, !0, !1) } for (var g = 0, p = m.depsNodeAllEdges; g < p.length; g++)f = p[g], this._updateAllForAttributeLayer(f, !1, !0); m.nodes.redrawAdjacentEdges && this._edges.redrawElements(i.edges) } } else for (var _ = 0, v = t; _ < v.length; _++) { var m; if (!(m = v[_]).edges.toUpdate.isFull()) { m.edges.needAdjacentElements && (i = i || e.fastGetAdjacentElements()), m.edges.toUpdate.add(e); for (var y = 0, b = m.depsEdgeSelf; y < b.length; y++)(f = b[y]).edges.toUpdate.add(e); for (var x = 0, E = m.depsEdgeExtremities; x < E.length; x++)(f = E[x]).nodes.toUpdate.add(i.nodes); for (var A = 0, S = m.depsEdgeParallelEdges; A < S.length; A++)(f = S[A]).edges.toUpdate.add(i.edges); for (var w = 0, T = m.depsEdgeAllNodes; w < T.length; w++)f = T[w], this._updateAllForAttributeLayer(f, !0, !1); for (var C = 0, M = m.depsEdgeAllEdges; C < M.length; C++)f = M[C], this._updateAllForAttributeLayer(f, !1, !0) } } this._triggerUpdate() }, Nl.prototype.destroyAttributeLayer = function (t) { var e = this._getLayerById(t); this._destroyedLayers.push(e), this._layers.splice(e.index, 1), this._triggerLayerUpdate() }, Nl.prototype.updateAttributeLayer = function (t, e) { var i = this._getLayerById(t); this._updateLayer(i, e) }, Nl.prototype.getAttributeLayerDefinition = function (t) { var e = this._getLayerById(t), i = e.priority, n = e.nodes, r = e.edges; return { priority: i, nodeAttributes: n.attributes, nodeSelector: n.selector, nodeContext: n.context, nodeDependencies: n.dependencies, nodeOutput: n.output, edgeAttributes: r.attributes, edgeSelector: r.selector, edgeContext: r.context, edgeDependencies: r.dependencies, edgeOutput: r.output } }, Nl.prototype.getAttributeValues = function (t, e, i, n) { return this.update(), this._fetch(t).getAttributeValues(t, e, i, n) }, Nl.prototype.setAnimationAttributes = function (t, e) { var i = t.nodes, n = t.edges; this._nodes.setAnimationAttributes(i, e), this._edges.setAnimationAttributes(n, e) }, Nl.prototype.resetAnimationAttributes = function (t) { var e = t.nodes, i = t.edges; this._nodes.resetAnimationAttributes(e), this._edges.resetAnimationAttributes(i) }, Nl.prototype.setTextHidden = function (t, value) { var e = this._textHiddenSet.addOrRemoveElements(t, value); this.redrawElements(e) }, Nl.prototype.resetTextHidden = function () { var t = this._textHiddenSet.getElements(), e = t.nodes, i = t.edges; this._textHiddenSet.clear(), this._nodes.redrawElements(e), this._edges.redrawElements(i) }, Nl.prototype.getUsedNodeAttributes = function () { return this._nodes.getUsedAttributes() }, Nl.prototype.getUsedEdgeAttributes = function () { return this._edges.getUsedAttributes() }, Nl); function Nl(t, e, i) { this._colorManager = new _n, this._layerIdCounter = 0, this._layers = [], this._destroyedLayers = [], this._layersNeedUpdate = !1, this._updateOngoing = !1, this._needUpdate = !1, this._ogma = i, this._graph = t, this._dom = e, this._textHiddenSet = new Do(this._graph, "textHidden"), this._nodes = new Tl(t, this._colorManager, !0, Ml), this._edges = new Tl(t, this._colorManager, !1, Il) } function kl(t, e, i) { return void 0 === i && (i = 0), "inherit" === t ? Array.isArray(e) ? e[i / (2 * Math.PI) * e.length | 0] : e : t } function Ol(t, e) { var i = t(), n = Y(i).map(function (t) { var value = H(i, t); return Array.isArray(value) ? "for (var i = 0; i < " + value.length + "; ++i) {\n        target." + t + "[i] = source." + t + "[i]." + e + ";\n      }\n      return target;" : "target." + t + " = source." + t + "." + e + ";" }).join("\n"); return new Function("source, target", n) } function Fl(t) { var e = t(), i = Y(e).map(function (t) { var value = H(e, t); return Array.isArray(value) ? "for (var i = 0; i < " + value.length + "; ++i) {\n        target." + t + "[i] = target." + t + "[i] || source." + t + "[i];\n      }" : "target." + t + " = target." + t + " || source." + t + ";" }).join("\n"); return new Function("target", "source", i) } function Rl(t) { var e = (t.getDepth() - ws) % ks; return 0 <= e && e !== Ts && e !== Is } function Pl(t, e, i, n) { var r, o, s, a, u, l, d, h, c, f; r = t, o = e, a = n, u = +("scaled" === (s = i).scalingMethod.get(a)), l = 2 * s.radius.get(a), d = s.innerStroke.width.get(a), h = +("scaled" === s.innerStroke.scalingMethod.get(a)), c = s.outerStroke.width.get(a), f = +("scaled" === s.outerStroke.scalingMethod.get(a)), o.x = s.x.get(a), o.y = s.y.get(a), o.shape = s.shape.get(a), o.color = s.color.get(a), o.opacity = s.opacity.get(a), o.diameterScaled = l * u, o.diameterFixed = l * (1 - u), o.innerStroke.color = kl(s.innerStroke.color.get(a), o.color), o.innerStroke.widthScaled = d * h, o.innerStroke.widthFixed = d * (1 - h), o.innerStroke.minVisibleSize = s.innerStroke.minVisibleSize.get(a), o.outerStroke.color = kl(s.outerStroke.color.get(a), o.color), o.outerStroke.widthScaled = c * f, o.outerStroke.widthFixed = c * (1 - f), o.halo.color = s.halo.color.get(a), o.halo.strokeColor = s.halo.strokeColor.get(a), o.icon.content = r.formatText(s.icon.content.get(a)), o.image.url = s.image.url.get(a), o.outline.enabled = s.outline.enabled.get(a), o.textHidden = !!s.textHidden.get(a), Dl(t, e.texts.primary, i.text, n, e), Dl(t, e.texts.secondary, i.text.secondary, n, e), zl(t, e.badges.topLeft, i.badges.topLeft, n), zl(t, e.badges.topRight, i.badges.topRight, n), zl(t, e.badges.bottomLeft, i.badges.bottomLeft, n), zl(t, e.badges.bottomRight, i.badges.bottomRight, n) } function Dl(t, e, i, n, r) { if (e.hidden = r.textHidden, e.content = t.formatText(i.content.get(n)), e.backgroundColor = kl(i.backgroundColor.get(n), r.color), e === r.texts.primary) { var o = i; e.tip = o.tip.get(n), e.position = o.position.get(n) } else e.position = "bottom" } function zl(t, e, i, n) { e.textContent = t.formatText(i.text.content.get(n)), e.imageUrl = i.image.url.get(n) } function Bl() { return { x: 0, y: 0, shape: "", color: "", opacity: 0, diameterScaled: 0, diameterFixed: 0, innerStroke: { color: "", widthScaled: 0, widthFixed: 0, minVisibleSize: 0 }, outerStroke: { color: "", widthScaled: 0, widthFixed: 0, minVisibleSize: 0 }, icon: { content: "", font: "", color: "", scale: 0, size: 0, style: "none", minVisibleSize: 0 }, image: { url: "", content: null, scale: 0, rescale: !1, duplicate: !1, minVisibleSize: 0 }, halo: { widthScaled: 0, widthFixed: 0, strokeWidthScaled: 0, strokeWidthFixed: 0, color: "", strokeColor: "" }, outline: { enabled: !1, color: "", minVisibleSize: 0 }, badges: { topLeft: Ul(Rs), topRight: Ul(Ps), bottomLeft: Ul(Ds), bottomRight: Ul(zs) }, textHidden: !1, texts: { primary: Vl(), secondary: Vl() } } } function Ul(t) { return { angle: t, color: "", scale: 0, positionScale: 0, minVisibleSize: 0, strokeColor: "", strokeWidthScaled: 0, strokeWidthFixed: 0, textContent: "", textFont: "", textColor: "", textScale: 0, textStyle: "none", imageUrl: "", imageContent: null, imageScale: 0 } } function Vl() { return { hidden: !1, content: "", position: "", backgroundColor: "", tip: !1, font: "", color: "", sizeScaled: 0, sizeFixed: 0, style: "none", align: "left", minVisibleSize: 0, margin: 0, padding: 0, maxLineLength: 0, widthScaled: 0, widthFixed: 0, heightScaled: 0, heightFixed: 0, positionAngle: 0, isPositionCenter: !1, isPositionVertical: !1, isPositionHorizontal: !1 } } function jl() { return { edgeHalo: 0, nodeHaloStroke: 0, nodeHalo: 0, edgeBody: 0, edgeTextBackground: 0, edgeText: 0, nodeBody: 0, nodeTextBackground: 0, nodeText: 0 } } function Gl(t, e) { var i = e || jl(), n = (t - Iu) * ks + ws; return i.edgeHalo = Es, i.nodeHaloStroke = As, i.nodeHalo = Ss, i.edgeBody = n + Ts, i.edgeTextBackground = n + Cs, i.edgeText = n + Ms, i.nodeBody = n + Is, i.nodeTextBackground = n + Ls, i.nodeText = n + Ns, i } function Hl(t, e) { var i, n; n = e, (i = t).body = !0, i.icon = !!n.icon.content, i.image = !!n.image.url, i.pieChart = Array.isArray(n.color), i.outerStroke = !!n.outerStroke.color, i.outline = !!n.outline.enabled, i.halo = !!n.halo.color, i.haloStroke = i.halo && !!n.halo.strokeColor, ql(t.texts.primary, e.texts.primary), ql(t.texts.secondary, e.texts.secondary), Wl(t.badges.topLeft, e.badges.topLeft), Wl(t.badges.topRight, e.badges.topRight), Wl(t.badges.bottomLeft, e.badges.bottomLeft), Wl(t.badges.bottomRight, e.badges.bottomRight) } function ql(t, e) { t.text = !e.hidden && !!e.content, t.background = t.text && !!e.backgroundColor, t.tip = t.background && e.tip && "center" !== e.position } function Wl(t, e) { t.text = !!e.textContent, t.image = !!e.imageUrl } function Xl(t, e) { t.pieceId = Sn, t.x1 = e.x, t.y1 = e.y, t.x2 = e.x, t.y2 = e.y, t.rectWidthOrSourceRadiusScaled = e.diameterScaled, t.rectWidthOrSourceRadiusFixed = e.diameterFixed, t.rectHeightOrTargetRadiusScaled = e.diameterScaled, t.rectHeightOrTargetRadiusFixed = e.diameterFixed, t.shape = e.shape, t.opacity = e.opacity, t.symbolicSize = e.diameterScaled, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = 0, t.strokeWidthFixed = 0, t.offsetScaled = 0, t.offsetFixed = 0, t.fillColor = null, t.strokeColor = null, t.globalMinVisibleSize = 0, t.strokeMinVisibleSize = 0, t.offsetAngle = 0, t.curvature = 0, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isSelfLoop = !1, t.isText = !1 } function Yl(t, e, i) { var n = i.diameterScaled * e.scale, r = i.diameterFixed * e.scale, o = i.diameterScaled * e.positionScale / 2, s = i.diameterFixed * e.positionScale / 2; t.pieceId = Sn, t.shape = "circle", t.x1 = i.x, t.y1 = i.y, t.x2 = i.x, t.y2 = i.y, t.rectWidthOrSourceRadiusScaled = n, t.rectWidthOrSourceRadiusFixed = r, t.rectHeightOrTargetRadiusScaled = n, t.rectHeightOrTargetRadiusFixed = r, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = e.strokeWidthScaled, t.strokeWidthFixed = e.strokeWidthFixed, t.offsetScaled = o, t.offsetFixed = s, t.pattern.type = 0, t.opacity = i.opacity, t.fillColor = e.color, t.strokeColor = e.strokeColor, t.patternColor = null, t.globalMinVisibleSize = e.minVisibleSize, t.strokeMinVisibleSize = 0, t.patternMinVisibleSize = 0, t.offsetAngle = e.angle, t.patternScale = 0, t.symbolicSize = i.diameterScaled, t.curvature = 0, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isSelfLoop = !1, t.isText = !1 } function Zl(t, e, i) { var n, r, o = 0, s = 0; if (e.isPositionCenter || (o += i.innerStroke.widthScaled + i.outerStroke.widthScaled + i.diameterScaled / 2, s += i.innerStroke.widthFixed + i.outerStroke.widthFixed + i.diameterFixed / 2 + e.margin + e.padding), e.isPositionVertical) { if (o += e.heightScaled / 2, s += e.heightFixed / 2, e === i.texts.secondary && "bottom" === i.texts.primary.position) { var a = i.texts.primary; o += a.heightScaled, s += a.heightFixed + a.margin + 2 * a.padding } } else e.isPositionHorizontal && (o += e.widthScaled / 2, s += e.widthFixed / 2); r = 0 < e.sizeScaled ? (n = "sdf", 1) : (n = e.sizeFixed, 0), t.pieceId = Sn, t.shape = "square", t.x1 = i.x, t.y1 = i.y, t.x2 = i.x, t.y2 = i.y, t.rectWidthOrSourceRadiusScaled = e.widthScaled, t.rectWidthOrSourceRadiusFixed = e.widthFixed + 2 * e.padding, t.rectHeightOrTargetRadiusScaled = e.heightScaled, t.rectHeightOrTargetRadiusFixed = e.heightFixed + 2 * e.padding, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = 0, t.strokeWidthFixed = 0, t.offsetScaled = o, t.offsetFixed = s, t.pattern.type = 0, t.pattern.attributes.size = n, t.opacity = i.opacity, t.fillColor = null, t.strokeColor = null, t.patternColor = null, t.globalMinVisibleSize = e.minVisibleSize, t.strokeMinVisibleSize = 0, t.patternMinVisibleSize = 0, t.offsetAngle = e.positionAngle, t.patternScale = r, t.symbolicSize = i.diameterScaled, t.curvature = 0, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isSelfLoop = !1, t.isText = !1 } function Kl(t, e, i, n, r, o) { var s = r.badges, a = n.badges, u = o.badges; !function (t, e, i, n, r) { if (n.halo) { var o = i.halo.width.get(e), s = +("scaled" === i.halo.scalingMethod.get(e)); r.halo.widthScaled = o * s, r.halo.widthFixed = o * (1 - s), function (t, e) { var i = e.diameterScaled + 2 * e.halo.widthScaled, n = e.diameterFixed + 2 * e.halo.widthFixed; t.pieceId = Sn, t.shape = "circle", t.x1 = e.x, t.y1 = e.y, t.x2 = e.x, t.y2 = e.y, t.rectWidthOrSourceRadiusScaled = i, t.rectWidthOrSourceRadiusFixed = n, t.rectHeightOrTargetRadiusScaled = i, t.rectHeightOrTargetRadiusFixed = n, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = 0, t.strokeWidthFixed = 0, t.offsetScaled = 0, t.offsetFixed = 0, t.pattern.type = 0, t.opacity = e.opacity, t.fillColor = e.halo.color, t.strokeColor = null, t.patternColor = null, t.globalMinVisibleSize = 0, t.strokeMinVisibleSize = 0, t.patternMinVisibleSize = 0, t.offsetAngle = 0, t.patternScale = 0, t.symbolicSize = e.diameterScaled, t.curvature = 0, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isSelfLoop = !1, t.isText = !1 }(n.halo, r), n.haloStroke && (r.halo.strokeWidthScaled = 0, r.halo.strokeWidthFixed = i.halo.strokeWidth.get(e), function (t, e) { var i = e.diameterScaled + 2 * e.halo.widthScaled, n = e.diameterFixed + 2 * e.halo.widthFixed; t.pieceId = Sn, t.shape = "circle", t.x1 = e.x, t.y1 = e.y, t.x2 = e.x, t.y2 = e.y, t.rectWidthOrSourceRadiusScaled = i, t.rectWidthOrSourceRadiusFixed = n, t.rectHeightOrTargetRadiusScaled = i, t.rectHeightOrTargetRadiusFixed = n, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = e.halo.strokeWidthScaled, t.strokeWidthFixed = e.halo.strokeWidthFixed, t.offsetScaled = 0, t.offsetFixed = 0, t.pattern.type = 0, t.opacity = e.opacity, t.fillColor = null, t.strokeColor = e.halo.strokeColor, t.patternColor = null, t.globalMinVisibleSize = 0, t.strokeMinVisibleSize = 0, t.patternMinVisibleSize = 0, t.offsetAngle = 0, t.patternScale = 0, t.symbolicSize = e.diameterScaled, t.curvature = 0, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isSelfLoop = !1, t.isText = !1 }(n.haloStroke, r)) } n.outline && (r.outline.color = i.outline.color.get(e), r.outline.minVisibleSize = i.outline.minVisibleSize.get(e), function (t, e) { var i = e.diameterScaled * Bs, n = e.diameterFixed * Bs, r = e.diameterScaled * Us, o = e.diameterFixed * Us + Vs; e.outerStroke.color && (r += e.outerStroke.widthScaled / 2, o += e.outerStroke.widthFixed / 2), t.pieceId = Sn, t.shape = e.shape, t.x1 = e.x, t.y1 = e.y, t.x2 = e.x, t.y2 = e.y, t.rectWidthOrSourceRadiusScaled = i, t.rectWidthOrSourceRadiusFixed = n, t.rectHeightOrTargetRadiusScaled = i, t.rectHeightOrTargetRadiusFixed = n, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = 0, t.strokeWidthFixed = 0, t.offsetScaled = r, t.offsetFixed = o, t.pattern.type = 0, t.opacity = e.opacity, t.fillColor = e.outline.color, t.strokeColor = null, t.patternColor = null, t.globalMinVisibleSize = e.outline.minVisibleSize, t.strokeMinVisibleSize = 0, t.patternMinVisibleSize = 0, t.offsetAngle = 1.5707963267948966, t.patternScale = 0, t.symbolicSize = e.diameterScaled, t.curvature = 0, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isSelfLoop = !1, t.isText = !1 }(n.outline, r)); n.outerStroke && (r.outerStroke.minVisibleSize = i.outerStroke.minVisibleSize.get(e), function (t, e) { var i = e.diameterScaled + 2 * e.innerStroke.widthScaled, n = e.diameterFixed + 2 * e.innerStroke.widthFixed; t.pieceId = Sn, t.shape = e.shape, t.x1 = e.x, t.y1 = e.y, t.x2 = e.x, t.y2 = e.y, t.rectWidthOrSourceRadiusScaled = i, t.rectWidthOrSourceRadiusFixed = n, t.rectHeightOrTargetRadiusScaled = i, t.rectHeightOrTargetRadiusFixed = n, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = e.outerStroke.widthScaled, t.strokeWidthFixed = e.outerStroke.widthFixed, t.offsetScaled = 0, t.offsetFixed = 0, t.pattern.type = 0, t.opacity = e.opacity, t.fillColor = null, t.strokeColor = e.outerStroke.color, t.patternColor = null, t.globalMinVisibleSize = e.outerStroke.minVisibleSize, t.strokeMinVisibleSize = 0, t.patternMinVisibleSize = 0, t.offsetAngle = 0, t.patternScale = 0, t.symbolicSize = e.diameterScaled, t.curvature = 0, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isSelfLoop = !1, t.isText = !1 }(n.outerStroke, r)); n.pieChart && function (t, e) { Xl(t, e), Array.isArray(e.color) && (t.pattern.type = bn, t.pattern.attributes.colors = e.color.join(";"), t.patternScale = 1, t.patternMinVisibleSize = 0, t.patternColor = null) }(n.pieChart, r); n.image && (r.image.content = t.imageManager.getImage(r.image.url), r.image.fit = i.image.fit.get(e), r.image.tile = i.image.tile.get(e), r.image.scale = i.image.scale.get(e), r.image.minVisibleSize = i.image.minVisibleSize.get(e), function (t, e) { var i = e.image.fit && !e.image.tile; Xl(t, e), t.pattern.type = yn, t.pattern.attributes.image = e.image.content, t.pattern.attributes.scaled = i, t.pattern.attributes.duplicated = e.image.tile, t.patternScale = i ? e.image.scale : 0, t.patternMinVisibleSize = e.image.minVisibleSize, t.patternColor = null }(n.image, r)); n.icon && (r.icon.font = t.fontManager.getFont(i.icon.font.get(e)), r.icon.style = i.icon.style.get(e), r.icon.color = i.icon.color.get(e), r.icon.scale = i.icon.scale.get(e), r.icon.minVisibleSize = i.icon.minVisibleSize.get(e), function (t, e) { Xl(t, e), t.pattern.type = xn, t.pattern.attributes.text = e.icon.content, t.pattern.attributes.font = e.icon.font, t.pattern.attributes.style = e.icon.style, t.pattern.attributes.size = "sdf", t.patternMinVisibleSize = e.icon.minVisibleSize, t.patternColor = e.icon.color, t.patternScale = e.icon.scale }(n.icon, r)); if (n.body) { var a = !n.pieChart && !n.image && !n.icon; !function (t, e, i) { Xl(t, e), t.fillColor = Array.isArray(e.color) ? null : e.color, t.strokeColor = e.innerStroke.color, t.strokeMinVisibleSize = e.innerStroke.minVisibleSize, t.strokeWidthScaled = e.innerStroke.widthScaled, t.strokeWidthFixed = e.innerStroke.widthFixed, i && (t.pattern.type = 0) }(n.body, r, a) } }(e, i, n, r, o), Jl(t, e, i, n.text, r.texts.primary, o.texts.primary, o), Jl(t, e, i, n.text.secondary, r.texts.secondary, o.texts.secondary, o), Ql(t, e, i, a.topLeft, s.topLeft, u.topLeft, o), Ql(t, e, i, a.topRight, s.topRight, u.topRight, o), Ql(t, e, i, a.bottomLeft, s.bottomLeft, u.bottomLeft, o), Ql(t, e, i, a.bottomRight, s.bottomRight, u.bottomRight, o) } function Ql(t, e, i, n, r, o, s) { if (r.image || r.text) { var a = n.stroke.width.get(i), u = +("scaled" === n.stroke.scalingMethod.get(i)); o.color = kl(n.color.get(i), s.color, o.angle), o.strokeColor = n.stroke.color.get(i), o.strokeWidthScaled = a * u, o.strokeWidthFixed = a * (1 - u), o.minVisibleSize = n.minVisibleSize.get(i), o.positionScale = n.positionScale.get(i), o.scale = n.scale.get(i) } var l, d, h, c; if (r.image && (o.imageContent = e.imageManager.getImage(o.imageUrl), o.imageScale = n.image.scale.get(i), Yl(l = r.image, d = o, s), d.imageContent ? (l.pattern.type = yn, l.pattern.attributes.image = d.imageContent, l.pattern.attributes.scaled = !0, l.pattern.attributes.duplicated = !1, l.patternScale = d.imageScale, l.patternMinVisibleSize = 0, l.patternColor = null) : (l.fillColor = null, l.strokeColor = null)), r.text) { if (o.textFont = e.fontManager.getFont(n.text.font.get(i)), o.textStyle = n.text.style.get(i), o.textColor = kl(n.text.color.get(i), s.color), o.textScale = n.text.scale.get(i), 1 < t.measureText(o.textContent, o.textFont, o.textStyle, o.textScale).width) { for (var f = 0, g = 0; g < o.textContent.length && f < 1;)f += t.measureText(o.textContent[g], o.textFont, o.textStyle, o.textScale).width, g += 1; g !== o.textContent.length && (o.textContent = o.textContent.substring(0, g - 1) + "‥") } Yl(h = r.text, c = o, s), c.textContent && (h.pattern.type = En, h.pattern.attributes.text = c.textContent, h.pattern.attributes.font = c.textFont, h.pattern.attributes.style = c.textStyle, h.pattern.attributes.size = "sdf", h.patternMinVisibleSize = 0, h.patternColor = c.textColor, h.patternScale = c.textScale), !c.imageUrl && c.textContent || (h.fillColor = null, h.strokeColor = null) } } function Jl(t, e, i, n, r, o, s) { if (r.text) { var a = n, u = a.scaling.get(i); if (o.font = e.fontManager.getFont(a.font.get(i)), o.color = kl(a.color.get(i), s.color), o.style = a.style.get(i), o.align = a.align.get(i), o.minVisibleSize = a.minVisibleSize.get(i), o.margin = a.margin.get(i), o.padding = a.padding.get(i), o.maxLineLength = a.maxLineLength.get(i), o.content = $o(o.content, o.maxLineLength), u) { var l = a.scale.get(i); o.sizeScaled = s.diameterScaled * l, o.sizeFixed = s.diameterFixed * l } else o.sizeFixed = a.size.get(i), o.sizeScaled = 0; var d = t.measureText(o.content, o.font, o.style); o.widthScaled = d.width * o.sizeScaled, o.widthFixed = d.width * o.sizeFixed, o.heightScaled = d.height * o.sizeScaled, o.heightFixed = d.height * o.sizeFixed, o.positionAngle = Zs[o.position], o.isPositionCenter = "center" === o.position, o.isPositionVertical = "top" === o.position || "bottom" === o.position, o.isPositionHorizontal = "left" === o.position || "right" === o.position, Zl(E = r.text, A = o, s), E.pattern.type = An, E.pattern.attributes.text = A.content, E.pattern.attributes.font = A.font, E.pattern.attributes.style = A.style, E.pattern.attributes.align = A.align, E.patternMinVisibleSize = 0, E.patternColor = A.color, E.thicknessOrFontSizeScaled = A.sizeScaled, E.thicknessOrFontSizeFixed = A.sizeFixed, E.isText = !0, r.background && (Zl(b = r.background, x = o, s), b.fillColor = x.backgroundColor, r.tip && (h = r.tip, c = o, f = s, g = Math.ceil(c.margin / 2) + 1, p = f.diameterScaled / 2 + f.innerStroke.widthScaled + f.outerStroke.widthScaled, _ = f.diameterFixed / 2 + f.innerStroke.widthFixed + f.outerStroke.widthFixed + g, v = Ks[c.position], m = Math.cos(v), y = Math.sin(v), h.pieceId = Sn, h.shape = "triangle", h.x1 = f.x - m, h.y1 = f.y - y, h.x2 = f.x + m, h.y2 = f.y + y, h.rectWidthOrSourceRadiusScaled = 0, h.rectWidthOrSourceRadiusFixed = c.margin, h.rectHeightOrTargetRadiusScaled = 0, h.rectHeightOrTargetRadiusFixed = c.margin * Xs, h.thicknessOrFontSizeScaled = 0, h.thicknessOrFontSizeFixed = 0, h.strokeWidthScaled = 0, h.strokeWidthFixed = 0, h.offsetScaled = p, h.offsetFixed = _, h.pattern.type = 0, h.opacity = f.opacity, h.fillColor = c.backgroundColor, h.strokeColor = null, h.patternColor = null, h.globalMinVisibleSize = c.minVisibleSize, h.strokeMinVisibleSize = 0, h.patternMinVisibleSize = 0, h.offsetAngle = c.positionAngle, h.patternScale = 0, h.symbolicSize = f.diameterScaled, h.curvature = 0, h.dashLength = 0, h.gapLength = 0, h.hasHead = !1, h.hasTail = !1, h.isSelfLoop = !1)) } var h, c, f, g, p, _, v, m, y, b, x, E, A } var $l = Ol(od, "start"), td = Ol(od, "end"), ed = Fl(od), id = (nd.prototype.drawNode = function (t) { if (this._computeBlockIds(t), this._attributes.excluded.get(t)) return this._freeBlocks(); var e = this._engine, i = this._helper, n = t, r = Gl(this._attributes.layer.get(t), this._depthInfo), o = this._attributes.animationDuration.get(t), s = 0 < o; if (this._prepareBlocks(s, r, n), Pl(i, this._endInput, this._attributes, t), Hl(this._endFlags, this._endInput), s && (Pl(i, this._startInput, this._attributesPrev, t), Hl(this._startFlags, this._startInput), ed(this._endFlags, this._startFlags)), this._initComponents(this._fullComponents, this._endFlags, this._blocks), td(this._fullComponents, this._endComponents), Kl(e, i, t, this._attributes, this._endComponents, this._endInput), s && ($l(this._fullComponents, this._startComponents), Kl(e, i, t, this._attributesPrev, this._startComponents, this._startInput)), s) { var a = this._attributes.animationStart.get(t), u = this._attributes.animationEasing.get(t); this._setBlocksAnimation(o, a, u) } this._endFlags.halo && this._attributes.halo.hideNonAdjacentEdges.get(t) && (this._blocks.halo.setStencilUsage(2), this._blocks.haloStroke.setStencilUsage(2)), this._storeBlocks() }, nd.prototype._computeBlockIds = function (t) { var e = 10 * t, i = this._blockIds; i.body = 0 + e, i.text = 1 + e, i.textBg = 2 + e, i.halo = 3 + e, i.haloStroke = 4 + e }, nd.prototype._prepareBlocks = function (t, e, i) { var n = this._blocks; n.body.reset(1, t, e.nodeBody, i), n.text.reset(2, t, e.nodeText, i), n.textBg.reset(1, t, e.nodeTextBackground, i), n.halo.reset(1, t, e.nodeHalo, i), n.haloStroke.reset(1, t, e.nodeHaloStroke, i) }, nd.prototype._storeBlocks = function () { var t = this._engine, e = this._blocks, i = this._blockIds; t.storeBlock(i.body, e.body), t.storeBlock(i.text, e.text), t.storeBlock(i.textBg, e.textBg), t.storeBlock(i.halo, e.halo), t.storeBlock(i.haloStroke, e.haloStroke) }, nd.prototype._freeBlocks = function () { var t = this._engine, e = this._blockIds; t.freeBlock(e.body), t.freeBlock(e.text), t.freeBlock(e.textBg), t.freeBlock(e.halo), t.freeBlock(e.haloStroke) }, nd.prototype._setBlocksAnimation = function (t, e, i) { var n = this._blocks; n.body.setGlobalAnimation(t, e, i), n.text.setGlobalAnimation(t, e, i), n.textBg.setGlobalAnimation(t, e, i), n.halo.setGlobalAnimation(t, e, i), n.haloStroke.setGlobalAnimation(t, e, i) }, nd.prototype._initComponents = function (t, e, i) { this._nodePatternAssigned = !1, this._initBaseComponents(t, e, i), this._initBadgeComponents(t.badges.topLeft, e.badges.topLeft, i), this._initBadgeComponents(t.badges.topRight, e.badges.topRight, i), this._initBadgeComponents(t.badges.bottomLeft, e.badges.bottomLeft, i), this._initBadgeComponents(t.badges.bottomRight, e.badges.bottomRight, i), this._initTextComponents(t.texts.primary, e.texts.primary, i), this._initTextComponents(t.texts.secondary, e.texts.secondary, i) }, nd.prototype._initBaseComponents = function (t, e, i) { t.haloStroke = this._nextElement(e.haloStroke, i.haloStroke), t.halo = this._nextElement(e.halo, i.halo), t.outline = this._nextElement(e.outline, i.body), t.outerStroke = this._nextElement(e.outerStroke, i.body), t.body = this._nextElement(e.body, i.body), t.pieChart = this._getNodePatternElement(e.pieChart, i), t.image = this._getNodePatternElement(e.image, i), t.icon = this._getNodePatternElement(e.icon, i) }, nd.prototype._initBadgeComponents = function (t, e, i) { t.image = this._nextElement(e.image, i.body), t.text = this._nextElement(e.text, i.body) }, nd.prototype._initTextComponents = function (t, e, i) { t.background = this._nextElement(e.background, i.textBg), t.tip = this._nextElement(e.tip, i.textBg), t.text = this._nextElement(e.text, i.text) }, nd.prototype._nextElement = function (t, e) { return t ? e.next() : this._nullElt }, nd.prototype._getNodePatternElement = function (t, e) { return t ? this._nodePatternAssigned ? e.body.next() : (this._nodePatternAssigned = !0, e.body.getCurrentElement()) : this._nullElt }, nd); function nd(t) { var e = t.engine, i = t.imageManager, n = t.fontManager, r = t.formatText, o = t.attributes, s = t.attributesPrev; this._fullComponents = od(), this._startComponents = od(), this._endComponents = od(), this._startFlags = od(), this._endFlags = od(), this._startInput = Bl(), this._endInput = Bl(), this._depthInfo = jl(), this._nodePatternAssigned = !1, this._nullElt = { id: -1, valid: !0, animation: null, start: null, end: null }, this._engine = e, this._attributes = o, this._attributesPrev = s, this._helper = { imageManager: i, fontManager: n, formatText: r }, this._blocks = rd(function () { return e.createBlock() }), this._blockIds = rd(function () { return 0 }) } function rd(t) { return { body: t(), text: t(), textBg: t(), halo: t(), haloStroke: t() } } function od() { return { haloStroke: void 0, halo: void 0, outline: void 0, outerStroke: void 0, body: void 0, pieChart: void 0, image: void 0, icon: void 0, badges: { topLeft: { text: void 0, image: void 0 }, topRight: { text: void 0, image: void 0 }, bottomLeft: { text: void 0, image: void 0 }, bottomRight: { text: void 0, image: void 0 } }, texts: { primary: { text: void 0, background: void 0, tip: void 0 }, secondary: { text: void 0, background: void 0, tip: void 0 } } } } function circleCircleIntersection(t, e, i, n, r, o) { var s, a, u, l, d, h, c, f, g; return a = n - t, u = r - e, i + o < (l = Math.sqrt(a * a + u * u)) ? null : l < Math.abs(i - o) ? null : (g = e + u * (s = (i * i - o * o + l * l) / (2 * l)) / l, [[(f = t + a * s / l) + (h = (d = Math.sqrt(i * i - s * s)) / l * -u), g + (c = d / l * a)], [f - h, g - c]]) } function circleSortCompare(t, e, i, n, r, o) { if (0 <= t - r && i - r < 0) return 1; if (t - r < 0 && 0 <= i - r) return -1; if (t - r == 0 && i - r == 0) return 0 <= e - n || 0 <= n - o ? e - n : n - e; var s = (t - r) * (n - o) - (i - r) * (e - o); return s < 0 ? 1 : 0 < s ? -1 : (t - r) * (t - r) + (e - o) * (e - o) - ((i - r) * (i - r) + (n - o) * (n - o)) } function sd(t, e, i) { var n = t[0], r = t[1], o = t[2], s = Math.abs(n - e), a = Math.abs(r - i); return s + a <= o || !(o < s || o < a) && Math.sqrt(s * s + a * a) < o + 1e-12 } function ad(t, e, i, n) { var r = t[0] - e, o = t[1] - i, s = t[2] - n; return r * r + o * o < s * s + 1e-6 } function ud(t, e, i, n, r, o, s) { var a = t - Math.max(n, Math.min(o, t)), u = e - Math.max(r, Math.min(s, e)); return a * a + u * u < i * i } function ld(t, e, i, n, r, o, s, a) { void 0 === a && (a = { x: 0, y: 0 }); var u, l, d, h, c = a || { x: 0, y: 0 }; if (i === t) { var f = t - r, g = s * s - f * f; if (g < 0) return null; var p = Math.sqrt(g); d = u = t, l = o + p, h = o - p } else { var _ = (n - e) / (i - t), v = e - _ * t, m = v - o, y = _ * _ + 1, b = 2 * (_ * m - r), x = b * b - 4 * y * (r * r + m * m - s * s); if (x < 0) return null; var E = -b, A = Math.sqrt(x), S = 2 * y; l = _ * (u = (E + A) / S) + v, h = _ * (d = (E - A) / S) + v } var w = t - u, T = e - l, C = t - d, M = e - h; return w * w + T * T < C * C + M * M ? (c.x = u, c.y = l) : (c.x = d, c.y = h), c } function dd(t, e, i, n, r, o) { !function (t, e, i, n, r) { var o = n.source, s = n.target, a = e.source.get(i), u = e.target.get(i), l = o.x.get(a), d = o.y.get(a), h = o.radius.get(a), c = o.color.get(a), f = +("scaled" === o.scalingMethod.get(a)), g = s.x.get(u), p = s.y.get(u), _ = s.radius.get(u), v = s.color.get(u), m = +("scaled" === s.scalingMethod.get(u)), y = function (t, e, i) { return "source" === t ? e : "target" === t ? i : t }(e.color.get(i), c, v), b = e.width.get(i), x = +("scaled" === e.scalingMethod.get(i)), E = e.stroke.width.get(i), A = +("scaled" === e.stroke.scalingMethod.get(i)), S = Ys[e.shape.style.get(i)], w = e.adjustAnchors.get(i); if (t.source = a, t.target = u, t.sourceX = l, t.sourceY = d, t.targetX = g, t.targetY = p, t.sourceRadiusScaled = h * f, t.sourceRadiusFixed = h * (1 - f), t.targetRadiusScaled = _ * m, t.targetRadiusFixed = _ * (1 - m), t.widthScaled = b * x, t.widthFixed = b * (1 - x), t.curvature = e.curvature.get(i), t.isSelfLoop = a === u, t.color = y, t.opacity = e.opacity.get(i), t.minVisibleSize = e.minVisibleSize.get(i), t.shape.type = e.shape.type.get(i), t.shape.head = e.shape.head.get(i), t.shape.tail = e.shape.tail.get(i), t.shape.dashLength = S.dash, t.shape.gapLength = S.gap, t.shape.isBodyTriangle = "triangle" === t.shape.type, t.stroke.color = kl(e.stroke.color.get(i), y), t.stroke.widthScaled = E * A, t.stroke.widthFixed = E * (1 - A), t.stroke.minVisibleSize = e.stroke.minVisibleSize.get(i), t.halo.color = e.halo.color.get(i), t.outline.enabled = e.outline.enabled.get(i), t.textHidden = 1 === e.textHidden.get(i), w && (t.shape.head || t.shape.tail || "triangle" === t.shape.type)) { var T = t, C = T.curvature, M = T.sourceX, I = T.sourceY, L = T.targetX, N = T.targetY, k = 1, O = 1; if (C) { if (!T.isSelfLoop) { var F = $s(M, I, L, N, C / 2); k = cd(T, r, o, a, M, I, F.x, F.y), O = cd(T, r, s, u, L, N, F.x, F.y) } } else k = cd(T, r, o, a, M, I, L, N), O = cd(T, r, s, u, L, N, M, I); t.sourceRadiusScaled *= k, t.sourceRadiusFixed *= k, t.targetRadiusScaled *= O, t.targetRadiusFixed *= O } }(e, i, n, r, o), hd(t, e.texts.primary, i.text, n, e), hd(t, e.texts.secondary, i.text.secondary, n, e) } function hd(t, e, i, n, r) { e.hidden = r.textHidden, e.content = t.formatText(i.content.get(n)), e.backgroundColor = kl(i.backgroundColor.get(n), r.color) } function cd(t, e, i, n, r, o, s, a) { var u = e.angle, l = Math.atan2(a - o, s - r) - u, d = 1, h = 0, c = null; l < -Os ? l += Fs : Os < l && (l -= Fs), c = l < -Os / 2 ? (h = Rs, i.badges.topLeft) : l < 0 ? (h = Ps, i.badges.topRight) : l < Os / 2 ? (h = zs, i.badges.bottomRight) : (h = Ds, i.badges.bottomLeft), h += u; var f, g = c.text.content.get(n), p = c.image.url.get(n); if ((f = g) || 0 === f || p) { var _ = c.positionScale.get(n), v = c.scale.get(n), m = ld(s, a, r, o, r + (x = Math.cos(h)) * _, o + (E = Math.sin(h)) * _, v); if (m) { var y = m.x - r, b = m.y - o, distance = Math.sqrt(y * y + b * b); d = Math.max(d, distance) } } if ("square" === i.shape.get(n)) { var x = Math.abs(Math.cos(l)), E = Math.abs(Math.sin(l)), A = 1 / Math.max(x, E); d = Math.max(d, A) } return d } function fd() { return { source: 0, target: 0, sourceX: 0, sourceY: 0, targetX: 0, targetY: 0, sourceRadiusScaled: 0, sourceRadiusFixed: 0, targetRadiusScaled: 0, targetRadiusFixed: 0, widthScaled: 0, widthFixed: 0, curvature: 0, isSelfLoop: !1, color: "", opacity: 0, minVisibleSize: 0, shape: { type: "line", head: null, tail: null, dashLength: 0, gapLength: 0, isBodyTriangle: !1 }, stroke: { color: "", widthScaled: 0, widthFixed: 0, minVisibleSize: 0 }, halo: { widthScaled: 0, widthFixed: 0, color: "" }, outline: { enabled: !1, color: "", minVisibleSize: 0 }, textHidden: !1, texts: { primary: gd(), secondary: gd() } } } function gd() { return { align: "left", hidden: !1, content: "", backgroundColor: "", font: "", color: "", sizeScaled: 0, sizeFixed: 0, style: "none", minVisibleSize: 0, margin: 0, padding: 0, maxLineLength: 0, widthScaled: 0, widthFixed: 0, heightScaled: 0, heightFixed: 0, positionAngle: 0, adjustAngle: !1, offsetAngle: 0 } } function pd(t, e) { _d(t.body, e, !0, !0), _d(t.outline, e, e.outline.enabled, !0), _d(t.halo, e, !!e.halo.color, !1), vd(t.texts.primary, e.texts.primary), vd(t.texts.secondary, e.texts.secondary) } function _d(t, e, value, i) { t.body = value, t.head = value && i && !!e.shape.head, t.tail = value && i && !!e.shape.tail } function vd(t, e) { t.text = !e.hidden && !!e.content, t.background = t.text && !!e.backgroundColor } function md(t, e, i, n) { yd(t, e, i, n), t.thicknessOrFontSizeScaled = e.widthScaled, t.thicknessOrFontSizeFixed = e.widthFixed, t.strokeWidthScaled = e.stroke.widthScaled, t.strokeWidthFixed = e.stroke.widthFixed, t.offsetScaled = 0, t.offsetFixed = 0, t.fillColor = e.color, t.strokeColor = e.stroke.color, t.globalMinVisibleSize = e.minVisibleSize, t.strokeMinVisibleSize = e.stroke.minVisibleSize, t.offsetAngle = 0, t.symbolicSize = e.widthScaled, t.dashLength = e.shape.dashLength, t.gapLength = e.shape.gapLength, t.hasHead = !!e.shape.head, t.hasTail = !!e.shape.tail, t.isBodyTriangle = e.shape.isBodyTriangle } function yd(t, e, i, n) { t.pieceId = i, t.shape = n, t.x1 = e.sourceX, t.y1 = e.sourceY, t.x2 = e.targetX, t.y2 = e.targetY, t.rectWidthOrSourceRadiusScaled = e.sourceRadiusScaled, t.rectWidthOrSourceRadiusFixed = e.sourceRadiusFixed, t.rectHeightOrTargetRadiusScaled = e.targetRadiusScaled, t.rectHeightOrTargetRadiusFixed = e.targetRadiusFixed, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = 0, t.strokeWidthFixed = 0, t.offsetScaled = 0, t.offsetFixed = 0, t.pattern.type = 0, t.opacity = e.opacity, t.fillColor = null, t.strokeColor = null, t.patternColor = null, t.globalMinVisibleSize = e.minVisibleSize, t.strokeMinVisibleSize = null, t.patternMinVisibleSize = 0, t.offsetAngle = 0, t.patternScale = 0, t.symbolicSize = e.widthScaled, t.curvature = e.curvature, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isSelfLoop = e.isSelfLoop, t.isText = !1 } function bd(t, e, i) { var n = e.widthScaled + 2 * e.halo.widthScaled, r = e.widthFixed + 2 * e.halo.widthFixed; yd(t, e, i, "line"), t.thicknessOrFontSizeScaled = n, t.thicknessOrFontSizeFixed = r, t.strokeWidthScaled = 0, t.strokeWidthFixed = 0, t.offsetScaled = 0, t.offsetFixed = 0, t.fillColor = e.halo.color, t.strokeColor = null, t.globalMinVisibleSize = e.minVisibleSize, t.strokeMinVisibleSize = 0, t.offsetAngle = 0, t.symbolicSize = e.widthScaled, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isBodyTriangle = !1 } function xd(t, e, i, n) { yd(t, e, i, n), t.thicknessOrFontSizeScaled = e.widthScaled * js, t.thicknessOrFontSizeFixed = e.widthFixed * js, t.strokeWidthScaled = 0, t.strokeWidthFixed = 0, t.offsetScaled = e.widthScaled * Gs, t.offsetFixed = e.widthFixed * Gs + Hs, t.fillColor = e.outline.color, t.strokeColor = null, t.globalMinVisibleSize = Math.max(e.minVisibleSize, e.outline.minVisibleSize), t.strokeMinVisibleSize = 0, t.offsetAngle = Math.PI / 2, t.symbolicSize = e.widthScaled, t.dashLength = e.shape.dashLength, t.gapLength = e.shape.gapLength, t.hasHead = !!e.shape.head, t.hasTail = !!e.shape.tail, t.isBodyTriangle = e.shape.isBodyTriangle } function Ed(t, e, i) { var n = (i.widthScaled + e.heightScaled) / 2 + i.stroke.widthScaled, r = (i.widthFixed + e.heightFixed) / 2 + i.stroke.widthFixed + e.padding + e.margin; t.pieceId = Mn, t.shape = "square", t.x1 = i.sourceX, t.y1 = i.sourceY, t.x2 = i.targetX, t.y2 = i.targetY, t.rectWidthOrSourceRadiusScaled = e.widthScaled, t.rectWidthOrSourceRadiusFixed = e.widthFixed + 2 * e.padding + 1, t.rectHeightOrTargetRadiusScaled = e.heightScaled, t.rectHeightOrTargetRadiusFixed = e.heightFixed + 2 * e.padding, t.thicknessOrFontSizeScaled = 0, t.thicknessOrFontSizeFixed = 0, t.strokeWidthScaled = i.sourceRadiusScaled + i.targetRadiusScaled, t.strokeWidthFixed = i.sourceRadiusFixed + i.targetRadiusFixed, t.offsetScaled = n, t.offsetFixed = r, t.pattern.type = 0, t.opacity = i.opacity, t.fillColor = null, t.strokeColor = null, t.patternColor = null, t.globalMinVisibleSize = Math.max(e.minVisibleSize, i.minVisibleSize), t.strokeMinVisibleSize = 0, t.patternMinVisibleSize = 0, t.offsetAngle = e.offsetAngle, t.patternScale = 0, t.symbolicSize = i.widthScaled, t.curvature = i.curvature, t.dashLength = 0, t.gapLength = 0, t.hasHead = !1, t.hasTail = !1, t.isSelfLoop = i.isSelfLoop, t.isText = !1, t.adjustTextAngle = e.adjustAngle } function Ad(t, e, i, n, r, o) { !function (t, e, i, n) { if (Sd(i.body, n, md), i.halo.body) { var r = e.halo.width.get(t), o = +("scaled" === e.halo.scalingMethod.get(t)); n.halo.widthScaled = r * o, n.halo.widthFixed = r * (1 - o), Sd(i.halo, n, bd) } i.outline.body && (n.outline.color = e.outline.color.get(t), n.outline.minVisibleSize = e.outline.minVisibleSize.get(t), Sd(i.outline, n, xd)) }(i, n, r, o), wd(t, e, i, n.text, r.texts.primary, o.texts.primary, o), wd(t, e, i, n.text.secondary, r.texts.secondary, o.texts.secondary, o) } function Sd(t, e, i) { i(t.body, e, wn, e.shape.type), t.head && i(t.head, e, Tn, e.shape.head), t.tail && i(t.tail, e, Cn, e.shape.tail) } function wd(t, e, i, n, r, o, s) { if (r.text) { var a = n, u = a.scaling.get(i); if (o.font = e.fontManager.getFont(a.font.get(i)), o.color = kl(a.color.get(i), s.color), o.style = a.style.get(i), o.minVisibleSize = a.minVisibleSize.get(i), o.margin = a.margin.get(i), o.padding = a.padding.get(i), o.maxLineLength = a.maxLineLength.get(i), o.content = $o(o.content, o.maxLineLength), o.adjustAngle = a.adjustAngle.get(i), o.align = a.align.get(i), u) { var l = a.scale.get(i); o.sizeScaled = s.widthScaled * l, o.sizeFixed = s.widthFixed * l } else o.sizeFixed = a.size.get(i), o.sizeScaled = 0; var d = t.measureText(o.content, o.font, o.style); o.widthScaled = d.width * o.sizeScaled, o.widthFixed = d.width * o.sizeFixed, o.heightScaled = d.height * o.sizeScaled, o.heightFixed = d.height * o.sizeFixed, o.offsetAngle = o === s.texts.primary ? qs : Ws, Ed(f = r.text, g = o, s), f.pattern.type = An, f.pattern.attributes.text = g.content, f.pattern.attributes.size = "sdf", f.pattern.attributes.font = g.font, f.pattern.attributes.style = g.style, f.pattern.attributes.align = g.align, f.patternColor = g.color, f.patternScale = 1, f.thicknessOrFontSizeScaled = g.sizeScaled, f.thicknessOrFontSizeFixed = g.sizeFixed, f.isText = !0, r.background && (Ed(h = r.background, c = o, s), h.fillColor = c.backgroundColor) } var h, c, f, g } var Td = Ol(kd, "start"), Cd = Ol(kd, "end"), Md = Fl(kd), Id = (Ld.prototype.drawEdge = function (t) { if (this._computeBlockIds(t), this._attributes.excluded.get(t)) this._freeBlocks(); else { var e = this._engine, i = this._helper, n = this._extremitiesAttributes, r = -t, o = Gl(this._attributes.layer.get(t), this._depthInfo), s = this._attributes, a = s.source.get(t), u = s.target.get(t), l = s.curvature.get(t), d = this._attributesPrev.curvature.get(t), h = s.animationDuration.get(t), c = s.animationStart.get(t), f = s.animationEasing.get(t), g = 0 < h, p = 0 !== l || g && 0 !== d; if (this._prepareBlocks(g, o, r, p), n.source = this._nodeAttributes, n.target = this._nodeAttributes, dd(i, this._endInput, s, t, n, this._view), pd(this._endFlags, this._endInput), g) { var _ = 0 < this._nodeAttributes.animationDuration.get(a), v = 0 < this._nodeAttributes.animationDuration.get(u); n.source = _ ? this._nodeAttributesPrev : this._nodeAttributes, n.target = v ? this._nodeAttributesPrev : this._nodeAttributes, dd(i, this._startInput, this._attributesPrev, t, n, this._view), pd(this._startFlags, this._startInput), Md(this._endFlags, this._startFlags) } this._initComponents(this._fullComponents, this._endFlags, this._blocks), Cd(this._fullComponents, this._endComponents), Ad(e, i, t, this._attributes, this._endComponents, this._endInput), g && (Td(this._fullComponents, this._startComponents), Ad(e, i, t, this._attributesPrev, this._startComponents, this._startInput), this._setBlocksAnimation(h, c, f)), this._setupHaloMasking(a, u), this._storeBlocks() } }, Ld.prototype._setupHaloMasking = function (t, e) { var i = this._nodeAttributes.halo, n = this._blocks, r = i.color.get(t) && i.hideNonAdjacentEdges.get(t), o = i.color.get(e) && i.hideNonAdjacentEdges.get(e), s = r || o ? 1 : 3; n.body.setStencilUsage(s), n.text.setStencilUsage(s), n.textBg.setStencilUsage(s) }, Ld.prototype._computeBlockIds = function (t) { var e = 10 * t, i = this._blockIds; i.body = 5 + e, i.halo = 8 + e, i.text = 6 + e, i.textBg = 7 + e }, Ld.prototype._prepareBlocks = function (t, e, i, n) { var r = this._blocks; r.body.reset(n ? 3 : 1, t, e.edgeBody, i), r.halo.reset(n ? 3 : 1, t, e.edgeHalo, i), r.text.reset(2, t, e.edgeText, i), r.textBg.reset(1, t, e.edgeTextBackground, i) }, Ld.prototype._storeBlocks = function () { var t = this._engine, e = this._blocks, i = this._blockIds; t.storeBlock(i.body, e.body), t.storeBlock(i.halo, e.halo), t.storeBlock(i.text, e.text), t.storeBlock(i.textBg, e.textBg) }, Ld.prototype._freeBlocks = function () { var t = this._engine, e = this._blockIds; t.freeBlock(e.body), t.freeBlock(e.halo), t.freeBlock(e.text), t.freeBlock(e.textBg) }, Ld.prototype._setBlocksAnimation = function (t, e, i) { var n = this._blocks; n.body.setGlobalAnimation(t, e, i), n.halo.setGlobalAnimation(t, e, i), n.text.setGlobalAnimation(t, e, i), n.textBg.setGlobalAnimation(t, e, i) }, Ld.prototype._initComponents = function (t, e, i) { this._initEdgeComponents(t.halo, e.halo, i.halo), this._initEdgeComponents(t.outline, e.outline, i.body), this._initEdgeComponents(t.body, e.body, i.body), this._initTextComponents(t.texts.primary, e.texts.primary, i), this._initTextComponents(t.texts.secondary, e.texts.secondary, i) }, Ld.prototype._initEdgeComponents = function (t, e, i) { t.head = this._nextElement(e.head, i), t.tail = this._nextElement(e.tail, i), t.body = this._nextElement(e.body, i) }, Ld.prototype._initTextComponents = function (t, e, i) { t.background = this._nextElement(e.background, i.textBg), t.text = this._nextElement(e.text, i.text) }, Ld.prototype._nextElement = function (t, e) { return t ? e.next() : this._nullElt }, Ld); function Ld(t) { var e = t.engine, i = t.imageManager, n = t.fontManager, r = t.formatText, o = t.view, s = t.attributes, a = t.attributesPrev, u = t.nodeAttributes, l = t.nodeAttributesPrev; this._extremitiesAttributes = { source: null, target: null }, this._fullComponents = kd(), this._startComponents = kd(), this._endComponents = kd(), this._startFlags = kd(), this._endFlags = kd(), this._startInput = fd(), this._endInput = fd(), this._depthInfo = jl(), this._nullElt = { id: -1, valid: !0, animation: null, start: null, end: null }, this._engine = e, this._view = o, this._helper = { imageManager: i, fontManager: n, formatText: r }, this._attributes = s, this._attributesPrev = a, this._nodeAttributes = u, this._nodeAttributesPrev = l, this._blocks = Nd(function () { return e.createBlock() }), this._blockIds = Nd(function () { return 0 }) } function Nd(t) { return { body: t(), halo: t(), text: t(), textBg: t() } } function kd() { return { halo: { body: void 0, head: void 0, tail: void 0 }, outline: { body: void 0, head: void 0, tail: void 0 }, body: { body: void 0, head: void 0, tail: void 0 }, texts: { primary: { text: void 0, background: void 0 }, secondary: { text: void 0, background: void 0 } } } } function Od(t) { var e, i, n, r, o, s = t.graph, a = t.elements, u = t.engine, l = t.imageManager, d = t.fontManager, h = t.view, c = t.attributes, f = t.boundaries, g = t.formatText, p = (i = $((e = c).nodes.current, { text: { secondary: { scaling: e.nodes.current.text.scaling, maxLineLength: e.nodes.current.text.maxLineLength } } }), n = $(e.nodes.previous, { textHidden: i.textHidden, text: { secondary: { scaling: e.nodes.previous.text.scaling, maxLineLength: e.nodes.previous.text.maxLineLength } } }), r = $(e.edges.current, { text: { secondary: { scaling: e.edges.current.text.scaling, maxLineLength: e.edges.current.text.maxLineLength, adjustAngle: e.edges.current.text.adjustAngle } } }), o = $(e.edges.previous, { source: e.edges.current.source, target: e.edges.current.target, textHidden: e.edges.current.textHidden, text: { secondary: { scaling: e.edges.previous.text.scaling, maxLineLength: e.edges.previous.text.maxLineLength, adjustAngle: e.edges.previous.text.adjustAngle } } }), { nodeAttributes: i, nodeAttributesPrev: n, edgeAttributes: r, edgeAttributesPrev: o }), _ = p.nodeAttributes, v = p.nodeAttributesPrev, m = p.edgeAttributes, y = p.edgeAttributesPrev, b = a.nodes, x = a.edges, E = f.maxSize, A = f.maxMinVisibleSize; if (b.size || x.size) { var S = 10 * (Math.max(s.getNodeMaxIndex(), s.getEdgeMaxIndex()) + 1), w = u.setGlobalBoundaries({ maxBlockId: qe(S), maxScaledSize: qe(8 * E), maxMinVisibleSize: qe(A), maxSymbolicSize: qe(E), maxDashLength: 3, maxGapLength: 1, maxPatternScale: 2 }), T = (w ? s.getNodes("_all") : b)._indexes, C = (w ? s.getEdges("_all") : x)._indexes; if (T.length) for (var M = new id({ engine: u, imageManager: l, fontManager: d, formatText: g, attributes: _, attributesPrev: v }), I = 0; I < T.length; ++I)M.drawNode(T[I]); if (C.length) { var L = new Id({ engine: u, imageManager: l, fontManager: d, formatText: g, view: h, attributes: m, attributesPrev: y, nodeAttributes: _, nodeAttributesPrev: v }); for (I = 0; I < C.length; ++I)L.drawEdge(C[I]) } } } var Fd = gt && document.fonts, Rd = "/qwerty/ [HELLO] ", Pd = (Dd.prototype._measureText = function (t, e) { return this._ctx.font = "12px " + e, this._ctx.measureText(t).width }, Dd.prototype.check = function (t) { if (this._checkReliable) return this._fontFaceSet.check("12px " + t); var e = this._measureText(Rd, "serif"); return this._measureText(Rd, t) !== e }, Dd.prototype.load = function (t) { return this._fontFaceSet && this._fontFaceSet.load ? this._fontFaceSet.load("12px " + t) : (this._ctx.font = "12px " + t, this._ctx.fillText(Rd, 10, 50), Promise.resolve()) }, Dd); function Dd() { this._fontFaceSet = Fd ? document.fonts : null, this._canvas = nr(), this._checkReliable = this._fontFaceSet && this._fontFaceSet.check && !this._fontFaceSet.check("12px FontThatDoesNotExist"), this._ctx = this._canvas.getContext("2d") } var zd = (Bd.prototype._setLoaded = function () { this._loaded = !0, this._value = this._fontName }, Bd.prototype.getValue = function () { return this._value }, Bd.prototype.isLoaded = function () { return this._loaded }, Bd.prototype.destroy = function () { clearTimeout(this._timeout) }, Bd.prototype.load = function () { var t = this; return this._tryLoad(200).then(function () { t._setLoaded() }) }, Bd.prototype._tryLoad = function (e) { var i = this; return this._fontFaceSet.load(this._fontName).then(function () { if (!i._fontFaceSet.check(i._fontName)) return new Promise(function (t) { e < 6e4 && (i._timeout = setTimeout(t, e)) }).then(function () { return i._tryLoad(1.5 * e) }) }) }, Bd); function Bd(t, e) { this._loaded = !1, this._value = null, this._timeout = null, this._fontFaceSet = t, this._fontName = e, this._loaded = !1, this._value = null, this._timeout = null, gt && !this._fontFaceSet.check(this._fontName) || this._setLoaded() } var Ud = (Vd.prototype.setHideUntilFontsLoaded = function (value) { this._hideUntilFontsLoaded = value }, Vd.prototype.getFont = function (t) { var e = this, i = this._fonts[t]; return i || (i = new zd(this._fontFaceSet, t), (this._fonts[t] = i).isLoaded() || i.load().then(function () { return e._triggerFontLoaded(t) })), !this._hideUntilFontsLoaded && t || i.getValue() }, Vd.prototype.onFontLoaded = function (t) { this._onFontLoaded.push(t) }, Vd.prototype.destroy = function () { var e = this; this._onFontLoaded = [], Object.keys(this._fonts).forEach(function (t) { return e._fonts[t].destroy() }) }, Vd.prototype._triggerFontLoaded = function (e) { this._onFontLoaded.forEach(function (t) { return t(e) }) }, Vd); function Vd() { this._fontFaceSet = new Pd, this._fonts = {}, this._onFontLoaded = [], this._hideUntilFontsLoaded = !0 } function jd(t, e, i) { for (var n = i.length, r = n - 1, o = !1, s = 0; s < n; ++s)(i[s].y < e && i[r].y >= e || i[r].y < e && i[s].y >= e) && (i[s].x <= t || i[r].x <= t) && (o = o !== i[s].x + (e - i[s].y) / (i[r].y - i[s].y) * (i[r].x - i[s].x) < t), r = s; return o } function Gd(t) { var e = t.x * t.x + t.y * t.y; return { x: t.x / e, y: t.y / e } } function Hd(t, e) { for (var i = 1 / 0, n = -1 / 0, r = 0, o = t.length; r < o; r++) { var s = t[r], a = s.x * e.x + s.y * e.y; a < i && (i = a), n < a && (n = a) } return { x: i, y: n } } function qd(t, e) { for (var i = function (t, e) { var i = t[1], n = t[0], r = Gd({ x: i.x - n.x, y: i.y - n.y }), o = r.x; r.x = -r.y, r.y = o; var s = r; i = t[2], n = t[1], o = (r = Gd({ x: i.x - n.x, y: i.y - n.y })).x, r.x = -r.y, r.y = o; var a = r; i = e[1], n = e[0], o = (r = Gd({ x: i.x - n.x, y: i.y - n.y })).x, r.x = -r.y, r.y = o; var u = r; return i = e[2], n = e[1], o = (r = Gd({ x: i.x - n.x, y: i.y - n.y })).x, r.x = -r.y, r.y = o, [s, a, u, r] }(t, e), n = 0, r = i.length; n < r; n++) { var o = i[n], s = Hd(t, o), a = Hd(e, o); if (0 == (s.x <= a.y && s.y >= a.x ? Math.min(s.y, a.y) - Math.max(s.x, a.x) : 0)) return !1 } return !0 } function Wd(t) { var e = 0, i = 0, n = t.length; if (0 === n) throw new Error("Compute centroid: at least one point is required"); for (var r = 0; r < n; ++r) { var o = t[r]; e += o.x, i += o.y } return { x: e /= n, y: i /= n } } var Xd = sh(4), Yd = sh(5), Zd = sh(10, .4), Kd = 1 / 3, Qd = [{ x: -1, y: -Kd }, { x: -.55, y: -Kd }, { x: -1, y: -1 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: -.55, y: Kd }, { x: -1, y: Kd }], Jd = [{ x: -.6, y: -.3 }, { x: .1, y: 0 }, { x: -.6, y: .3 }], $d = { circle: { getDistanceFromStrokeVertically: function (t, e) { return 1 }, getDistanceFromStrokeHorizontally: function (t, e) { return 1 - Math.sqrt(t * t + e * e) }, points: [{ x: 0, y: 0, r: 1 }], isSimple: !0 }, square: { getDistanceFromStrokeVertically: function (t, e) { return 1 - Math.abs(e) }, getDistanceFromStrokeHorizontally: function (t, e) { return 1 - Math.abs(t) }, points: [{ x: -1, y: -1 }, { x: 1, y: -1 }, { x: 1, y: 1 }, { x: -1, y: 1 }], isSimple: !0 }, line: { getDistanceFromStrokeVertically: function (t, e) { return 1 - Math.abs(e) }, getDistanceFromStrokeHorizontally: function (t, e) { return 1 }, points: [{ x: -1, y: 0 }, { x: 1, y: 0 }], isSimple: !0 }, triangle: { getDistanceFromStrokeVertically: function (t, e) { return (1 - t) / 2 - Math.abs(e) }, getDistanceFromStrokeHorizontally: function (t, e) { return 1 - Math.abs(t) }, points: [{ x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 0 }], isSimple: !0 }, arrow: { getDistanceFromStrokeVertically: function (t, e) { return (1 - t) / 2 - Math.abs(e) }, getDistanceFromStrokeHorizontally: function (t, e) { return 1 - Math.abs(t) }, points: [{ x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 0 }], isSimple: !0 }, "circle-hole-arrow": { getDistanceFromStrokeVertically: function (t, e) { return Math.min(Math.sqrt((t + .4) * (t + .4) + e * e) - .27, (1 - t) / 2 - Math.abs(e)) }, getDistanceFromStrokeHorizontally: function (t, e) { return 1 - Math.abs(t) }, points: [{ x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 0 }], hole: [{ x: -.4, y: 0, r: .3 }], isSimple: !0 }, "triangle-hole-arrow": { getDistanceFromStrokeVertically: function (t, e) { var i = Math.min((1 - t) / 2 - Math.abs(e), 1 - Math.abs(t)), n = -oh(t, e, Jd); return Math.min(i, n) }, getDistanceFromStrokeHorizontally: function (t, e) { return 1 }, points: [{ x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 0 }], hole: Jd, isSimple: !0 }, "short-arrow": ah([{ x: -1, y: -Kd }, { x: 0, y: -Kd }, { x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: Kd }, { x: -1, y: Kd }], !1), "sharp-arrow": ah(Qd, !1), cross: { getDistanceFromStrokeVertically: function (t, e) { return 1 }, getDistanceFromStrokeHorizontally: function (t, e) { var i = Math.abs(t), n = Math.abs(e), r = .31 - Math.min(i, n), o = 1 - Math.max(i, n); return Math.min(r, o) }, points: [{ x: -1, y: .31 }, { x: -1, y: -.31 }, { x: -.31, y: -.31 }, { x: -.31, y: -1 }, { x: .31, y: -1 }, { x: .31, y: -.31 }, { x: 1, y: -.31 }, { x: 1, y: .31 }, { x: .31, y: .31 }, { x: .31, y: 1 }, { x: -.31, y: 1 }, { x: -.31, y: .31 }], isSimple: !1 }, diamond: ah(Xd), pentagon: ah(Yd), star: ah(Zd) }, th = ["circle", "square", "triangle", "line"], eh = ["cross", "diamond", "pentagon", "star"], ih = ["arrow", "triangle-hole-arrow", "circle-hole-arrow", "short-arrow", "sharp-arrow"]; function nh(t, e) { for (var i = 0, n = th; i < n.length; i++) { rh(t, n[i]) } for (var r = e.nodes.current.shape.getValues(), o = e.edges.current.shape.head.getValues(), s = e.edges.current.shape.tail.getValues(), a = 0, u = eh; a < u.length; a++) { var l = u[a]; r.includes(l) && rh(t, l) } for (var d = 0, h = ih; d < h.length; d++) { var c = h[d]; (o.includes(c) || s.includes(c)) && rh(t, c) } } function rh(t, e) { t.registerShape(e, $d[e]) } function oh(t, e, i) { for (var n = 1 / 0, r = { x: t, y: e }, o = 0; o < i.length; ++o) { var s = i[o], a = i[(o + 1) % i.length]; n = Math.min(n, eu(r, s, a)) } return n * (jd(t, e, i) ? 1 : -1) } function sh(t, e) { void 0 === e && (e = 1); for (var i = -Math.PI / 2 + 1e-6, n = [], r = 2 * Math.PI / t, o = i, s = 0; s < t; ++s) { var a = s % 2 == 1 ? e : 1; n.push({ x: Math.cos(o) * a, y: Math.sin(o) * a }), o += r } return n } function ah(i, t) { return void 0 === t && (t = !1), { getDistanceFromStrokeVertically: function () { return 1 }, getDistanceFromStrokeHorizontally: function (t, e) { return oh(t, e, i) }, points: i, isSimple: t } } var uh, lh; (lh = uh = uh || {}).ZOOM = "zoom", lh.ROTATE = "rotate"; var dh = { duration: 0, easing: "linear", startAfter: 0, ignoreZoomLimits: !(lh.PAN = "pan"), callback: function () { } }; function hh(t) { return Math.abs(t) < 1e-9 } var ch, fh = (b(gh, ch = Ae), Object.defineProperty(gh.prototype, "x", { get: function () { return this._x }, enumerable: !0, configurable: !0 }), Object.defineProperty(gh.prototype, "y", { get: function () { return this._y }, enumerable: !0, configurable: !0 }), Object.defineProperty(gh.prototype, "zoom", { get: function () { return this._zoom }, enumerable: !0, configurable: !0 }), Object.defineProperty(gh.prototype, "angle", { get: function () { return this._angle }, enumerable: !0, configurable: !0 }), Object.defineProperty(gh.prototype, "width", { get: function () { return this._dimensions.width }, enumerable: !0, configurable: !0 }), Object.defineProperty(gh.prototype, "height", { get: function () { return this._dimensions.height }, enumerable: !0, configurable: !0 }), gh.prototype.moveEnd = function (t) { var e = this; this._dom.clearTimeout(this._timeout), this._timeout = this._dom.setTimeout(function () { e._timeout = null, e._events.fire(xe.VIEW_CHANGED, { type: t }) }, 80) }, gh.prototype.getSize = function () { return { width: this._dimensions.width, height: this._dimensions.height } }, gh.prototype.getCenter = function () { return { x: this._x, y: this._y } }, gh.prototype.setCenter = function (t, e) { var i = this, n = t.x, r = t.y, o = C({}, dh, e), s = this._x, a = this._y, u = n - this._x, l = r - this._y; return hh(u) && hh(l) ? Promise.resolve() : new Promise(function (t) { o.callback = function () { i.moveEnd(uh.PAN), t() }, i._moveAnimation && i._animations.end(i._moveAnimation, !1), i._moveAnimation = i._animations.play(function (t) { i._x = s + u * t, i._y = a + l * t, i._events.fire(xe.CAMERA_MOVE), i._events.fire(xe.CAMERA_PAN) }, o) }) }, gh.prototype.move = function (t, e) { var i = ph({ x: t.x, y: t.y }, this._zoom, this._sinAngle, this._cosAngle); return this.setCenter({ x: this._x + i.x, y: this._y + i.y }, e) }, gh.prototype.getZoom = function () { return this._zoom }, gh.prototype.setZoom = function (t, h, e) { var c = this; void 0 === e && (e = { refX: void 0, refY: void 0 }), h = C({}, dh, h); var f = e.refX, g = e.refY, p = Xe(t, this._minZoom, this._maxZoom); return h.ignoreZoomLimits || (p = this._applyZoomLimits(p)), hh(this._zoom - p) ? Promise.resolve() : new Promise(function (t) { var e = c._dimensions.width / 2, i = c._dimensions.height / 2, n = c._zoom, r = e / n - e / p; if (h.callback = function () { c.moveEnd(uh.ZOOM), t() }, void 0 !== f && void 0 !== g) { var o = (f - e) / n - (f - e) / p, s = (g - i) / n - (g - i) / p, a = c._cosAngle, u = c._sinAngle, l = a * o - u * s, d = u * o + a * s; c.setCenter({ x: c._x + l, y: c._y + d }, h) } c._zoomAnimation && c._animations.end(c._zoomAnimation, !1), c._dom.setTimeout(function () { c._events.fire(xe.START_ZOOM, { duration: h.duration, easing: h.easing, startZoom: n, endZoom: p }) }), c._zoomAnimation = c._animations.play(function (t) { c._zoom = e / (e / n - r * t), c._events.fire(xe.CAMERA_MOVE), c._events.fire(xe.CAMERA_ZOOM) }, h) }) }, gh.prototype._applyZoomLimits = function (t) { var e = this._settings.get("interactions.zoom.minValue"), i = this._settings.get("interactions.zoom.maxValue"), n = this._modules.locate.getGraphBoundingBox(), r = this._zoom, o = this.getSize(), s = t; if (!isNaN(n.cx)) { var a = { smallestNodeSize: n.minScaledSize, biggestNodeSize: n.maxScaledSize, graphWidth: n.width + n.maxScaledSize, graphHeight: n.height + n.maxScaledSize, viewWidth: o.width, viewHeight: o.height }, u = e && e(a), l = i && i(a); _h(u) && s < u ? s < r && (s = Math.min(r, u)) : _h(l) && l < s && r < s && (s = Math.max(r, l)) } return s }, gh.prototype.zoomIn = function (t, e, i) { return void 0 === i && (i = { refX: void 0, refY: void 0 }), "number" != typeof t && (i = e, e = t, t = this._settings.get("interactions.zoom.modifier")), this.setZoom(this._zoom * t, e, i) }, gh.prototype.zoomOut = function (t, e, i) { return void 0 === i && (i = { refX: void 0, refY: void 0 }), "number" != typeof t && (i = e, e = t, t = this._settings.get("interactions.zoom.modifier")), this.setZoom(this._zoom / t, e, i) }, gh.prototype.getAngle = function () { return this._angle }, gh.prototype.setAngle = function (t, e) { var i = this; e = C({}, dh, e); var n = this._angle, r = t - n; return hh(r) ? Promise.resolve() : new Promise(function (t) { e.callback = function () { i.moveEnd(uh.ROTATE), t() }, i._rotateAnimation && i._animations.end(i._rotateAnimation, !1), i._rotateAnimation = i._animations.play(function (t) { for (i._angle = n + r * t; i._angle > Math.PI;)i._angle -= 2 * Math.PI; for (; i._angle < -Math.PI;)i._angle += 2 * Math.PI; i._sinAngle = Math.sin(i._angle), i._cosAngle = Math.cos(i._angle), i._events.fire(xe.CAMERA_MOVE), i._events.fire(xe.CAMERA_ROTATE) }, e) }) }, gh.prototype.rotate = function (t, e) { return this.setAngle(this._angle + t, e) }, gh.prototype.getScreenCenter = function () { return { x: this._dimensions.width / 2, y: this._dimensions.height / 2 } }, gh.prototype.graphToScreenCoordinates = function (t, e) { var i = t.x, n = t.y; void 0 === e && (e = { x: 0, y: 0 }); var r = this._dimensions.width / 2, o = this._dimensions.height / 2; return la((i - this._x) * this._zoom + r, (n - this._y) * this._zoom + o, r, o, -this._angle, e) }, gh.prototype.screenToGraphCoordinates = function (t, e) { var i = t.x, n = t.y; return void 0 === e && (e = { x: 0, y: 0 }), la(this._x + (i - this._dimensions.width / 2) / this._zoom, this._y + (n - this._dimensions.height / 2) / this._zoom, this._x, this._y, this._angle, e) }, gh.prototype.projectBounds = function (t, e) { void 0 === e && (e = t); for (var i = t[0], n = t[1], r = t[2], o = t[3], s = this._x, a = this._y, u = this._dimensions.width / 2, l = this._dimensions.height / 2, d = this._sinAngle, h = this._cosAngle, c = 1 / this._zoom, f = 1 / 0, g = 1 / 0, p = -1 / 0, _ = -1 / 0, v = [i, n, i, o, r, o, r, n], m = 0; m < v.length; m += 2) { var y = v[m], b = v[m + 1], x = (y = s + (y - u) * c) - s, E = (b = a + (b - l) * c) - a; (y = h * x - d * E + s) < f && (f = y), p < y && (p = y), (b = d * x + h * E + a) < g && (g = b), _ < b && (_ = b) } return e[0] = f, e[1] = g, e[2] = p, e[3] = _, e }, gh.prototype.screenToGraphVector = function (t) { return ph({ x: t.x, y: t.y }, this._zoom, this._sinAngle, this._cosAngle) }, gh.prototype.getView = function () { return { x: this._x, y: this._y, zoom: this._zoom, angle: this._angle, width: this._dimensions.width, height: this._dimensions.height } }, gh.prototype.setView = function (t, e) { var i = C({ x: this._x, y: this._y, zoom: this._zoom, angle: this._angle }, t), n = i.x, r = i.y, o = i.zoom, s = i.angle; return Promise.all([this.setCenter({ x: n, y: r }, e), this.setZoom(o, e), this.setAngle(s, e)]).then(function () { }) }, gh.prototype._reloadDimensions = function () { this._dimensions = this._dom.getDimensions() }, gh.prototype.animationInProgress = function () { var t = this._moveAnimation, e = this._zoomAnimation; return t && !t.done || e && !e.done }, gh.prototype.getProjectedScreenBounds = function (t) { void 0 === t && (t = 0); var e = this._dimensions, i = e.width, n = e.height, r = Math.max(i, n) * t; return this.projectBounds([0 - r, 0 - r, i + r, n + r]) }, gh.prototype._reset = function () { this._zoom = 1, this._x = 0, this._y = 0, this._angle = 0, this._sinAngle = 0, this._cosAngle = 1, this._dimensions = this._dom.getDimensions() }, gh); function gh(t) { var e = ch.call(this) || this; return e._modules = t, e._events = t.events, e._dom = t.dom, e._animations = t.animations, e._settings = t.settings, e._zoomAnimation = null, e._moveAnimation = null, e._reset(), e._minZoom = 1e-8, e._maxZoom = 1e8, e._settings.register("minZoom", 1e-8, function (t) { e._minZoom = t, e._zoom < t && (e._zoom = t, e._events.fire(xe.CAMERA_MOVE)) }), e._settings.register("maxZoom", 1e8, function (t) { e._maxZoom = t, e._zoom > t && (e._zoom = t, e._events.fire(xe.CAMERA_MOVE)) }), e._timeout = null, e._events.on({ setContainer: function () { e._reset(), e._events.fire(xe.CAMERA_MOVE) }, resize: function () { e._reloadDimensions(), e._events.fire(xe.CAMERA_MOVE) } }), e } function ph(t, e, i, n) { var r = t.x, o = t.y; return { x: n * (r /= e) - i * (o /= e), y: i * r + n * o } } function _h(value) { return "number" == typeof value && isFinite(value) } var vh, mh = { maxBlockId: 1024, maxScaledSize: 16, maxPixelSize: 255, maxMinVisibleSize: 64, maxDashOffset: 4, maxDashLength: 3, maxGapLength: 1, maxSymbolicSize: 0, maxPatternScale: 0 }, yh = ft ? "webgl" : null, bh = (b(xh, vh = Ae), xh.prototype.onMounted = function (t, e) { var i = this; void 0 !== e.renderer && t.setOptions({ renderer: e.renderer }), void 0 !== e.imgCrossOrigin && t.setOptions({ imgCrossOrigin: e.imgCrossOrigin }), this._dom.addWindowEventListener("unload", function () { i.destroy() }) }, xh.prototype.getTransparentBackgroundColor = function () { var t = this._settings.get("backgroundColor"); return t ? this._engine.transparentify(t) : null }, xh.prototype._render = function () { var t = this._dom.getDimensions(), e = this._camera.getView(), i = wt(), n = Kt(), r = this._settings.get("backgroundColor"), o = this._isBufferDisplayable; this._engine.setView({ x: e.x, y: e.y, zoom: e.zoom, angle: e.angle, width: t.width, height: t.height, pixelRatio: i, currentTime: n, backgroundColor: r, isBufferDisplayable: o }); try { this._engine.render(), "requested" === this._rendererState.state && this._updateRendererState({ state: "ok" }) } catch (t) { if (this._debug) throw t; var s = t.message, a = t.code, u = void 0 === a ? "OTHER" : a, l = this._rendererState.type, d = this._formatRendererName(l), h = "requested" === this._rendererState.state ? "Error while initializing the " + d + " renderer" : "The " + d + " renderer encountered an unexpected runtime error", c = null; "webgl" === l && (h += "; fallbacking on canvas renderer", c = "canvas"), hi(s), hi(h), this._updateRendererState({ state: "error", code: u, message: s }), this._settings.set("renderer", c) } }, xh.prototype._formatRendererName = function (t) { return "webgl" === t ? "WebGL" : "svg" === t ? "SVG" : t }, xh.prototype._fireRendererStateChangeEvent = function () { this._events.fire(xe.RENDERER_STATE_CHANGE, { type: this._rendererState.type, state: this._rendererState.state, code: this._rendererState.code, message: this._rendererState.message }) }, xh.prototype._updateRendererState = function (t) { var e = t.type, i = t.state, n = t.code, r = t.message, o = !1; void 0 !== e && this._rendererState.type !== e && (this._rendererState.type = e, o = !0), void 0 !== i && this._rendererState.state !== i && (this._rendererState.state = i, o = !0), void 0 !== n && this._rendererState.code !== n && (this._rendererState.code = n, o = !0), void 0 !== r && this._rendererState.message !== r && (this._rendererState.message = r, o = !0), o && this._initDone && this._fireRendererStateChangeEvent() }, xh.prototype.getImageData = function () { var t = this; return this._dom.afterNextFrame().then(function () { return t._engine.getImageData() }) }, xh.prototype.addCanvas = function (t) { this._engine.addCanvas(t) }, xh.prototype.removeCanvas = function (t) { this._engine.removeCanvas(t) }, xh.prototype.getNodeAttributes = function () { return this._attributesManager.getFlexArrays().nodes.current }, xh.prototype.getEdgeAttributes = function () { return this._attributesManager.getFlexArrays().edges.current }, xh.prototype.getGraphicsEngine = function () { return this._engine }, xh.prototype.getImageManager = function () { return this._imageManager }, xh.prototype.getFontManager = function () { return this._fontManager }, xh.prototype.allocateGraphicsEngineBlockId = function () { return this._availableGeIndexes.length ? this._availableGeIndexes.pop() : 10 * this._nextGeIndex++ + 9 }, xh.prototype.releaseGraphicsEngineBlockId = function (t) { this._engine.freeBlock(t), this._availableGeIndexes.push(t), this._dom.refresh() }, xh.prototype.addCursorStyle = function (t) { t && (this._cursorStyle.push(t), this._applyCursorStyle()) }, xh.prototype.removeCursorStyle = function (t) { if (t) { var e = this._cursorStyle.lastIndexOf(t); -1 !== e && (this._cursorStyle.splice(e, 1), this._applyCursorStyle()) } }, xh.prototype.reloadFonts = function () { this._events.fire(xe.RELOAD_FONTS), this._engine.notifyFontsReloaded(), this._dom.refresh() }, xh.prototype.getDomElement = function () { return this._domElement }, xh.prototype.setTextHidden = function (t, e) { this._attributesManager.setTextHidden(t, e) }, xh.prototype.resetTextHidden = function () { this._attributesManager.resetTextHidden(), this._dom.refresh() }, xh.prototype.getAttributesManager = function () { return this._attributesManager }, xh.prototype._checkFontsNewlyLoaded = function () { return !!this._fontsNewlyLoaded.length && (this._fontsNewlyLoaded = [], !0) }, xh.prototype._loadGraphInGraphicsEngine = function () { this._attributesManager.update(), this._checkFontsNewlyLoaded() && this._attributesManager.redrawAll(); var t = this._attributesManager.getAndResetElementsToRedraw(), e = this._attributesManager.getAndResetElementsUpdated(), i = 0 < e.nodes.size || 0 < e.edges.size; (e.nodeAttributes.includes("radius") || e.edgeAttributes.includes("width")) && (this._boundaries.maxSize = function (t) { for (var e = t.getNodeAttribute("radius"), i = t.getEdgeAttribute("width"), n = t.getNodes(), r = t.getEdges(), o = 0, s = 0, a = 0; a < n._indexes.length; a++) { var u = n._indexes[a], l = e.get(u); o < l && (o = l) } for (a = 0; a < r._indexes.length; a++) { u = r._indexes[a]; var d = i.get(u); s < d && (s = d) } return Math.max(2 * o, s) }(this._graph)), (e.nodeAttributes.includes("shape") || e.edgeAttributes.includes("shape.head") || e.edgeAttributes.includes("shape.tail")) && nh(this._engine, this._attributesManager.getFlexArrays()), Od({ graph: this._graph, elements: t, engine: this._engine, imageManager: this._imageManager, fontManager: this._fontManager, view: this._camera.getView(), attributes: this._attributesManager.getFlexArrays(), boundaries: this._boundaries, formatText: this._formatText }), i && this._events.fire(xe.UPDATE_ATTRIBUTES, e) }, xh.prototype._forceCompleteGraphRefresh = function () { this._attributesManager.redrawAll(), this._loadGraphInGraphicsEngine() }, xh.prototype.export = function (e, i, r, n) { var o, s = this; return Promise.all([this._graph.getNodes().addClass(fl), this._graph.getEdges().addClass(fl)]).then(function () { return s.resolveAtNextFrame() }).then(function () { return s._imageManager.whenReady() }).then(function () { var t; return "all" === r ? (t = s._graph, o = { nodes: Eh(t, !0), edges: Eh(t, !1) }, s._forceCompleteGraphRefresh()) : s._loadGraphInGraphicsEngine(), s._engine.export(e, i, n) }).then(function (t) { return Promise.all([s._graph.getNodes().removeClass(fl), s._graph.getEdges().removeClass(fl)]).then(function () { return t }) }).then(function (t) { var e, i, n; return "all" === r && (i = (e = o).nodes, n = e.edges, Ah(i), Ah(n), s._forceCompleteGraphRefresh()), t }) }, xh.prototype.addAttributeLayer = function (t) { return this._attributesManager.addAttributeLayer(t) }, xh.prototype.createFlexArrays = function () { return this._attributesManager.createFlexArrays() }, xh.prototype.getAttributeValues = function (t, e, i, n) { return this._attributesManager.getAttributeValues(t, e, i, n) }, xh.prototype.forceAttributesComputation = function () { this._attributesManager.update() }, xh.prototype.resolveAtNextFrame = function (t) { return this._dom.afterNextFrame().then(function () { return t }) }, xh.prototype.animate = function (t, e, i) { var n = function (t) { return "number" == typeof t ? t = { duration: t } : "object" == typeof t && null !== t || (t = { duration: 0 }), { duration: function (t) { return "number" != typeof t || !isFinite(t) || t < 0 ? 0 : t }(t.duration), easing: t.easing || "linear", chain: !!t.chain } }(i); return n.duration && this._engine.ensureAnimationsReady(), this._animate(t, e, n) }, xh.prototype.isAnimating = function () { return 0 < this._animations.length }, xh.prototype.getAnimationInformation = function (t) { return this._attributesManager.getAnimationInformation(t) }, xh.prototype._toSubGraph = function (t) { if (t instanceof tn || t instanceof Ji) return { nodes: t.toList(), edges: t.getAdjacentEdges() }; if (t instanceof Pi || t instanceof Fi) return { nodes: this._graph.nodeList(), edges: t.toList() }; var e = t, i = { nodes: e.nodes || this._graph.nodeList(), edges: e.edges || this._graph.edgeList() }; return i.nodes.size && (i.edges.size ? i.edges = i.edges.concat(i.nodes.getAdjacentEdges()).dedupe() : i.edges = i.nodes.getAdjacentEdges()), i }, xh.prototype._animate = function (e, t, i) { var n = i.duration, r = i.easing; if (!this._animations.length && !n) return t(e), Promise.resolve(e); var o = this._toSubGraph(e), s = o.nodes, a = o.edges; if (!s.size && !a.size) return Promise.resolve(e); s.size && this._events.fire(xe.ANIMATE, { elements: s, duration: n, easing: r }), a.size && this._events.fire(xe.ANIMATE, { elements: a, duration: n, easing: r }); for (var u = { id: this._nextAnimationId++, startTime: -1, finished: !1, func: function () { return t(e) }, duration: n, easing: r, nodes: s, edges: a, resolve: void 0 }, l = new Promise(function (t) { return u.resolve = function () { return t(e) } }), d = 0; d < s._indexes.length; d++)this._nodeAnimationList.set(s._indexes[d], u.id); for (d = 0; d < a._indexes.length; d++)this._edgeAnimationList.set(a._indexes[d], u.id); return this._animations.push(u), this._dom.refresh(), n || this._processAnimations(), l }, xh.prototype._endAnimation = function (t) { t.resolve(t.elements), t.finished = !0 }, xh.prototype._removeFinishedAnimations = function () { this._animations = this._animations.filter(function (t) { return !t.finished }) }, xh.prototype._getAnimationElements = function (t) { for (var e = [], i = [], n = 0; n < t.nodes._indexes.length; n++) { var r = t.nodes._indexes[n]; this._nodeAnimationList.get(r) === t.id && e.push(r) } for (n = 0; n < t.edges._indexes.length; n++)r = t.edges._indexes[n], this._edgeAnimationList.get(r) === t.id && i.push(r); return { nodes: this._graph.nodeList(new Uint32Array(e)), edges: this._graph.edgeList(new Uint32Array(i)) } }, xh.prototype._resetAnimationAttributes = function (t) { var e = t.nodes, i = t.edges; this._attributesManager.resetAnimationAttributes({ nodes: e, edges: i }), this._nodeAnimationList.fill(e._indexes, 0), this._edgeAnimationList.fill(i._indexes, 0) }, xh.prototype._processAnimations = function () { if (this._animations.length) { var t = Kt(), e = []; this._attributesManager.update(); for (var i = 0, n = this._animations; i < n.length; i++)-1 === (u = n[i]).startTime && (u.startTime = t, e.push(u.func), 0 < u.duration && this._attributesManager.setAnimationAttributes(this._getAnimationElements(u), u)); for (var r = 0, o = e; r < o.length; r++)(0, o[r])(); for (var s = 0, a = this._animations; s < a.length; s++) { var u; t >= (u = a[s]).startTime + u.duration && (this._resetAnimationAttributes(this._getAnimationElements(u)), this._endAnimation(u)) } this._removeFinishedAnimations(), this._animations.length && this._dom.refresh() } }, xh.prototype.hideTexts = function () { this.setNodeTextsVisibility(!1), this.setEdgeTextsVisibility(!1) }, xh.prototype.showTexts = function () { this.setNodeTextsVisibility(!0), this.setEdgeTextsVisibility(!0) }, xh.prototype.setNodesVisibility = function (value) { return this._updateVisibilityCounter("nodes", value) }, xh.prototype.setNodeTextsVisibility = function (value) { return this._updateVisibilityCounter("nodeTexts", value) }, xh.prototype.setEdgesVisibility = function (value) { return this._updateVisibilityCounter("edges", value) }, xh.prototype.setEdgeTextsVisibility = function (value) { return this._updateVisibilityCounter("edgeTexts", value) }, xh.prototype._updateVisibilityCounter = function (t, value) { this._visibility[t] += value ? -1 : 1, this._dom.refresh() }, xh.prototype.detectNode = function (t) { return function (t, e, i, n, r, o) { var s = t.x, a = t.y, u = t.margin, l = t.texts, d = t.indexes; d = d || e.getNodes()._indexes; var h = n.getZoom(), c = e.getObjectList(!0), f = i.getFlexArrays().nodes.current, g = 0; i.update(); for (var p = 0; p < d.length; ++p) { var _ = d[p]; if (!f.excluded.get(_) && f.detectable.get(_) && 0 === f.animationDuration.get(_)) { var v = f.x.get(_), m = f.y.get(_), y = n.graphToScreenCoordinates({ x: v, y: m }), b = y.x, x = y.y, E = f.shape.get(_), A = "scaled" === f.scalingMethod.get(_), S = f.radius.get(_) * (A ? h : 1), w = S + u, T = (s - b) / w, C = (a - x) / w; if (r.checkShapeHit(E, T, C)) g = _; else if (l) { var M = o(f.text.content.get(_)), I = f.textHidden.get(_), L = f.text.minVisibleSize.get(_); if (!I && M && L <= (A ? 2 * S : 1 / 0)) { var N = $o(M, f.text.maxLineLength.get(_)), k = f.innerStroke.width.get(_), O = f.outerStroke.width.get(_), F = f.text.margin.get(_), R = f.text.padding.get(_), P = f.text.size.get(_), D = f.text.scale.get(_), z = f.text.scaling.get(_), B = f.text.font.get(_), U = f.text.style.get(_), V = f.text.position.get(_), j = r.measureText(N, B, U, 1), G = z ? D * S : P, H = j.width * G / 2 + R + u, q = j.height * G / 2 + R + u, W = mu[V], X = k + O + F + S, Y = b + (X + H) * W.x, Z = x + (X + q) * W.y; Y - H < s && s < Y + H && Z - q < a && a < Z + q && (g = _) } } } } return c.get(g) || null }(t, this._graph, this._attributesManager, this._camera, this._engine, this._formatText) }, xh.prototype.detectEdge = function (t) { return function (t, e, i, n) { var r = t.margin, o = (t.texts, t.indexes), s = void 0 === o ? e.getEdges()._indexes : o, a = e.getObjectList(!1), u = n.getFlexArrays(), l = u.edges.current, d = u.nodes.current, h = i.getZoom(), c = r / h, f = i.screenToGraphCoordinates(t), g = f.x, p = f.y, _ = 0; n.update(); for (var v = 0; v < s.length; ++v) { var m = s[v], y = l.source.get(m), b = l.target.get(m), x = l.excluded.get(m), E = l.detectable.get(m), A = 0 !== l.animationDuration.get(m), S = 0 !== d.animationDuration.get(y), w = 0 !== d.animationDuration.get(b); if (!x && E && !A && !S && !w) { var T = y === b, C = l.curvature.get(m), M = "triangle" === l.shape.type.get(m), I = "scaled" === l.scalingMethod.get(m), L = l.width.get(m) / (I ? 1 : h), N = d.x.get(y), k = d.y.get(y), O = d.x.get(b), F = d.y.get(b); if (T) { var R = "scaled" === d.scalingMethod.get(y); gu(g, p, N, k, N, k, (P = ta(N, k, C, d.radius.get(y) / (R ? 1 : h), 0)).x1, P.y1, P.x2, P.y2, L, c) && (_ = m) } else if (0 !== C) { var P; cu(g, p, N, k, O, F, (P = $s(N, k, O, F, C)).x, P.y, L, c, M) && (_ = m) } else Ya(g, p, N, k, O, F, L, c, M) && (_ = m) } } return a.get(_) || null }(t, this._graph, this._camera, this._attributesManager) }, xh.prototype.getVisibilityCounters = function () { return this._visibility }, xh.prototype.destroy = function () { this.getGraphicsEngine().destroy(), this.getImageManager().destroy(), this.getFontManager().destroy() }, xh); function xh(t, e) { var i, n = t.dom, r = t.graph, o = t.camera, s = t.events, a = t.settings, u = vh.call(this) || this; return u._debug = !1, u._initDone = !1, u._boundaries = { maxSize: 10, maxMinVisibleSize: 64 }, u._visibility = { nodes: 0, edges: 0, nodeTexts: 0, edgeTexts: 0 }, u._nextAnimationId = 1, u._animations = [], u._rendererState = { type: null, code: null, state: "ok", message: "" }, u._cursorStyle = [], u._fontsNewlyLoaded = [], u._nextGeIndex = 1, u._availableGeIndexes = [], u._isBufferDisplayable = function (t) { var e, i = (e = t.getDepth()) === Ss || e === As || Is <= (e - ws) % ks, n = Rl(t), r = i ? u._visibility.nodes : u._visibility.edges, o = i ? u._visibility.nodeTexts : u._visibility.edgeTexts; return 0 === r && (!n || 0 === o) }, u._applyCursorStyle = function () { var t = u._cursorStyle[u._cursorStyle.length - 1] || u._settings.get("cursor.default"); Vt(u._domElement, t) }, u._updateImageCrossOrigin = function () { u._imageManager.setImgCrossOrigin(u._settings.get("imgCrossOrigin")) }, u._debug = e.isDebug(), u._events = s, u._dom = n, u._graph = r, u._camera = o, u._events = s, u._settings = a, u._formatText = ns().applyArabicShaping, u._attributesManager = new Ll(r, n, e), u._imageManager = new Wa, u._fontManager = new Ud, u._engine = new Va(Va.getCachedInitData()), u._domElement = u._engine.getDomElement(), u._nodeAnimationList = u._graph.createNodeAttribute({ storage: 32, default: 0 }), u._edgeAnimationList = u._graph.createEdgeAttribute({ storage: 32, default: 0 }), u._events.register([xe.RELOAD_FONTS, xe.RENDERER_STATE_CHANGE, xe.UPDATE_ATTRIBUTES, xe.ANIMATE, xe.CAMERA_MOVE, xe.CAMERA_PAN, xe.CAMERA_ZOOM, xe.CAMERA_ROTATE, xe.VIEW_CHANGED, xe.START_ZOOM]), u._settings.register("renderer", yh, function (t) { u._updateRendererState({ type: t, state: "requested", code: null, message: null }), u._engine.setRenderType(t), u._dom.refresh() }), u._settings.register("backgroundColor", "white", function (t) { u._engine.parseColor(t) ? u._dom.refresh() : (hi('Invalid background color "' + t + '" specified; will default to black.'), u._settings.set("backgroundColor", "black")) }), u._settings.register("texts.hideUntilFontsLoaded", !0, function (t) { u._fontManager.setHideUntilFontsLoaded(t) }), u._settings.register("imgCrossOrigin", "anonymous", u._updateImageCrossOrigin), u._settings.register("cursor.default", "default", u._applyCursorStyle), u._dom.setLayer("graphics", u._domElement), u._engine.setGlobalBoundaries(mh), u._dom.beforeNextFrame().then(function () { u._initDone = !0, u._fireRendererStateChangeEvent() }), u._imageManager.onFetch(function () { u._engine.notifyPatternUpdate(), u._dom.refresh() }), u._fontManager.onFontLoaded(function (t) { u._fontsNewlyLoaded.push(t), u._engine.notifyPatternUpdate(), u._dom.refresh() }), u._dom.addMediaListener("(min-resolution: 2dppx)", function () { u._dom.refresh() }), u._visibleAttributeLayer = u._attributesManager.addAttributeLayer({ priority: 0, name: "internal(" + ol + ")", tag: ol, nodeOutput: { attributes: "all" }, edgeOutput: { attributes: "all" }, nodeDependencies: null, edgeDependencies: null }), u._dataAttributeLayer = u._attributesManager.addAttributeLayer({ priority: 0, name: "internal(" + sl + ")", tag: sl, nodeDependencies: null, edgeDependencies: null }), nh(u._engine, u._attributesManager.getFlexArrays()), u._events.on(((i = {})[xe.CAMERA_MOVE] = function () { return u._dom.refresh() }, i[xe.NEW_FRAME] = function () { u._processAnimations(), u._loadGraphInGraphicsEngine(), u._render() }, i[xe.CLEAR_GRAPH] = function () { u._nextGeIndex = 1, u._availableGeIndexes = [], u._engine.clear(), u._attributesManager.clear(), u._dom.refresh() }, i[xe.VIEW_CHANGED] = function (t) { if (t.type === uh.ROTATE) { var e = u._graph.getEdges().filter(function (t) { return t.getAttribute("adjustAnchors") }); u._attributesManager.redrawElements(e) } }, i[xe.ADD_NODES + " " + xe.ADD_EDGES] = function (t) { u._attributesManager.updateForAllAttributeLayers(t.nodes || t.edges) }, i[xe.EXCLUDED_STATE_CHANGE] = function (t) { u._visibleAttributeLayer.updateElements(t.elements) }, i[xe.SET_DATA] = function (t) { u._dataAttributeLayer.updateElements(t.elements) }, i)), Va.clearCachedInitData(), u } function Eh(t, e) { var i = e ? t.getNodeAttribute("excluded") : t.getEdgeAttribute("excluded"), n = (e ? t.getNodes("all") : t.getEdges("all"))._indexes, r = i.getMultiple(n); return i.fill(n, 0), { excludedList: i, indexes: n, values: r } } function Ah(t) { var e = t.excludedList, i = t.indexes, n = t.values; e.setMultiple(i, n) } var Sh, wh = (b(Th, Sh = Ae), Th.prototype.register = function (t, e) { var i = this; void 0 === e && (e = []), t.forEach(function (t) { if (i._events[t]) throw new Error('event "' + t + '" already exists'); i._events[t] = new Ch(!1, t) }), e.forEach(function (t) { if (i._events[t]) throw new Error('event "' + t + '" already exists'); i._events[t] = new Ch(!0, t) }) }, Th.prototype.onAnyEvent = function (t) { this._onAnyEvents.push(t) }, Th.prototype.on = function (t, e) { var i = this; return "string" == typeof t ? t.split(" ").filter(function (t) { return !!t }).forEach(function (t) { return Ih(i._events, t, "event").on(e) }) : V(t, function (t, e) { return i.on(e, t) }), this }, Th.prototype.removeListener = function (e) { V(this._events, function (t) { t.off(e) }) }, Th.prototype.fire = function (e, i) { void 0 === i && (i = null); var t = Ih(this._events, e, "event"); return this._onAnyEvents.forEach(function (t) { return t(e, i) }), t.trigger(i), this }, Th.prototype.once = function (t, e) { var i = this, n = function () { e.apply(null, arguments), i.removeListener(n) }; this.on(t, n) }, Th); function Th() { var t = null !== Sh && Sh.apply(this, arguments) || this; return t._events = {}, t._onAnyEvents = [], t } var Ch = (Mh.prototype.trigger = function (t) { for (var e = 0, i = this._handlers; e < i.length; e++)(0, i[e])(t, this._name); return this }, Mh.prototype.on = function (t) { if ("function" != typeof t) throw new Error("handler is not a function"); var e = this._reverseOrder ? 0 : this._subscribers.length; return this._handlers.splice(e, 0, t), this._subscribers.splice(e, 0, t), this }, Mh.prototype.off = function (t) { for (var e; -1 !== (e = this._subscribers.indexOf(t));)this._subscribers.splice(e, 1), this._handlers.splice(e, 1); return this }, Mh); function Mh(t, e) { this._subscribers = [], this._handlers = [], this._reverseOrder = t, this._name = e } function Ih(t, e, i) { if (!(e in t)) throw new Error(i + " " + e + " does not exist"); return t[e] } var Lh, Nh = (b(kh, Lh = Ae), kh.prototype.getOriginalAttributes = function () { return this._originalAttributesLayer.getFlexArrays() }, kh.prototype.setMultipleAttributes = function (t, e, i, n) { var r = this; return this._graphics.animate(t, function () { r._individualAttributesLayer.setAttributeValues(t, e, n) }, i) }, kh.prototype.setSingleAttribute = function (t, e, i, n) { var r = {}; return G(r, e, i), this.setMultipleAttributes(t, r, n) }, kh.prototype.resetMultipleAttributes = function (t, e, i) { var n = this; e = e || this._individualAttributesLayer.getUsedAttributeNames(t); for (var r = {}, o = 0, s = e; o < s.length; o++) { var a = s[o]; G(r, a, void 0) } return this._graphics.animate(t, function () { n._individualAttributesLayer.setAttributeValues(t, r) }, i) }, kh.prototype.getMultipleAttributes = function (t, e) { return this._graphics.getAttributeValues(t, e, !0, !1) }, kh.prototype.getSingleAttribute = function (t, e) { return this._graphics.getAttributeValues(t, e, !1, !1) }, kh.prototype.replaceOriginalAttributes = function (t, e, i) { void 0 === i && (i = []); for (var n = {}, r = this._originalAttributesLayer.getUsedAttributeNames(t).filter(function (t) { return !i.includes(t) }), o = 0; o < r.length; ++o)G(n, r[o], void 0); this._originalAttributesLayer.setAttributeValues(t, n), this._originalAttributesLayer.setAttributeValues(t, e) }, kh.prototype.getSinglePreviousAttribute = function (t, e) { return this._graphics.getAttributeValues(t, e, !1, !0) }, kh.prototype.getMultiplePreviousAttributes = function (t, e) { return this._graphics.getAttributeValues(t, e, !0, !0) }, kh); function kh(t) { var e = t.events, i = t.graphics, o = Lh.call(this) || this; return o._events = e, o._graphics = i, o._events.on({ "addNodes addEdges": function (t) { var e = t.nodes, i = t.edges, n = e || i, r = t.objects.map(function (t) { return t.attributes }); o._originalAttributesLayer.setAttributeValues(n, r) } }), o._originalAttributesLayer = o._graphics.addAttributeLayer({ name: "original-attributes", priority: 1, nodeOutput: { attributes: "all" }, edgeOutput: { attributes: "all" }, nodeDependencies: null, edgeDependencies: null }), o._individualAttributesLayer = o._graphics.addAttributeLayer({ name: "individual-attributes", priority: 4, nodeOutput: { attributes: "all" }, edgeOutput: { attributes: "all" }, nodeDependencies: null, edgeDependencies: null }), o } var Oh, Fh = (b(Rh, Oh = Ae), Rh.prototype.onMounted = function (t, e) { e.renderer && this.update({ renderer: e.renderer }), e.options && this.update(e.options) }, Rh.prototype.register = function (t, e, i, n) { return void 0 === n && (n = !0), this._keys.push(t), this._currentValue[t] = e, this._defaultValues[t] = e, this._onChange[t] = i || function () { }, i && n && i(e), this }, Rh.prototype.update = function (t) { t = q(t); for (var e = this._keys, i = {}, n = 0; n < e.length; ++n) { var r = e[n]; if (r in t) { var value = t[r]; void 0 === value && (value = this._defaultValues[r]), i[r] = this._currentValue[r], this._currentValue[r] = value } } var o = Object.keys(i); for (n = 0; n < o.length; ++n) { var s = o[n], a = this._currentValue[s], u = i[s]; a !== u && this._onChange[s](a, u) } return W(i) }, Rh.prototype.get = function (t) { return arguments.length ? this._currentValue[t] : W(this._currentValue) }, Rh.prototype.set = function (t, value) { var e = this._currentValue[t], i = this._onChange[t]; this._currentValue[t] = value, i && i(value, e) }, Rh); function Rh() { var t = null !== Oh && Oh.apply(this, arguments) || this; return t._currentValue = {}, t._onChange = {}, t._defaultValues = {}, t._keys = [], t } var Ph = (Dh.prototype.getName = function () { return this._name }, Dh.prototype.getIndex = function () { return this._classes.getIndex(this._name) }, Dh.prototype.setIndex = function (t) { return this._classes.setIndex(this._name, t) }, Dh.prototype.update = function (t) { return this._classes.update(this._name, t), this }, Dh.prototype.getDefinition = function () { return this._classes.getDefinition(this._name) }, Dh.prototype.getNodes = function () { return this._classes.getElementsByClass(this._name).nodes }, Dh.prototype.getEdges = function () { return this._classes.getElementsByClass(this._name).edges }, Dh.prototype.clearNodes = function () { this.getNodes().removeClass(this._name) }, Dh.prototype.clearEdges = function () { this.getEdges().removeClass(this._name) }, Dh.prototype.add = function (t) { t.addClass(this._name) }, Dh.prototype.remove = function (t) { t.removeClass(this._name) }, Dh); function Dh(t, e) { this._classes = t, this._name = e } var zh, Bh = (b(Uh, zh = Ae), Uh.prototype._getClassList = function (t) { return t ? this._builtinClasses : this._userClasses }, Uh.prototype.createClass = function (t) {
    void 0 === t && (t = {}); var e = t.name, i = t.isBuiltin, n = t.after, r = t.nodeAttributes, o = t.nodeDependencies, s = t.nodeOutput, a = t.edgeAttributes, u = t.edgeDependencies, l = t.edgeOutput; if ("string" != typeof e) throw new Error('the "name" argument should be a string'); var d = this._getClassList(i), h = n ? function (t, e) { for (var i = 0; i < t.length; ++i)if (t[i].name === e) return i; return -1 }
/* eslint-disable */(d, n) + 1 : d.length; if (-1 === h) throw new Error('createClass: class specified as `after` parameter "' + n + '" does not exist'); if (i && !e.startsWith("_")) throw new Error('invalid builtin class name "' + e + "\": builtin classes should start with '_'"); var c = new Do(this._graph), f = new Ph(this, e), g = { name: e, elementSet: c, attributeLayer: this._graphics.addAttributeLayer({ name: "class(" + e + ")", tag: e, standaloneSelectors: !0, nodeAttributes: r, edgeAttributes: a, nodeSelector: function (t, e) { return e.hasElement(t) }, edgeSelector: function (t, e) { return e.hasElement(t) }, nodeContext: c, edgeContext: c, nodeOutput: s, edgeOutput: l, nodeDependencies: o, edgeDependencies: u }), isBuiltin: i, wrapper: f }; return d.splice(h, 0, g), i && d.sort(function (t, e) { return _l.indexOf(t.name) - _l.indexOf(e.name) }), this._updatePriorities(i), this._classesByName[e] = g, this._events.register([Vh(e, !0, !0), Vh(e, !0, !1), Vh(e, !1, !0), Vh(e, !1, !1)]), f
    }, Uh.prototype._updatePriorities = function (t) { for (var e = this._getClassList(t), i = 5 + (t ? .5 : 0), n = 0; n < e.length; ++n) { var r = i + 5e-4 * n; e[n].attributeLayer.update({ priority: r }) } }, Uh.prototype._get = function (t) { var e = this._classesByName[t]; if (!e) throw new Error('class "' + t + '" does not exist'); return e }, Uh.prototype.getIndex = function (t) { var e = this._get(t); return this._getClassList(e.isBuiltin).indexOf(e) }, Uh.prototype.setIndex = function (t, e) { var i = this._get(t), n = this._getClassList(i.isBuiltin), r = n.indexOf(i), o = Xe(e, 0, n.length - 1); n.splice(r, 1), n.splice(o, 0, i), this._updatePriorities(i.isBuiltin) }, Uh.prototype.update = function (t, e) { void 0 === e && (e = {}), this._get(t).attributeLayer.update({ nodeAttributes: e.nodeAttributes, edgeAttributes: e.edgeAttributes, nodeDependencies: e.nodeDependencies, edgeDependencies: e.edgeDependencies, nodeOutput: e.nodeOutput, edgeOutput: e.edgeOutput, fullOverwrite: e.fullOverwrite }) }, Uh.prototype.getDefinition = function (t) { var e = this._get(t).attributeLayer.getDefinition(), i = e.nodeAttributes, n = e.nodeDependencies, r = e.nodeOutput; return { nodeAttributes: i, edgeAttributes: e.edgeAttributes, nodeDependencies: n, edgeDependencies: e.edgeDependencies, nodeOutput: r, edgeOutput: e.edgeOutput } }, Uh.prototype._addOrRemoveClassesToElements = function (t, e, i) { for (var n = e.isNode, r = 0; r < t.length; ++r) { var o = t[r], s = this._get(o), a = s.elementSet, u = s.attributeLayer, l = a.addOrRemoveElements(e, i), d = Vh(o, n, i); l.size && (u.updateElements(l), this._events.fire(d, n ? { nodes: l } : { edges: l })) } }, Uh.prototype.addClassesToElements = function (t, e, i) { var n = this, r = e.toList(); return this._graphics.animate(e, function () { n._addOrRemoveClassesToElements(t, r, !0) }, i) }, Uh.prototype.removeClassesFromElements = function (t, e, i) { var n = this, r = e.toList(); return this._graphics.animate(e, function () { n._addOrRemoveClassesToElements(t, r, !1) }, i) }, Uh.prototype.hasSingleElementClass = function (t, e) { return this._get(t).elementSet.hasElement(e) }, Uh.prototype.getElementsClassList = function (t, e) { void 0 === e && (e = {}); for (var i = e.includeBuiltinClasses, n = void 0 !== i && i, r = new Array(t.size), o = 0; o < r.length; ++o)r[o] = []; return this._addClassNamesToList(r, t, this._userClasses), n && this._addClassNamesToList(r, t, this._builtinClasses), r }, Uh.prototype._addClassNamesToList = function (t, e, i) { for (var n = e.toList(), r = 0; r < i.length; ++r)for (var o = this._userClasses[r], s = o.name, a = o.elementSet, u = 0; u < n.size; ++u) { var l = n.get(u); a.hasElement(l) && t[u].push(s) } }, Uh.prototype.getClassByName = function (t, e) { void 0 === e && (e = !1); var i = this._classesByName[t] || null; if (e && !i) throw new Error('class "' + t + '" does not exist'); return i && i.wrapper }, Uh.prototype.getClassList = function () { return this._userClasses.map(function (t) { return t.wrapper }) }, Uh.prototype.getElementsByClass = function (t) { var e = this._get(t).elementSet.getElements(); return { nodes: e.nodes.filter(function (t) { return t.isVisible() }), edges: e.edges.filter(function (t) { return t.isVisible() }) } }, Uh.prototype._onClassEvent = function (t, e, i, n) { var r = Vh(t, i, n); this._events.on(r, e) }, Uh.prototype.onNodeClassAdded = function (t, e) { this._onClassEvent(t, e, !0, !0) }, Uh.prototype.onNodeClassRemoved = function (t, e) { this._onClassEvent(t, e, !0, !1) }, Uh.prototype.onEdgeClassAdded = function (t, e) { this._onClassEvent(t, e, !1, !0) }, Uh.prototype.onEdgeClassRemoved = function (t, e) { this._onClassEvent(t, e, !1, !1) }, Uh); function Uh(t) { var e, n = zh.call(this) || this; return n._builtinClasses = [], n._userClasses = [], n._classesByName = {}, n._events = t.events, n._graphics = t.graphics, n._graph = t.graph, n._events.on(((e = {})[xe.EXCLUDED_STATE_CHANGE] = function (t) { var e = t.elements; if (t.value) { var i = n._builtinClasses.map(function (t) { return t.name }); n._addOrRemoveClassesToElements(i, e, !1) } }, e.clear = function () { n._builtinClasses.concat(n._userClasses).forEach(function (t) { return t.elementSet.clear() }) }, e)), n } function Vh(t, e, i) { return (e ? "node" : "edge") + "Class" + (i ? "Added" : "Removed") + "_" + t } for (var jh, Gh, Hh = [0, 1], qh = [0, 2], Wh = 4; Wh < 65535; Wh <<= 2)for (var Xh = 0, Yh = Hh.length; Xh < Yh; Xh++)Hh.push(Hh[Xh] | Wh), qh.push((Hh[Xh] | Wh) << 1); function Zh(t, e) { return (qh[255 & e] | Hh[255 & t]) + 65536 * (qh[e >> 8 & 255] | Hh[t >> 8 & 255]) + 4294967296 * (qh[e >> 16 & 255] | Hh[t >> 16 & 255]) } function Kh(t, e) { if (void 0 === e && (e = []), 0xffffffffffff < t) throw "Only morton codes up to 48 bits are supported."; if (!jh) { jh = {}, Gh = {}; for (var i = 0; i < 256; i++)jh[Zh(i, 0)] = i, Gh[Zh(0, i)] = i } var n = jh[21845 & t], r = Gh[43690 & t]; return 65535 < t && (n |= jh[21845 & (t /= 65536)] << 8, r |= Gh[43690 & t] << 8, 65535 < t && (n |= jh[21845 & (t /= 65536)] << 16, r |= Gh[43690 & t] << 16)), e[0] = n, e[1] = r, e } Zh.code = function (t, e, i) { if (24 < t) throw "Morton codes are only supported up to Z=24"; var n = 1 << 24 - t; return Zh(e * n, i * n) }, Zh.range = function (t, e, i) { if (24 < t) throw "Morton ranges are only supported up to Z=24"; var n = 1 << 24 - t, r = Zh(e * n, i * n); return [r, r + n * n - 1] }, Zh.reverse = Kh, Zh.decode = function (t, e) { var i = Kh(e), n = 1 << 24 - t; return [i[0] / n, i[1] / n] }, Zh.min = function (t, e) { var i = 1431655765 & t, n = 1431655765 & e, r = 2863311530 & t, o = 2863311530 & e; return Math.min(i, n) + Math.min(r, o) }; function Qh(t, e, i) { void 0 === t && (t = Int32Array), void 0 === e && (e = 16), void 0 === i && (i = 8), this._BIG_LIST = new Uint8Array([-1])[0], this._ArrayType = t, this._capacity = e, this._MAX_LIST_SIZE = i, this._freeIndex = -1, this.clear() } var Jh = { averageSize: { configurable: !0 } }; function $h(t, e) { var i = new t.constructor(e); return i.set(t), i } Qh.prototype.clear = function () { this._buffer = new this._ArrayType(this._capacity * this._MAX_LIST_SIZE), this._sizes = new Uint8Array(this._capacity), this._bigLists = [], this._nextIndex = 0, this._idToIndex = {}, this._constList = new Array(this._MAX_LIST_SIZE) }, Qh.prototype.addEntry = function (t) { var e; return -1 === this._freeIndex ? e = this._nextIndex++ : (e = this._freeIndex, this._freeIndex = -1), (this._idToIndex[t] = e) >= this._capacity && this._expand(e + 1), this._sizes[e] = 0, e }, Qh.prototype.getItems = function (t) { var e = this._idToIndex[t]; if (void 0 !== e) { var i = this._sizes[e], n = this._MAX_LIST_SIZE * e; if (i <= this._MAX_LIST_SIZE) { for (var r = 0, o = this._constList.length = i; r < o; ++r)this._constList[r] = this._buffer[n + r]; return this._constList } if (i === this._BIG_LIST) { var s = this._buffer[n]; return this._bigLists[s] } } }, Qh.prototype.removeEntry = function (t) { var e = this._idToIndex[t]; if (this._sizes[e] === this._BIG_LIST) { var i = this._MAX_LIST_SIZE * e, n = this._buffer[i]; this._bigLists[n].length = 0 } this._sizes[e] = 0, this._freeIndex = e }, Qh.prototype.size = function (t) { var e = this._idToIndex[t], i = this._sizes[e]; return i <= this._MAX_LIST_SIZE ? i : this._bigLists[this._buffer[e * this._MAX_LIST_SIZE]].length }, Qh.prototype.sizes = function (t) { for (var e = this._sizes, i = this._bigLists, n = this._buffer, r = this._MAX_LIST_SIZE, o = t.length, s = new Array(o), a = 0; a < o; a++) { var u = this._idToIndex[t[a]], l = e[u]; s[a] = l <= r ? l : i[n[u * r]].length } return s }, Qh.prototype.addTo = function (t, value) { var e = this._idToIndex[t], i = this._sizes[e], n = e * this._MAX_LIST_SIZE; if (i < this._MAX_LIST_SIZE) this._buffer[n + i] = value, this._sizes[e] = i + 1; else if (i === this._BIG_LIST) { var r = this._buffer[n]; this._bigLists[r].push(value) } else { for (var o = new Array(this._MAX_LIST_SIZE), s = 0; s < this._MAX_LIST_SIZE; ++s)o[s] = this._buffer[n + s]; o.push(value), this._bigLists.push(o), this._sizes[e] = this._BIG_LIST, this._buffer[n] = this._bigLists.length - 1 } }, Qh.prototype.removeFrom = function (t, value) { this.removeFromAndGetSize(t, value) }, Qh.prototype.removeFromAndGetSize = function (t, value) { var e = this._idToIndex[t], i = this._sizes[e], n = this._MAX_LIST_SIZE * e; if (i <= this._MAX_LIST_SIZE) { for (var r = n, o = n + i; r < o; ++r)if (this._buffer[r] === value) return --i, this._buffer[r] = this._buffer[o - 1], this._sizes[e] = i } else if (i === this._BIG_LIST) { var s = this._buffer[n], a = this._bigLists[s], u = a.indexOf(value); if (-1 !== u) return a.splice(u, 1), a.length } }, Qh.prototype.reserve = function (t) { this._capacity < t && this._expand(t) }, Qh.prototype._expand = function (t) { this._capacity = Math.pow(2, Math.ceil(Math.log2(t))), this._buffer = $h(this._buffer, this._capacity * this._MAX_LIST_SIZE), this._sizes = $h(this._sizes, this._capacity) }, Qh.prototype.has = function (t) { var e = this._idToIndex[t]; return !(void 0 === e || e >= this._capacity) && 0 !== this._sizes[e] }, Jh.averageSize.get = function () { for (var t = 0, e = 0; e < this._capacity; e++)t += this._sizes[e]; return t / this._capacity }, Object.defineProperties(Qh.prototype, Jh); function tc(t, e, i) { return i | Zh(t, e) << 4 } function ec(t, e) { return void 0 === e && (e = []), Zh.reverse(t >> 4, e), e[2] = t & oc, e } function ic(t, e, i, n, r) { void 0 === i && (i = 16), void 0 === n && (n = 65536), void 0 === r && (r = Int32Array), this._intersects = t, this._getBounds = e, this._occupied = 0, this._cells = new Qh(r), this._objectsAtLevel = new Array(16).fill(0), this._idToCode = new nc, this._codeCache = [], this._offset = n, this._min = -n, this._max = n, this._resolution = 65535 / (this._max - this._min), this._minCellSize = i * this._resolution, this._bounds = new Array(64); for (var o = 0; o < 16; o++)this._bounds[4 * o] = 1 / 0, this._bounds[4 * o + 1] = 1 / 0, this._bounds[4 * o + 2] = -1 / 0, this._bounds[4 * o + 3] = -1 / 0 } var nc = "undefined" == typeof Map ? function () { function t() { this._values = {}, this._size = 0 } var e = { size: { configurable: !0 } }; return e.size.get = function () { return this._size }, t.prototype.has = function (t) { return !!this._values[t] }, t.prototype.set = function (t, value) { t in this._values || this._size++ , this._values[t] = value }, t.prototype.get = function (t) { return this._values[t] }, t.prototype.delete = function (t) { t in this._values && (delete this._values[t], this._size--) }, t.prototype.keys = function () { return Object.keys(this._values) }, t.prototype.clear = function () { this._values = {}, this._size = 0 }, Object.defineProperties(t.prototype, e), t }() : Map, rc = "undefined" == typeof Set ? function () { function t() { this._values = {}, this._size = 0 } var e = { size: { configurable: !0 } }; return e.size.get = function () { return this._size }, t.prototype.has = function (t) { return !!this._values[t] }, t.prototype.add = function (t) { t in this._values || this._size++ , this._values[t] = !0 }, t.prototype.delete = function (t) { t in this._values && (delete this._values[t], this._size--) }, t.prototype.keys = function () { return Object.keys(this._values) }, t.prototype.clear = function () { this._values = {}, this._size = 0 }, Object.defineProperties(t.prototype, e), t }() : Set, oc = (1 << Math.log2(16)) - 1, sc = { averageCellOccupancy: { configurable: !0 }, size: { configurable: !0 } }; ic.prototype.setMinCellSize = function (t) { return this._minCellSize = t, this }, ic.prototype.setOffset = function (t) { return this._offset = t, this._min = -t, this._max = t, this._resolution = 65535 / (this._max - this._min), this }, ic.prototype.setIntersector = function (t) { return this._intersects = t, this }, ic.prototype.setBoundsGetter = function (t) { return this._getBounds = t, this }, ic.prototype.insert = function (t, e) { void 0 === e && (e = this._getBounds(t)); var i, n = Math.max(e[2] - e[0], e[3] - e[1]), r = this._minCellSize; for (i = 0; r < n && i < 16; i++)r *= 2; var o = this._resolution, s = this._min, a = o * (.5 * (e[2] + e[0]) - s) / r | 0, u = o * (.5 * (e[3] + e[1]) - s) / r | 0, l = tc(a, u, i); this._cells.has(l) || this._cells.addEntry(l), this._cells.addTo(l, t), this._objectsAtLevel[i]++ , this._occupied |= 1 << i; var d = 4 * i, h = this._bounds; return a < h[d] && (h[d] = a), u < h[1 + d] && (h[1 + d] = u), a > h[2 + d] && (h[2 + d] = a), u > h[3 + d] && (h[3 + d] = u), this._idToCode.set(t, l), l }, ic.prototype.has = function (t) { return this._idToCode.has(t) }, ic.prototype.update = function (t, e) { return this.remove(t), this.insert(t, e) }, ic.prototype.remove = function (t) { var e = this._idToCode.get(t); ec(e, this._codeCache); var i = this._codeCache[2]; return 0 == --this._objectsAtLevel[i] && (this._occupied &= ~(1 << i), this._bounds[4 * i] = 1 / 0, this._bounds[4 * i + 1] = 1 / 0, this._bounds[4 * i + 2] = -1 / 0, this._bounds[4 * i + 3] = -1 / 0), this._cells.removeFrom(e, t), this._idToCode.delete(t), this }, ic.prototype.query = function (t) { var e = t[0], i = t[1], n = t[2], r = t[3], o = this._cells, s = this._bounds, a = this._intersects, u = this._min, l = this._resolution, d = this._minCellSize, h = this._occupied, c = []; e = l * (e - u), i = l * (i - u), n = l * (n - u), r = l * (r - u); for (var f = 0; f < 16 && 0 !== h; d *= 2, h >>= 1, f++)if (0 != (1 & h)) for (var g = 1 / d, p = 4 * f, _ = Math.max(s[p], e * g - 1 >> 0), v = Math.max(s[1 + p], i * g - 1 >> 0), m = Math.min(s[2 + p], n * g + 1 >> 0), y = Math.min(s[3 + p], r * g + 1 >> 0), b = _; b <= m; b++)for (var x = v; x <= y; x++) { var E = tc(b, x, f), A = o.getItems(E); if (void 0 !== A) for (var S = 0; S < A.length; S++) { var w = A[S]; a(w, t) && c.push(w) } } return c }, ic.prototype.collisions = function (t, e) { if (void 0 === e && (e = this._getBounds), "function" != typeof e) throw new Error("getBounds function is required to get the object bounds"); for (var i = Array.from(this._idToCode.keys()), n = this._min, r = this._resolution, o = this._cells, s = new nc, a = [], u = 0; u < i.length; u++) { var l = 0, d = this._minCellSize, h = this._occupied, c = i[u], f = e(c), g = f[0], p = f[1], _ = f[2], v = f[3], m = Math.max(_ - g, v - p); for (l = 0; d < m; l++)d *= 2, h >>= 1; g = r * (g - n), p = r * (p - n), _ = r * (_ - n), v = r * (v - n); for (var y = l; y < 16 && 0 !== h; d *= 2, h >>= 1, y++)if (0 != (1 & h)) for (var b = 1 / d, x = p * b - 1 >> 0, E = _ * b + 1 >> 0, A = v * b + 1 >> 0, S = g * b - 1 >> 0; S <= E; S++)for (var w = x; w <= A; w++) { var T = tc(S, w, y); if (s.get(T) !== u) { s.set(T, u); var C = o.getItems(T); if (void 0 !== C) for (var M = 0; M < C.length; M++) { var I = C[M]; I !== c && t(c, I) && a.push(c, I) } } } } return function (t) { for (var e = new rc, i = [], n = 0; n < t.length; n += 2) { var r = t[n], o = t[n + 1], s = r < o ? r * o + (o - r - 1) * (o - r - 1) / 4 : r * o + (r - o - 1) * (r - o - 1) / 4; e.has(s) || (e.add(s), i.push(r, o)) } return i }(a) }, ic.prototype.clear = function () { this._occupied = 0, this._cells.clear(), this._idToCode.clear(), this._objectsAtLevel = new Array(16).fill(0), this._bounds = new Array(64); for (var t = 0; t < 16; t++)this._bounds[4 * t] = 1 / 0, this._bounds[4 * t + 1] = 1 / 0, this._bounds[4 * t + 2] = -1 / 0, this._bounds[4 * t + 3] = -1 / 0; return this }, ic.prototype.keyToBBox = function (t) { var e = ec(t), i = e[0], n = e[1], r = e[2], o = this._minCellSize * (1 << r), s = this._min, a = this._resolution; return [i * o / a + s, n * o / a + s, (i + 1) * o / a + s, (n + 1) * o / a + s] }, ic.prototype.keys = function () { return Object.keys(this._cells._idToIndex) }, sc.averageCellOccupancy.get = function () { return this._cells.averageSize }, sc.size.get = function () { return this._idToCode.size }, Object.defineProperties(ic.prototype, sc), ic.code = tc, ic.decode = ec; function ac() { return { x: 0, y: 0, x1: 0, y1: 0, x2: 0, y2: 0 } } var uc, lc = ["x", "y", "radius"], dc = ["width", "curvature"], hc = (b(cc, uc = Ae), cc.prototype._getIntersector = function () { var t = this._graph, e = t.getNodeAttributes(["x", "y", "radius"]), d = e[0], h = e[1], c = e[2], i = t.getEdgeAttributes(["source", "target", "width", "curvature"]), f = i[0], g = i[1], p = i[2], _ = i[3], v = ac(); return function (t, e) { if (t < 0) { t = -t; var i = f.get(t), n = g.get(t), r = _.get(t), o = p.get(t) / 2, s = d.get(i), a = h.get(i), u = d.get(n), l = h.get(n); return i === n ? (ta(s, a, r, c.get(i), 0, v), du(s, a, v.x1, v.y1, v.x2, v.y2, u, l, e[0] - o, e[1] - o, e[2] + o, e[3] + o)) : 0 === r ? tu(s, a, u, l, e[0] - o, e[1] - o, e[2] + o, e[3] + o) : ($s(s, a, u, l, r, v), uu(s, a, v.x, v.y, u, l, e[0] - o, e[1] - o, e[2] + o, e[3] + o)) } return ud(d.get(t), h.get(t), c.get(t), e[0], e[1], e[2], e[3]) } }, cc.prototype._boundsGetter = function () { var t = this._graph, e = t.getNodeAttributes(["x", "y", "radius"]), h = e[0], c = e[1], f = e[2], i = t.getEdgeAttributes(["source", "target", "curvature"]), g = i[0], p = i[1], _ = i[2], v = ac(), m = Bo(); return function (t) { if (t < 0) { t = -t; var e = g.get(t), i = p.get(t), n = _.get(t), r = h.get(e), o = c.get(e), s = h.get(i), a = c.get(i); e === i ? (ta(r, o, n, f.get(e), 0, v), _u(r, o, v.x1, v.y1, v.x2, v.y2, s, a, m)) : 0 === n ? (m.minX = Math.min(r, s), m.minY = Math.min(o, a), m.maxX = Math.max(r, s), m.maxY = Math.max(o, a)) : ($s(r, o, s, a, n, v), pu(r, o, v.x, v.y, s, a, m)) } else { var u = h.get(t), l = c.get(t), d = f.get(t); m.minX = u - d, m.minY = l - d, m.maxX = u + d, m.maxY = l + d } return [m.minX, m.minY, m.maxX, m.maxY] } }, cc.prototype.reindex = function () { this._graphics.forceAttributesComputation(), this._index.clear(), this._elementsToUpdate.clear(), this._updateItems(this._graph.getNodes("all")._indexes, this._graph.getEdges("all")._indexes) }, cc.prototype._updateIndex = function () { if (!this._elementsToUpdate.isEmpty()) { var t = this._elementsToUpdate.getElements(), e = t.nodes, i = t.edges; this._updateItems(e._indexes, i._indexes), this._elementsToUpdate.clear() } }, cc.prototype._updateItems = function (t, e) { for (var i = this._index, n = this._removedNodes, r = this._removedEdges, o = [], s = [], a = 0; a < t.length; a++) { var u = t[a]; 0 !== n.get(u) ? o.push(u) : (i.has(u) && o.push(u), s.push(u)) } for (a = 0; a < e.length; a++)u = -e[a], 0 !== r.get(-u) ? o.push(u) : (i.has(u) && o.push(u), s.push(u)); for (var l = 0, d = o; l < d.length; l++)u = d[l], i.remove(u); for (var h = 0, c = s; h < c.length; h++)u = c[h], i.insert(u) }, cc.prototype.getNodesInScreenByDistance = function (e) { var t = e.getPositionOnScreen(), r = t.x, o = t.y; return this._graph.getNodes().filter(function (t) { return t.isInScreen() && t !== e }).sort(function (t, e) { var i = t.getPositionOnScreen(), n = e.getPositionOnScreen(); return distance(i.x, i.y, r, o) - distance(n.x, n.y, r, o) }) }, cc.prototype.getNearestNodesForNode = function (t, e, i) { void 0 === e && (e = 240); var n = t.getPosition(), r = n.x, o = n.y; return this.getNearestNodes(r, o, e, i, t) }, cc.prototype.getNearestNodes = function (t, e, i, n, r) { if (this._updateIndex(), n) { var o = this._camera.screenToGraphVector({ x: i, y: i }); i = distance(0, 0, o.x, o.y) } return this._getNearestNodes(t, e, i, r) }, cc.prototype._getNearestNodes = function (t, e, i, n) { for (var r = [], o = i * i, s = n ? n._index : 0, a = this._graph.getNodes()._indexes, u = this._graph.getNodeAttributes(["x", "y"]), l = u[0], d = u[1], h = 0, c = a.length; h < c; h++) { var f = a[h]; if (f !== s) { var g = t - l.get(f), p = e - d.get(f); g * g + p * p <= o && r.push(f) } } return this._graph.nodeList(new Uint32Array(r)) }, cc.prototype.queryRaw = function (t, e, i, n) { this._updateIndex(); var r = this._queryBounds; r[0] = t, r[1] = e, r[2] = i, r[3] = n; var o = this._index.query(r), s = this._queryResult, a = s.nodes, u = s.edges; a.length = u.length = 0; for (var l = 0; l < o.length; l++) { var d = o[l]; d < 0 ? u.push(-d) : a.push(d) } return this._queryResult }, cc.prototype.queryRawProjected = function (t, e, i, n) { var r = this._queryBounds; return r[0] = t, r[1] = e, r[2] = i, r[3] = n, this._camera.projectBounds(r), this.queryRaw(r[0], r[1], r[2], r[3]) }, cc.prototype.query = function (t, e, i, n) { var r = this._graph, o = this.queryRaw(t, e, i, n), s = o.nodes, a = o.edges; return { nodes: r.nodeList(new Uint32Array(s.slice())), edges: r.edgeList(new Uint32Array(a.slice())) } }, cc.prototype.queryProjected = function (t, e, i, n) { var r = this._graph, o = this.queryRawProjected(t, e, i, n), s = o.nodes, a = o.edges; return { nodes: r.nodeList(new Uint32Array(s.slice())), edges: r.edgeList(new Uint32Array(a.slice())) } }, cc.prototype.getNodesByBoundingBox = function (t, e, i, n, r) { if (this._updateIndex(), r) { var o = void 0; t = (o = this._camera.screenToGraphVector({ x: t, y: e })).x, e = o.y, i = (o = this._camera.screenToGraphVector({ x: i, y: n })).x, n = o.y } for (var s = this._graph, a = s.getNodes()._indexes, u = [], l = s.getNodeAttribute("excluded"), d = s.getNodeAttributes(["x", "y"]), h = d[0], c = d[1], f = 0, g = a.length; f < g; f++) { var p = a[f]; if (!l.get(p)) { var _ = h.get(p), v = c.get(p); t <= _ && _ <= i && e <= v && v <= n && u.push(p) } } return s.nodeList(new Uint32Array(u)) }, cc.prototype.toggleDebug = function (t) { t ? (this._canvas = nr(), this._graphics.addCanvas(this._canvas), this._ctx = this._canvas.getContext("2d")) : this._canvas && (this._graphics.removeCanvas(this._canvas), this._canvas = this._ctx = null) }, cc.prototype.renderDebug = function (t) { this._ctx || this.toggleDebug(!0), function (t, e) { function n(t, e) { return { x: (t - v) * _, y: (e - m) * _ } } var i = void 0 === e ? {} : e, r = i.cells, o = void 0 === r || r, s = i.boxes, a = void 0 === s || s, u = i.query, l = void 0 === u || u, d = wt(), h = t._ctx, c = t._canvas, f = t._camera, g = t._index, p = -f.getAngle(), _ = f.getZoom() * d, v = f._x, m = f._y, y = f._dimensions.width * d / 2, b = f._dimensions.height * d / 2, x = g.keys().map(function (t) { return g.keyToBBox(t) }), E = Array.from(g._idToCode.keys()).map(function (t) { return g._getBounds(t) }); if (h.clearRect(0, 0, c.width, c.height), h.save(), h.translate(y, b), h.rotate(p), o && (h.beginPath(), h.lineWidth = 1, h.strokeStyle = "#707070", x.forEach(function (t) { var e = n(t[0], t[1]), i = n(t[2], t[3]); h.rect(e.x, e.y, i.x - e.x, i.y - e.y) }), h.stroke()), a && (h.beginPath(), h.lineWidth = 1, h.strokeStyle = "#ff7070", E.forEach(function (t) { var e = n(t[0], t[1]), i = n(t[2], t[3]); h.rect(e.x, e.y, i.x - e.x, i.y - e.y) }), h.closePath(), h.stroke()), l && t._queryBounds) { var A = t._queryBounds; h.beginPath(), h.lineWidth = 2, h.strokeStyle = "#3030ff"; var S = n(A[0], A[1]), w = n(A[2], A[3]); h.rect(S.x, S.y, w.x - S.x, w.y - S.y), h.closePath(), h.stroke() } h.restore() }(this, t) }, cc); function cc(t) { var i = uc.call(this) || this; i._minCellSize = 8; var e = t.graph, n = t.camera, r = t.graphics, o = t.events; return i._graph = e, i._camera = n, i._graphics = r, i._index = new ic(i._getIntersector(), i._boundsGetter(), i._minCellSize, 1e6), i._elementsToUpdate = new Do(i._graph), i._removedNodes = e.getNodeAttribute("removed"), i._removedEdges = e.getEdgeAttribute("removed"), i._queryResult = { edges: [], nodes: [] }, i._queryBounds = [0, 0, 0, 0], o.on({ "addNodes addEdges removeNodes removeEdges updateAttributes": function (t) { if (t.nodes && (!t.nodeAttributes || t.nodeAttributes.some(function (t) { return lc.includes(t) }))) { var e = t.nodes.fastGetAdjacentElements().edges; i._elementsToUpdate.addElements(t.nodes), i._elementsToUpdate.addElements(e) } t.edges && (t.edgeAttributes && !t.edgeAttributes.some(function (t) { return dc.includes(t) }) || i._elementsToUpdate.addElements(t.edges)) }, clear: function () { i._index.clear(), i._elementsToUpdate.clear() } }), i } var fc, gc, pc, _c = (b(vc, fc = Ae), vc.prototype.onMounted = function () { this.locateGraph({}, !0) }, vc.prototype.locateGraph = function (t, force) { var e = this; return void 0 === force && (force = !1), force ? this._locateGraph(t) : this._transformations.whenApplied().then(function () { return e._locateGraph(t) }) }, vc.prototype._locateGraph = function (t) { return this._locateBoundingBox(this.getGraphBoundingBox(), t) }, vc.prototype.locateElements = function (t, e) { var i = this; return this._transformations.whenApplied().then(function () { return i._locateBoundingBox(i.getBoundingBox(t), e) }) }, vc.prototype.locateRawGraph = function (t, e) { return this._locateBoundingBox(this.getRawGraphBoundingBox(t), e) }, vc.prototype.getGraphBoundingBox = function () { return this._cacheValid || this._updateCache(), Object.assign({}, this._cachedGraphBoundingBox) }, vc.prototype.forceInvalidCache = function () { this._invalidCache() }, vc.prototype._invalidCache = function () { this._cacheValid = !1 }, vc.prototype._updateCache = function () { this._cacheValid = !0, this._cachedGraphBoundingBox = this.getBoundingBox(this._graph.getNodes()) }, vc.prototype.getBoundingBox = function (t, e) { return t.isNode ? this._getNodesBoundingBox(t.toList()) : this._getEdgesBoundingBox(t.toList(), e) }, vc.prototype._getNodesBoundingBox = function (t) { this._graphics.forceAttributesComputation(); for (var e = this._graphics.getNodeAttributes(), i = [], n = [], r = [], o = [], s = 0; s < t.size; ++s) { var a = t._indexes[s]; if (0 === e.excluded.get(a)) { var u = e.x.get(a), l = e.y.get(a), d = 2 * e.radius.get(a); "scaled" === e.scalingMethod.get(a) ? r.push(d) : o.push(d), i.push(u), n.push(l) } } return new Uo({ xValues: i, yValues: n, scaledSizeValues: r, fixedSizeValues: o }) }, vc.prototype._getEdgesBoundingBox = function (t, e) { void 0 === e && (e = !1), this._graphics.forceAttributesComputation(); for (var i = this._graphics.getEdgeAttributes(), n = this._graphics.getNodeAttributes(), r = { x1: 0, y1: 0, x2: 0, y2: 0 }, o = { x: 0, y: 0 }, s = { minX: 0, minY: 0, maxX: 0, maxY: 0 }, a = [], u = [], l = [], d = [], h = 0; h < t.size; ++h) { var c = t._indexes[h], f = i.source.get(c), g = i.target.get(c), p = i.curvature.get(c), _ = n.x.get(f), v = n.y.get(f), m = "scaled" === n.scalingMethod.get(f), y = 2 * n.radius.get(f), b = n.x.get(g), x = n.y.get(g), E = "scaled" === n.scalingMethod.get(g), A = 2 * n.radius.get(g); m ? l.push(y) : d.push(y), E ? l.push(A) : d.push(A), e || 0 === p ? (a.push(_, b), u.push(v, x)) : (f === g ? (ta(_, v, p, y / 2, 0, r), _u(_, v, r.x1, r.y1, r.x2, r.y2, b, x, s)) : ($s(_, v, b, x, p, o), pu(_, v, o.x, o.y, b, x, s)), a.push(s.minX, s.maxX), u.push(s.minY, s.maxY)) } return new Uo({ xValues: a, yValues: u, scaledSizeValues: l, fixedSizeValues: d }) }, vc.prototype.getRawGraphBoundingBox = function (t) { for (var e = t.nodes.length, i = new Array(e), n = new Array(e), r = new Array(e), o = 0; o < e; o++) { var s = t.nodes[o].attributes || {}; i[o] = s.x || 0, n[o] = s.y || 0, r[o] = s.radius || 5 } return new Uo({ xValues: i, yValues: n, scaledSizeValues: r }) }, vc.prototype._computeCameraConfig = function (t, e, i) { "number" == typeof e && (e = { left: e, right: e, top: e, bottom: e }); var n, r = void 0 === e.left ? 40 : e.left, o = void 0 === e.right ? 40 : e.right, s = void 0 === e.top ? 40 : e.top, a = void 0 === e.bottom ? 40 : e.bottom, u = this._dom.getDimensions(), l = r + o, d = s + a, h = 0 === t.width ? t.maxFixedSize : t.width, c = 0 === t.height ? t.maxFixedSize : t.height, f = (u.width - l) / (h + t.maxScaledSize), g = (u.height - d) / (c + t.maxScaledSize), p = (u.width - l - t.maxFixedSize) / h, _ = (u.height - d - t.maxFixedSize) / c, v = i / t.maxScaledSize || NaN, m = (n = [f, g, p, _, v].filter(function (t) { return isFinite(t) && 0 < t })).length ? Qe(n) : 1; return { x: t.cx + (o - r) / (2 * m), y: t.cy + (a - s) / (2 * m), zoom: m } }, vc.prototype._locateBoundingBox = function (t, e) { if (void 0 === e && (e = {}), isNaN(t.cx)) return Promise.resolve(); var i = e.padding, n = void 0 === i ? {} : i, r = e.easing, o = void 0 === r ? "quadraticInOut" : r, s = e.duration, a = void 0 === s ? 0 : s, u = e.maxNodeSizeOnScreen, l = void 0 === u ? 200 : u, d = e.ignoreZoomLimits, h = void 0 !== d && d, c = this._computeCameraConfig(t, n, l), f = c.x, g = c.y, p = c.zoom, _ = p / this._camera.getZoom(); return this._moveCamera(f, g, p, a, o, _, h) }, vc.prototype._moveCamera = function (t, e, i, n, r, o, s) { return 1.01 < o ? (this._camera.setCenter({ x: t, y: e }, { duration: n, easing: r, ignoreZoomLimits: s }), this._camera.setZoom(i, { duration: n, easing: r, ignoreZoomLimits: s, startAfter: .5 })) : o < .99 ? (this._camera.setCenter({ x: t, y: e }, { duration: n, easing: r, ignoreZoomLimits: s, startAfter: .5 }), this._camera.setZoom(i, { duration: n, easing: r, ignoreZoomLimits: s })) : this._camera.setCenter({ x: t, y: e }, { duration: n, easing: r, ignoreZoomLimits: s }) }, vc.prototype.computeConfigForBounds = function (t, e) { void 0 === e && (e = {}); var i = e.padding, n = void 0 === i ? {} : i, r = e.maxNodeSizeOnScreen, o = void 0 === r ? 200 : r; return this._computeCameraConfig(t, n, o) }, vc.prototype.layoutDataBoundingBox = function (t) { for (var e = t.x, i = t.y, n = t.indexes, r = this._graphics.getNodeAttributes(), o = [], s = [], a = [], u = [], l = 0; l < n.length; ++l) { var d = n[l], h = e[l], c = i[l], f = 2 * r.radius.get(d), g = "scaled" === r.scalingMethod.get(d); o.push(h), s.push(c), g ? a.push(f) : u.push(f) } return new Uo({ xValues: o, yValues: s, scaledSizeValues: a, fixedSizeValues: u }) }, vc.prototype.isEdgeInPolygon = function (t, e) { var i = t.getSource(), n = t.getTarget(), r = i.getPositionOnScreen(), o = n.getPositionOnScreen(); if (jd(r.x, r.y, e) || jd(o.x, o.y, e)) return !0; for (var s = mc(t, this._camera.getZoom()), a = 0; a < s.length - 1; ++a)for (var u = s[a], l = s[a + 1], d = 0; d < e.length - 1; ++d) { var h = e[d], c = e[d + 1]; if ($a(u.x, u.y, l.x, l.y, h.x, h.y, c.x, c.y)) return !0 } return !1 }, vc.prototype.isElementInView = function (t, e) { var i = (void 0 === e ? {} : e).margin, n = void 0 === i ? 0 : i, r = this._camera.getSize(), o = { minX: -n, minY: -n, maxX: r.width + n, maxY: r.height + n }; return t.isNode ? this.isNodeInRectangle(t, o) : this.isEdgeInRectangle(t, o) }, vc.prototype.isNodeInRectangle = function (t, e) { var i = t.getPositionOnScreen(), n = t.getAttribute("radius") * this._camera.getZoom(), r = i.x - n, o = i.y - n, s = i.x + n, a = i.y + n; return s >= e.minX && r <= e.maxX && a >= e.minY && o <= e.maxY }, vc.prototype.isNodeInPolygon = function (t, e) { var i = t.getPositionOnScreen(); return jd(i.x, i.y, e) }, vc.prototype.isEdgeInRectangle = function (t, e) { for (var i = mc(t, this._camera.getZoom()), n = 0; n < i.length - 1; ++n) { var r = i[n], o = i[n + 1]; if (tu(r.x, r.y, o.x, o.y, e.minX, e.minY, e.maxX, e.maxY)) return !0 } return !1 }, vc); function vc(t) { var e = fc.call(this) || this; return e._cacheValid = !0, e._cachedGraphBoundingBox = new Uo, e._dom = t.dom, e._events = t.events, e._camera = t.camera, e._graph = t.graph, e._graphics = t.graphics, e._settings = t.settings, e._sync = t.sync, e._transformations = t.transformations, e._events.on({ "addNodes removeNodes addEdges removeEdges excludedStateChange clear updateAttributes": function () { return e._invalidCache() } }), e } function mc(t, e) { var i = t.getAttribute("curvature"), n = t.getSource(), r = t.getTarget(), o = n.getPositionOnScreen(); if (n === r) { var s = (i + n.getAttribute("radius")) * jn * e, a = o.x, u = o.y, l = a - s, d = u, h = a, c = u + s; return [o].concat([.2, .4, .6, .8].map(function (t) { return fu(t, a, u, a, u, l, d, h, c) }), [o]) } var f = r.getPositionOnScreen(); if (0 === i) return [o, f]; var g = f.x - o.x, p = f.y - o.y, distance = Math.sqrt(g * g + p * p), _ = (o.x + f.x) / 2, v = (o.y + f.y) / 2, m = i * (distance / Vn) * 2, y = _ + p / distance * m, b = v + -g / distance * m; return [o].concat([.25, .5, .75].map(function (t) { return hu(t, o.x, o.y, f.x, f.y, y, b) }), [f]) } (pc = gc = gc || {}).LEFT = "left", pc.MIDDLE = "middle", pc.RIGHT = "right"; var yc = ct && "msLaunchUri" in navigator && !("documentMode" in document); if (ft) { var bc = []; document.documentElement.addEventListener("mousemove", function (t) { for (var e = 0; e < bc.length; e++)bc[e](t) }) } var xc, Ec = (b(Ac, xc = Ae), Object.defineProperty(Ac.prototype, "x", { get: function () { return this._position.x }, enumerable: !0, configurable: !0 }), Object.defineProperty(Ac.prototype, "y", { get: function () { return this._position.y }, enumerable: !0, configurable: !0 }), Object.defineProperty(Ac.prototype, "left", { get: function () { return this._left }, enumerable: !0, configurable: !0 }), Object.defineProperty(Ac.prototype, "right", { get: function () { return this._right }, enumerable: !0, configurable: !0 }), Object.defineProperty(Ac.prototype, "middle", { get: function () { return this._middle }, enumerable: !0, configurable: !0 }), Ac.prototype._isEnabled = function () { return this._settings.get("mouse.enabled") }, Ac.prototype._isWheelEnabled = function () { return this._settings.get("mouse.wheelEnabled") }, Ac.prototype._disableWheelUntilMouseDown = function () { return this._settings.get("mouse.disableWheelUntilMouseDown") }, Ac.prototype._getDoubleClickTimer = function () { return this._settings.get("mouse.doubleClickTimer") }, Ac.prototype._resetClickCounter = function (t, value) { void 0 === value && (value = 0), t ? this._clickCounter[t] = value : (this._clickCounter.left = value, this._clickCounter.middle = value, this._clickCounter.right = value), this._dom.clearTimeout(this._dbclickTimer), this._lastMouseDownTarget = null }, Ac.prototype._setXY = function (t) { var e = this._domElt.getBoundingClientRect(); return !!(this._bounds = e) && (this._evt = t, this._button = qt[t.button], this._px = this._position.x, this._py = this._position.y, this._position.x = t.clientX - e.left, this._position.y = t.clientY - e.top, this._left = this._buttons.left, this._right = this._buttons.right, this._middle = this._buttons.middle, !0) }, Ac.prototype._applyMouseWheelZoom = function (t) { var e; this._setXY(t) && this._events.fire(xe.MOUSE_WHEEL, { delta: (e = t, yc ? e.wheelDeltaY / 2 : e.deltaY && 0 === e.deltaMode ? -e.deltaY / wt() : e.deltaY && 1 === e.deltaMode ? 20 * -e.deltaY : e.deltaY && 2 === e.deltaMode ? 60 * -e.deltaY : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? 20 * -e.detail : e.detail ? e.detail / -32765 * 60 : 0), x: this._position.x, y: this._position.y, domEvent: this._evt }) }, Ac.prototype._initializeListeners = function () { var e = this, t = this._domElt, i = this._dom; gt && this._dom.addElementEventListener(document, "contextmenu", function (t) { e._lastMouseDownTarget && t.target !== e._lastMouseDownTarget && t.preventDefault() }), i.addElementEventListener(t, "contextmenu", function (t) { e._setXY(t), e._dom.hasFocus() && e._settings.get("mouse.enabled") && t.preventDefault() }, !1); var n = "onwheel" in t ? "wheel" : void 0 !== t.onmousewheel ? "mousewheel" : "DOMMouseScroll"; i.addElementEventListener(t, n, this._onMouseWheel), i.addElementEventListener(t, "mousemove", this._onMouseMove), i.addElementEventListener(t, "mouseleave", function () { e._isEnabled() && (e._dom.blur(), e._events.fire(xe.MOUSE_LEAVE, { domEvent: e._evt })) }), i.addElementEventListener(t, "mousedown", this._onMouseDown), i.addElementEventListener(t, "mouseup", this._onMouseUp) }, Ac); function Ac(t) { var e = t.dom, i = t.position, n = t.settings, r = t.events, o = t.graphics, s = xc.call(this) || this; return s._px = 0, s._py = 0, s._pressX = 0, s._pressY = 0, s._left = !1, s._middle = !1, s._right = !1, s._evt = null, s._bounds = null, s._clickCounter = { left: 0, middle: 0, right: 0 }, s._buttons = { left: !1, middle: !1, right: !1 }, s._button = null, s._lastMouseDownTarget = null, s._skipNextMove = !1, s._onMouseWheel = function (t) { s._isEnabled() && s._isWheelEnabled() && (!s._disableWheelUntilMouseDown() || s._dom.hasFocus()) && (t.preventDefault(), t.stopPropagation(), s._applyMouseWheelZoom(t)) }, s._onMouseMove = function (t) { if (s._isEnabled() && s._setXY(t)) { var e = s._position.x, i = s._position.y, n = e - s._px, r = i - s._py; 0 == n && 0 == r || (s._skipNextMove ? s._skipNextMove = !1 : 6 <= distance(e, i, s._pressX, s._pressY) && (s._resetClickCounter(), s._events.fire(xe.MOUSE_MOVE, { x: e, y: i, dx: n, dy: r, domEvent: s._evt }))) } }, s._onDocumentMouseMove = function (t) { if (s._isEnabled() && s._setXY(t)) { var e = s._position.x, i = s._position.y, n = s._bounds, r = e - s._px, o = i - s._py; (e < 0 || e > n.width || i < 0 || i > n.height) && s._events.fire(xe.DOCUMENT_MOUSE_MOVE, { x: e, y: i, dx: r, dy: o, domEvent: s._evt }) } }, s._onMouseUp = function (t) { if (s._isEnabled() && s._setXY(t)) { var e = s._position.x, i = s._position.y, n = s._button, r = s._evt; s._buttons[n] = !1, 1 === s._clickCounter[s._button] ? s._events.fire(xe.MOUSE_CLICK, { button: n, x: e, y: i, domEvent: r }) : 1 < s._clickCounter[n] && (s._events.fire(xe.MOUSE_DOUBLE_CLICK, { button: n, x: e, y: i, domEvent: r }), s._resetClickCounter(n)), s._events.fire(xe.MOUSE_UP, { button: n, x: e, y: i, domEvent: r }) } }, s._onDocumentMouseup = function (t) { if (s._isEnabled() && s._setXY(t)) { var e = s._position.x, i = s._position.y, n = s._button; s._buttons[n] = !1, s._events.fire(xe.DOCUMENT_MOUSE_UP, { button: n, x: e, y: i, domEvent: s._evt }), s._dom.removeDocumentEventListener(xe.MOUSE_MOVE, s._onDocumentMouseMove), s._dom.removeDocumentEventListener(xe.MOUSE_UP, s._onDocumentMouseup) } }, s._onMouseDown = function (t) { if (s._isEnabled() && s._setXY(t)) { var e = s._position.x, i = s._position.y, n = s._button; s._skipNextMove = !0, s._pressX = e, s._pressY = i, s._lastMouseDownTarget = t.target, s._dom.focus(), s._buttons[n] = !0, s._clickCounter[n] += 1; var r = n; s._dbclickTimer = s._dom.setTimeout(function () { s._resetClickCounter(r, 0) }, s._getDoubleClickTimer()), s._events.fire(xe.MOUSE_DOWN, { button: n, x: e, y: i, domEvent: s._evt }), s._dom.addDocumentEventListener(xe.MOUSE_MOVE, s._onDocumentMouseMove), s._dom.addDocumentEventListener(xe.MOUSE_UP, s._onDocumentMouseup) } }, s._dom = e, s._settings = n, s._events = r, s._graphics = o, s._position = i, s._domElt = s._graphics.getDomElement(), n.register("mouse.enabled", !0), n.register("mouse.wheelEnabled", !0), n.register("mouse.disableWheelUntilMouseDown", !1), n.register("mouse.doubleClickTimer", 500), r.register([xe.MOUSE_DOWN, xe.MOUSE_UP, xe.MOUSE_MOVE, xe.MOUSE_WHEEL, xe.MOUSE_CLICK, xe.MOUSE_DOUBLE_CLICK, xe.MOUSE_LEAVE, xe.DOCUMENT_MOUSE_UP, xe.DOCUMENT_MOUSE_MOVE]), e.afterNextFrame().then(function () { return s._initializeListeners() }), s } var Sc, wc = 500, Tc = (b(Cc, Sc = Ae), Object.defineProperty(Cc.prototype, "x", { get: function () { return this._position.x }, enumerable: !0, configurable: !0 }), Object.defineProperty(Cc.prototype, "y", { get: function () { return this._position.y }, enumerable: !0, configurable: !0 }), Object.defineProperty(Cc.prototype, "pressed", { get: function () { return this._pressed }, enumerable: !0, configurable: !0 }), Cc.prototype._listen = function (t, e, i) { if (ne) { if (e === te.START) return _e(this._addEvent, t, i); if (e === te.MOVE) return me(this._addDocEvent, t, i); if (e === te.END) return ye(this._addDocEvent, t, i); if (e === te.CANCEL) return ve(this._addDocEvent, t, i) } return this._dom.addElementEventListener(t, e, i) }, Cc.prototype._initialize = function (t) { function p() { _._position.x = v, _._position.y = m, _._pressed = l } function s(t, e) { var i = _._domElt.getBoundingClientRect(); if (!i) return null; var n = t.touches[0].clientX - i.left, r = t.touches[0].clientY - i.top, o = t.touches[1].clientX - i.left, s = t.touches[1].clientY - i.top, a = (n + o) / 2, u = (r + s) / 2, l = a - v, d = u - m, h = distance(n, r, o, s), c = h / y, f = Ka(n, r, o, s), g = { dx: l, dy: d, rotation: f - b, scale: c }; return y = h, b = f, v = a, m = u, p(), g } function n(t) { if (d = qt[t.button], 1 !== t.touches.length) return l = !1, 1 < t.touches.length && _._events.fire(xe.TOUCH_UP, { x: v, y: m, domEvent: g, button: d }), !1; var e = _._domElt.getBoundingClientRect(); return e && (a = v, u = m, v = t.touches[0].clientX - e.left | 0, m = t.touches[0].clientY - e.top | 0, l = !0, g = t, p()), !0 } function r() { h = 0, _._dom.clearTimeout(x) } function i(t) { if (t.preventDefault(), 2 !== t.touches.length && f && (f = !1, _._events.fire(xe.TOUCH_END_GESTURE, { domEvent: g })), n(t), 0 === t.touches.length) { var e = { x: v, y: m, domEvent: g, button: d }; 1 === h && _._events.fire(xe.TOUCH_TAP, e), 1 < h && (_._events.fire(xe.TOUCH_DOUBLE_TAP, e), r()), _._events.fire(xe.TOUCH_UP, e) } var i = yt().documentElement; be(_._removeDocEvent, i, te.MOVE, _._onMove), be(_._removeDocEvent, i, te.END, _._onEnd) } function o(t) { !function (t) { if (2 === t.touches.length && f) { var e = s(t); if (e) { var i = e.dx, n = e.dy, r = e.rotation, o = e.scale; _._events.fire(xe.TOUCH_PROGRESS_GESTURE, { dx: i, dy: n, rotation: r, scale: o, x: v, y: m, domEvent: g, button: d }) } } }(t), c ? c = !1 : (r(), n(t) && _._events.fire(xe.TOUCH_MOVE, { x: v, y: m, dx: v - a, dy: m - u, domEvent: g, button: d })) } var _ = this, v = 0, m = 0, a = 0, u = 0, l = !1, d = gc.LEFT, h = 0, c = !1, f = !1, y = 1, b = 0, g = null, x = null; this._listen(this._domElt, te.START, function (t) { 2 !== t.touches.length || f || s(t) && (f = !0, _._events.fire(xe.TOUCH_START_GESTURE, { domEvent: g })), n(t) && (_._dom.focus(), _._events.fire(xe.TOUCH_DOWN, { x: v, y: m, domEvent: g, button: d }), h += 1, x = _._dom.setTimeout(r, wc), c = !0); var e = yt().documentElement; _._onMove = _._listen(e, te.MOVE, o), _._onEnd = _._listen(e, te.END, i) }) }, Cc); function Cc(t) { var e = t.dom, i = t.events, n = t.settings, r = t.graphics, o = t.position, s = Sc.call(this) || this; return s._pressed = !1, s._addEvent = function (t, e, i, n) { s._dom.addElementEventListener(t, e, i, n) }, s._addDocEvent = function (t, e, i, n) { s._dom.addDocumentEventListener(e, i, n) }, s._removeDocEvent = function (t, e, i) { s._dom.removeDocumentEventListener(e, i) }, s._dom = e, s._events = i, s._settings = n, s._graphics = r, s._position = o, s._domElt = s._graphics.getDomElement(), s._settings.register("touch.enabled", !0), s._events.register([xe.TOUCH_DOWN, xe.TOUCH_UP, xe.TOUCH_TAP, xe.TOUCH_DOUBLE_TAP, xe.TOUCH_MOVE, xe.TOUCH_START_GESTURE, xe.TOUCH_PROGRESS_GESTURE, xe.TOUCH_END_GESTURE, xe.DOCUMENT_TOUCH_MOVE, xe.DOCUMENT_TOUCH_UP]), s._dom.afterNextFrame().then(function () { s._initialize(s) }), s } var Mc, Ic = (b(Lc, Mc = Ae), Lc.prototype._fetchSubEltsList = function (t) { return t ? this._subNodesList : this._subEdgesList }, Lc.prototype._fetchMetaEltList = function (t) { return t ? this._metaNodeList : this._metaEdgeList }, Lc.prototype.setSubElements = function (t, e) { this._fetchSubEltsList(t.isNode).setMultiple(t._indexes, e) }, Lc.prototype.setMetaElement = function (t, e) { this._fetchMetaEltList(t.isNode).setMultiple(t._indexes, e) }, Lc.prototype.getSubElements = function (t) { return this._fetchSubEltsList(t.isNode).getMultiple(t._indexes) }, Lc.prototype.getMetaElement = function (t) { return this._fetchMetaEltList(t.isNode).getMultiple(t._indexes) }, Lc); function Lc(t) { var e = t.graph, i = Mc.call(this) || this; return i._graph = e, i._subNodesList = i._graph.createNodeAttribute({ storage: "any", default: null }), i._subEdgesList = i._graph.createEdgeAttribute({ storage: "any", default: null }), i._metaNodeList = i._graph.createNodeAttribute({ storage: "any", default: null }), i._metaEdgeList = i._graph.createEdgeAttribute({ storage: "any", default: null }), i } var Nc = (kc.prototype.getName = function () { return this._module.getName(this._id) }, kc.prototype.getId = function () { return this._id }, kc.prototype.whenApplied = function () { return this._whenApplied }, kc.prototype.isEnabled = function () { return this._module.isEnabled(this._id) }, kc.prototype.enable = function (t) { return this._module.enable(this._id, t) }, kc.prototype.disable = function (t) { return this._module.disable(this._id, t) }, kc.prototype.toggle = function (t) { return this._module.toggle(this._id, t) }, kc.prototype.getIndex = function () { return this._module.getIndex(this._id) }, kc.prototype.setIndex = function (t) { return this._module.setIndex(this._id, t) }, kc.prototype.destroy = function (t) { return this._module.remove(this._id, t) }, kc.prototype.refresh = function () { return this._module.refresh(this._id) }, kc.prototype.delete = function (t) { return this.destroy(t) }, kc); function kc(t, e) { var i = this; this._module = t, this._id = e, this._whenApplied = t.whenApplied().then(function () { return i }) } var Oc = (Fc.prototype.cleanup = function (t) { return Promise.resolve() }, Fc); function Fc(t) { } var Rc, Pc = (b(Dc, Rc = Ae), Dc.prototype._invalidState = function () { var t = this; this._afterCurrentUpdate.then(function () { (t._list.length || t._currentPipeline.length) && (t._mustRefresh = !0, t._dom.refresh()) }) }, Dc.prototype._onUpdate = function () { var i = this; return this._afterCurrentUpdate.then(function () { return i._dom.refresh(), new Promise(function (t, e) { return i._resolvers.push({ resolve: t, reject: e }) }) }) }, Dc.prototype._resetEltTransformationIds = function () { this._nodeTransformationIdList.reset(), this._edgeTransformationIdList.reset() }, Dc.prototype._assignTransformationIds = function (t) { this._assignTransformationIdsToElements(!0, t), this._assignTransformationIdsToElements(!1, t) }, Dc.prototype._assignTransformationIdsToElements = function (t, e) { for (var i = t ? this._graph.getNodes("all") : this._graph.getEdges("all"), n = this._graph.getAttribute(t, "virtual"), r = this._graph.getAttribute(t, "excluded"), o = t ? this._nodeTransformationIdList : this._edgeTransformationIdList, s = 0; s < i._indexes.length; s++) { var a = i._indexes[s]; if (!o.get(a)) { var u = r.get(a), l = n.get(a); !u && l && o.set(a, e) } } }, Dc.prototype._resolveTransformations = function (i, n, t) { var r = this; t || (i.forEach(function (t) { return t.duration = 0 }), n.forEach(function (t) { return t.duration = 0 })), this._resetEltTransformationIds(); for (var e = this._selection.getSelectedNodes().getId(), o = this._selection.getSelectedEdges().getId(), s = Promise.resolve(), a = function (t) { var e = i[t]; null !== e.context && (s = s.then(function () { return e.methods.undo(e) })), n.some(function (t) { return t.id === e.id }) || (s = s.then(function () { return e.methods.cleanup(e) }).then(function () { e.context = null })) }, u = i.length - 1; 0 <= u; --u)a(u); var l = function (t) { var e = n[t], i = null; s = s.then(function () { return e.methods.run(e) }).catch(function (t) { return e.error = t, !0 }).then(function (t) { if (i = t, e.context) return e.methods.cleanup(e) }).then(function () { r._assignTransformationIds(e.id), e.context = i }) }; for (u = 0; u < n.length; ++u)l(u); return s = s.then(function () { r._destroyed || (r._graph.getNodes(e).setSelected(!0), r._graph.getEdges(o).setSelected(!0)) }) }, Dc.prototype.getList = function () { return this._list.map(function (t) { return t.wrapper }) }, Dc.prototype.clear = function () { return this._list = [], this._invalidState(), this._onUpdate() }, Dc.prototype._get = function (t, e) { void 0 === e && (e = !0); for (var i = 0; i < this._list.length; ++i) { var n = this._list[i]; if (n.id === t) return n.index = i, n } if (e) throw new Error("calling a method on a destroyed transformation"); return null }, Dc.prototype.getName = function (t) { return this._get(t).methods.getName() }, Dc.prototype.enable = function (e, i) { var n = this; return this._afterCurrentUpdate.then(function () { var t = n._get(e); return t.enabled || (t.enabled = !0, t.duration = i, n._invalidState()), n._onUpdate() }) }, Dc.prototype._setRemovalDuration = function (t, e) { for (var i = 0; i < this._currentPipeline.length; ++i) { var n = this._currentPipeline[i]; n.id === t && (n.duration = e) } }, Dc.prototype.disable = function (e, i) { var n = this; return this._afterCurrentUpdate.then(function () { var t = n._get(e); return t.enabled && (t.enabled = !1, n._setRemovalDuration(e, i), n._invalidState()), n._onUpdate() }) }, Dc.prototype.remove = function (e, i) { var n = this; return this._afterCurrentUpdate.then(function () { var t = n._get(e); return n._list.splice(t.index, 1), n._setRemovalDuration(e, i), n._invalidState(), n._onUpdate() }) }, Dc.prototype.toggle = function (t, e) { var i = this; return this._afterCurrentUpdate.then(function () { return i._get(t).enabled ? i.disable(t, e) : i.enable(t, e) }) }, Dc.prototype.setIndex = function (e, i) { var n = this; return this._afterCurrentUpdate.then(function () { var t = n._get(e); return n._list.splice(t.index, 1), n._list.splice(Xe(i, 0, n._list.length), 0, t), n._invalidState(), n._onUpdate() }) }, Dc.prototype.getIndex = function (t) { return this._get(t).index }, Dc.prototype.add = function (t, e) { var i = void 0 === e ? {} : e, n = i.duration, r = void 0 === n ? 0 : n, o = i.enabled, s = void 0 === o || o; t.cleanup || (t.cleanup = function () { return Promise.resolve() }); var a = { ogma: this._ogma, id: ++this._idCounter, methods: t, duration: r, enabled: s, context: null, wrapper: new Nc(this, this._idCounter), index: -1, error: null }; return this._list.push(a), this._invalidState(), a.wrapper }, Dc.prototype.whenApplied = function () { return this._onUpdate() }, Dc.prototype.refresh = function () { return this._invalidState(), this._onUpdate() }, Dc.prototype.isEnabled = function (t) { return this._get(t).enabled }, Dc.prototype._getElementTransformationId = function (t) { return (t.isNode ? this._nodeTransformationIdList : this._edgeTransformationIdList).get(t._index) }, Dc.prototype.isElementVirtual = function (t) { return !!this._getElementTransformationId(t) }, Dc.prototype.getElementTransformation = function (t) { var e = this._get(this._getElementTransformationId(t), !1); return e && e.wrapper }, Dc.prototype.destroy = function () { this._destroyed = !0 }, Dc); function Dc(t, e) { var i, o = Rc.call(this) || this; return o._list = [], o._currentPipeline = [], o._idCounter = 0, o._mustRefresh = !1, o._safeGuard = !1, o._resolvers = [], o._afterCurrentUpdate = Promise.resolve(), o._destroyed = !1, o._computeTransformations = function () { if (!o._safeGuard) { if (o._safeGuard = !0, o._afterCurrentUpdate = Promise.resolve(), o._mustRefresh) { o._captor.setDetectionEnabled(!1); var t, e, i = o._currentPipeline.filter(function (t) { return t.enabled }), n = o._list.filter(function (t) { return t.enabled }), r = !1; r = i.length === n.length + 1 && zc(i, n, n.length) ? (t = [i.pop()], e = [], !0) : n.length === i.length + 1 && zc(i, n, i.length) ? (t = [], e = [n.pop()], !0) : (t = i, e = n, !1), o._afterCurrentUpdate = o._afterCurrentUpdate.then(function () { return o._resolveTransformations(t, e, r) }).then(function () { return o._captor.setDetectionEnabled(!0), o._currentPipeline = o._list.map(function (t) { return C({}, t) }), o._mustRefresh = !1, o._dom.afterNextFrame() }) } o._afterCurrentUpdate = o._afterCurrentUpdate.then(function () { o._safeGuard = !1, o._resolvers.forEach(function (t, e) { var i = t.resolve, n = t.reject, r = o._list[e]; return r && r.error ? n(r.error) : i() }), o._resolvers = [] }) } }, o._settings = t.settings, o._dom = t.dom, o._events = t.events, o._graph = t.graph, o._captor = t.captor, o._classes = t.classes, o._selection = t.selection, o._ogma = e, o._classes.createClass({ name: gl, isBuiltin: !0, nodeAttributes: { opacity: 0, radius: 0 }, edgeAttributes: { opacity: 0, width: 0 } }), o._classes.createClass({ name: pl, isBuiltin: !0, nodeAttributes: { opacity: 0 }, edgeAttributes: { opacity: 0 } }), o._nodeTransformationIdList = o._graph.createNodeAttribute({ storage: 16, default: 0 }), o._edgeTransformationIdList = o._graph.createEdgeAttribute({ storage: 16, default: 0 }), o._settings.register("transformations.updateOnDataChange", !0), o._events.on(((i = {})[[xe.ADD_NODES, xe.ADD_EDGES, xe.REMOVE_NODES, xe.REMOVE_EDGES].join(" ")] = function (t) { t.virtual || o._invalidState() }, i[xe.UPDATE_NODE_DATA + " " + xe.UPDATE_EDGE_DATA] = function () { o._settings.get("transformations.updateOnDataChange") && !o._safeGuard && o._invalidState() }, i[xe.AFTER_NEW_FRAME] = o._computeTransformations, i)), o } function zc(t, e, i) { for (var n = 0; n < i; ++n)if (t[n].id !== e[n].id) return !1; return !0 } var Bc, Uc = { layer: 2, outline: !0, outerStroke: { color: "red", width: 5 }, innerStroke: { minVisibleSize: 0 }, text: { backgroundColor: "rgb(220, 220, 220)", minVisibleSize: 0 } }, Vc = { layer: 2, color: "red", outline: !0, text: { backgroundColor: "rgb(220, 220, 220)", minVisibleSize: 0 }, stroke: { width: 2 } }, jc = (b(Gc, Bc = Ae), Gc.prototype.onMounted = function (t) { function e() { i._selectionExtremityHighlightedClass.clearNodes(), i._selectedClass.getEdges().getExtremities().addClass(dl) } var i = this; t.events.onEdgesClassAdded(ll, e), t.events.onEdgesClassRemoved(ll, e) }, Gc.prototype.setNodeAttributes = function (t, e) { this._selectedClass.update({ nodeAttributes: t, fullOverwrite: e }), this._selectionExtremityHighlightedClass.update({ nodeAttributes: t, fullOverwrite: e }), this._updateExtremityHighlightLayer() }, Gc.prototype.setEdgeAttributes = function (t, e) { this._selectedClass.update({ edgeAttributes: t, fullOverwrite: e }), this._updateExtremityHighlightLayer() }, Gc.prototype._updateExtremityHighlightLayer = function () { var t = this._selectedClass.getDefinition().edgeAttributes, e = t ? t.layer : void 0; this._selectionExtremityHighlightedClass.update({ nodeAttributes: { layer: e }, fullOverwrite: !1 }) }, Gc.prototype.setActive = function (t, i) { if (I(i)) { var n = [], r = []; t.toList().forEach(function (t, e) { (i[e] ? n : r).push(t.getId()) }), 0 !== n.length && this._graph.getElements(t.isNode, n).addClass(ll), 0 !== r.length && this._graph.getElements(t.isNode, r).removeClass(ll) } else t[i ? "addClass" : "removeClass"](ll) }, Gc.prototype.areActive = function (t) { return t.hasClass(ll) }, Gc.prototype.getSelectedNodes = function () { return this._selectedClass.getNodes() }, Gc.prototype.getSelectedEdges = function () { return this._selectedClass.getEdges() }, Gc.prototype.getNonSelectedNodes = function () { return this._graph.getNodes().filter(function (t) { return !t.hasClass(ll) }) }, Gc.prototype.getNonSelectedEdges = function () { return this._graph.getEdges().filter(function (t) { return !t.hasClass(ll) }) }, Gc.prototype.clear = function () { this._selectedClass.clearNodes(), this._selectedClass.clearEdges() }, Gc); function Gc(t) { var r = Bc.call(this) || this; return r._events = t.events, r._settings = t.settings, r._graph = t.graph, r._keyboard = t.keyboard, r._graphics = t.graphics, r._interactions = t.interactions, r._selectionExtremityHighlightedClass = t.classes.createClass({ name: dl, isBuiltin: !0, nodeAttributes: Uc }), r._selectedClass = t.classes.createClass({ name: ll, isBuiltin: !0, nodeAttributes: Uc, edgeAttributes: Vc }), r._settings.register("interactions.selection.enabled", !0), r._settings.register("interactions.selection.multiSelectionKey", "ctrl"), r._interactions.onClick({ priority: "selection", check: function (t) { var e = t.button, i = r._settings.get("interactions.selection.enabled"); return "left" === e && i && !r._graphics.isAnimating() }, handler: function (t) { var e = t.target; if (e) { var i = r._settings.get("interactions.selection.multiSelectionKey"), n = i && r._keyboard.isPressed(i); if (e.isNode ? r._selectedClass.clearEdges() : r._selectedClass.clearNodes(), n) e.hasClass(ll) ? e.removeClass(ll) : e.addClass(ll); else (e.isNode ? r._selectedClass.getNodes() : r._selectedClass.getEdges()).filter(function (t) { return t !== e }).removeClass(ll), e.hasClass(ll) || e.addClass(ll) } else r._selectedClass.clearNodes(), r._selectedClass.clearEdges() } }), r._events.on(xe.BEFORE_REMOVE_EDGES, function (t) { return t.edges.setSelected(!1) }), r } var Hc, qc = (b(Wc, Hc = Ae), Wc.prototype._nextTimeIdle = function (t) { var e = this, i = new Xc(this._dom, this._idIdle, t); return this._delayedCalls.push(i), i.whenDone().then(function () { e._delayedCalls.splice(e._delayedCalls.indexOf(i), 1) }) }, Wc.prototype.debounceIdle = function (e, i) { var n = this; function r() { var t = s; o = !1, s = [], e(), t.forEach(function (t) { return t() }) } void 0 === i && (i = 0); var o = !1, s = []; return function () { return new Promise(function (t) { s.push(t), o || (o = !0, n._nextTimeIdle(i).then(r)) }) } }, Wc); function Wc(t) { var e = Hc.call(this) || this; return e._dom = t.dom, e._events = t.events, e._captor = t.captor, e._delayedCalls = [], e._idIdle = function () { return !e._captor.isAnyButtonPressed() && !e._dom.isPlayingFrame() }, e._events.on({ "down up beforeNewFrame newFrame": function () { e._delayedCalls.forEach(function (t) { return t.reset() }) } }), e } var Xc = (Yc.prototype._startTimeout = function () { var t = this; this._timeout = this._dom.setTimeout(function () { t._isIdle() ? (t._done = !0, t._resolve()) : t._startTimeout() }, this._delay) }, Yc.prototype.reset = function () { this._done || (this._dom.clearTimeout(this._timeout), this._startTimeout()) }, Yc.prototype.whenDone = function () { return this._promise }, Yc); function Yc(t, e, i) { var n = this; this._timeout = null, this._done = !1, this._dom = t, this._promise = new Promise(function (t) { return n._resolve = t }), this._isIdle = e, this._delay = i, this._startTimeout() } var Zc, Kc = { number: 1, duration: 1e3, interval: 800, startColor: "rgba(0,0,0,0.6)", endColor: "rgba(0,0,0,0.0)", width: 50, startRatio: 1, endRatio: 2 }, Qc = { number: 1, duration: 1e3, interval: 800, startColor: "rgba(0,0,0,0.6)", endColor: "rgba(0,0,0,0.0)", width: 10, startRatio: 1, endRatio: 2 }, Jc = (b($c, Zc = Ae), $c.prototype._onElementsAttributeChange = function (t, e) { if (e.includes("pulse.enabled")) { var i = Ei(this._graph, t, function (t) { return t.getAttribute("pulse.enabled") }), n = i.valid, r = i.invalid; this._hasPulses.removeElements(r), this._hasPulses.addElements(n), this._removePulses(r) } }, $c.prototype._removePulses = function (t) { for (var e = t.isNode ? this._nodePulses : this._edgePulses, i = 0; i < t._indexes.length; i++) { var n = t._indexes[i], r = e.get(n); if (r) { for (var o = 0; o < r.length; o++) { var s = r[o]; this._graphics.releaseGraphicsEngineBlockId(s.blockId) } e.set(n, null) } } }, $c.prototype._refreshElementsPulses = function (t, e) { for (var i = t.isNode, n = i ? this._nodePulses : this._edgePulses, r = i ? this._nodeFlexArrays.pulse.duration : this._edgeFlexArrays.pulse.duration, o = i ? "_createNodePulseBlock" : "_createEdgePulseBlock", s = i ? this._nodeFlexArrays.pulse.interval : this._edgeFlexArrays.pulse.interval, a = i ? this._nodeNbPulsesRemaining : this._edgeNbPulsesRemaining, u = 0; u < t._indexes.length; u++) { var l = t._indexes[u], d = n.get(l); d || (d = [], n.set(l, d)); for (var h = 0; h < d.length; h++) { var c = d[h], f = c.startTime, g = c.duration, p = c.blockId; f + g <= e && (this._graphics.releaseGraphicsEngineBlockId(p), d.splice(h--, 1)) } var _ = d[d.length - 1]; if (!_ || e >= _.startTime + s.get(l)) { g = r.get(l); var v = a.get(l); 0 !== v && d.push({ blockId: this[o](l, e, g), startTime: e, duration: g }), 0 < v && a.set(l, v - 1) } } }, $c.prototype._createNodePulseBlock = function (t, e, i) { var n = this._nodeFlexArrays, r = n.color.get(t), o = n.layer.get(t), s = n.x.get(t), a = n.y.get(t), u = n.radius.get(t), l = "scaled" === n.scalingMethod.get(t), d = n.pulse.startRatio.get(t), h = n.pulse.endRatio.get(t), c = n.pulse.width.get(t), f = 2 * u * d, g = 2 * u * h, p = Gl(o).nodeBody, _ = n.pulse.startColor.get(t), v = n.pulse.endColor.get(t), m = this._graphics.allocateGraphicsEngineBlockId(), y = this._block.reset(1, !0, p), b = y.nextAndReset(), x = kl(_, r), E = kl(v, r); return b.end.shape = "circle", b.end.pieceId = Sn, b.end.x1 = s, b.end.y1 = a, b.end.x2 = s, b.end.y2 = a, b.end.rectWidthOrSourceRadiusScaled = l ? g : 0, b.end.rectHeightOrTargetRadiusScaled = l ? g : 0, b.end.rectWidthOrSourceRadiusFixed = l ? 0 : g, b.end.rectHeightOrTargetRadiusFixed = l ? 0 : g, b.end.strokeWidthFixed = c, b.end.strokeColor = E, b.start.shape = "circle", b.start.pieceId = Sn, b.start.x1 = s, b.start.y1 = a, b.start.x2 = s, b.start.y2 = a, b.start.rectWidthOrSourceRadiusScaled = l ? f : 0, b.start.rectHeightOrTargetRadiusScaled = l ? f : 0, b.start.rectWidthOrSourceRadiusFixed = l ? 0 : f, b.start.rectHeightOrTargetRadiusFixed = l ? 0 : f, b.start.strokeWidthFixed = c, b.start.strokeColor = x, b.animation.duration = i, b.animation.beginTime = e, this._engine.storeBlock(m, y), m }, $c.prototype._createEdgePulseBlock = function (t, e, i) { var n = this._edgeFlexArrays, r = this._nodeFlexArrays, o = n.pulse.startRatio.get(t), s = n.pulse.endRatio.get(t), a = n.pulse.startColor.get(t), u = n.pulse.endColor.get(t), l = Gl(n.layer.get(t)).edgeBody, d = this._edgeSourceList.get(t), h = this._edgeTargetList.get(t), c = n.curvature.get(t), f = 0 !== c, g = this._graphics.allocateGraphicsEngineBlockId(), p = this._block.reset(f ? 3 : 1, !0, l), _ = p.nextAndReset(), v = { isSelfLoop: d === h, curvature: c, sourceX: r.x.get(d), sourceY: r.y.get(d), targetX: r.x.get(h), targetY: r.y.get(h), sourceRadius: r.radius.get(d), targetRadius: r.radius.get(h), isSourceRadiusScaled: "scaled" === r.scalingMethod.get(d), isTargetRadiusScaled: "scaled" === r.scalingMethod.get(h), width: n.width.get(t), isWidthScaled: "scaled" === n.scalingMethod.get(t), strokeWidth: n.pulse.width.get(t) }; return tf(_.start, v), tf(_.end, v), _.start.strokeColor = a, _.end.strokeColor = u, _.start.thicknessOrFontSizeScaled *= o, _.start.thicknessOrFontSizeFixed *= o, _.end.thicknessOrFontSizeScaled *= s, _.end.thicknessOrFontSizeFixed *= s, _.animation.duration = i, _.animation.beginTime = e, this._engine.storeBlock(g, p), g }, $c.prototype.pulse = function (t, e) { var i = t.isNode, n = C({}, i ? Kc : Qc, e), r = n.number, o = n.interval, s = n.duration, a = i ? this._nodeNbPulsesRemaining : this._edgeNbPulsesRemaining, u = (r - 1) * o + s; delete n.number, n.enabled = !0, t.setAttributes({ pulse: n }), a.setMultiple(t._indexes, r), this._dom.setTimeout(function () { t.setAttribute("pulse.enabled", !1), a.setMultiple(t._indexes, -1) }, u) }, $c); function $c(t) { var e = t.graphics, i = t.graph, n = t.dom, r = t.events, o = Zc.call(this) || this; return o._onAttributeChange = function (t) { var e = t.nodes, i = t.edges, n = t.nodeAttributes, r = t.edgeAttributes; o._onElementsAttributeChange(e, n), o._onElementsAttributeChange(i, r) }, o._refreshPulses = function () { var t = o._hasPulses.getElements(), e = t.nodes, i = t.edges; if (0 !== e.size || 0 !== i.size) { var n = o._engine.getCurrentTime(); o._refreshElementsPulses(e, n), o._refreshElementsPulses(i, n), o._dom.refresh() } }, o._graph = i, o._dom = n, o._graphics = e, r.on(xe.UPDATE_ATTRIBUTES, o._onAttributeChange), r.on(xe.NEW_FRAME, o._refreshPulses), r.on(xe.BEFORE_REMOVE_NODES + " " + xe.BEFORE_REMOVE_EDGES, function (t) { var e = t.nodes, i = t.edges; (e || i).setAttribute("pulse.enabled", !1) }), r.on(xe.CLEAR_GRAPH, function () { return o._hasPulses.clear() }), o._engine = o._graphics.getGraphicsEngine(), o._block = o._engine.createBlock(), o._nodePulses = i.createNodeAttribute({ storage: "any" }), o._edgePulses = i.createEdgeAttribute({ storage: "any" }), o._nodeNbPulsesRemaining = i.createNodeAttribute({ storage: "int16", default: -1 }), o._edgeNbPulsesRemaining = i.createEdgeAttribute({ storage: "int16", default: -1 }), o._nodeFlexArrays = o._graphics.getNodeAttributes(), o._edgeFlexArrays = o._graphics.getEdgeAttributes(), o._edgeSourceList = i.getEdgeAttribute("source"), o._edgeTargetList = i.getEdgeAttribute("target"), o._hasPulses = new Do(o._graph), o } function tf(t, e) { var i = e.sourceX, n = e.sourceY, r = e.targetX, o = e.targetY, s = e.isSourceRadiusScaled, a = e.isTargetRadiusScaled, u = e.targetRadius, l = e.sourceRadius, d = e.isWidthScaled, h = e.width, c = e.strokeWidth, f = e.curvature, g = e.isSelfLoop; t.pieceId = wn, t.shape = "line", t.x1 = i, t.y1 = n, t.x2 = r, t.y2 = o, t.rectWidthOrSourceRadiusScaled = s ? l : 0, t.rectWidthOrSourceRadiusFixed = s ? 0 : l, t.rectHeightOrTargetRadiusScaled = a ? u : 0, t.rectHeightOrTargetRadiusFixed = a ? 0 : u, t.thicknessOrFontSizeScaled = d ? h : 0, t.thicknessOrFontSizeFixed = d ? 0 : h, t.strokeWidthFixed = c, t.curvature = f, t.isSelfLoop = g } var ef, nf = { duration: 0, easing: "linear", callback: function () { }, startAfter: 0 }, rf = (b(of, ef = Ae), of.prototype.play = function (t, e) { var i = Q(e, nf), n = i.duration, r = i.easing, o = i.callback, s = i.startAfter, a = null; return n <= 0 ? (t(1), o()) : (a = { func: t, easing: "function" == typeof r ? r : rl[r], duration: n, callback: o, startAfter: s, creationDate: Kt(), done: !1 }, this._animationList.push(a), this._dom.refresh()), a }, of.prototype.end = function (t, e) { void 0 === e && (e = !0); var i = this._animationList.indexOf(t); -1 !== i && (t.func(1), this._animationList.splice(i, 1), t.done = !0, e && t.callback(!0)) }, of); function of(t) { var u = ef.call(this) || this; return u._animationList = [], u._update = function () { if (0 !== u._animationList.length) { for (var t = Kt(), e = [], i = 0; i < u._animationList.length; ++i) { var n = u._animationList[i], r = (t - n.creationDate) / n.duration, o = n.startAfter, s = n.easing(r); if (1 <= r) n.func(1), n.done = !0, u._animationList.splice(i, 1), --i, e.push(n.callback); else if (o <= s) { s = (s - o) * (1 / (1 - o)), n.func(s) } } for (var a = 0; a < e.length; ++a)e[a](!1); u._dom.refresh() } }, u._dom = t.dom, u._events = t.events, u._animationList = [], u._events.on(xe.BEFORE_NEW_FRAME, u._update), u } function sf(t) { return t + (-1 === t.indexOf("?") ? "?" : "&") + "noCache=" + Date.now() } var af = { tileLayers: function (e, s, t, o, a) { var u = t._getMapPanePos(), l = o.DomUtil.getPosition(e.getContainer()); t.removeLayer(e), e.options.crossOrigin = "anonymous"; var d = [], h = []; return e.on("tileload", function (t) { var e = t.tile, i = o.DomUtil.getPosition(e), n = i.x, r = i.y; d.push(e), h.push({ x: n - l.x + u.x - a.x, y: r - l.y + u.y - a.y }) }), t.addLayer(e), new Promise(function (t) { e.once("load", function () { var o = e.getTileSize(); d.forEach(function (t, e) { var i = h[e], n = i.x, r = i.y; s.drawImage(t, n, r, o.x, o.y) }), t() }) }) }, imageOverlays: function (s, a, u, t, l) { return new Promise(function (o) { u.removeLayer(s), s.setUrl(sf(s.getUrl())), s.options.crossOrigin = "anonymous", s.once("load", function () { var t = s.getBounds(), e = u.latLngToContainerPoint(t.getNorthWest()), i = u.latLngToContainerPoint(t.getSouthEast()), n = i.x - e.x, r = i.y - e.y; a.drawImage(s._image, e.x - l.x, e.y - l.y, n, r), o() }), u.addLayer(s) }) }, vectorLayers: function (s, a, u, l, d, h) { return new Promise(function (t) { var e = s.options.renderer; u.removeLayer(s), s.options.renderer = h, u.addLayer(s), h._updatePaths(); var i = u._getMapPanePos(), n = h._container, r = l.DomUtil.getPosition(n), o = wt(); a.drawImage(h._container, r.x + i.x - d.x, r.y + i.y - d.y, n.width / o, n.height / o), u.removeLayer(s), s.options.renderer = e, u.addLayer(s), t() }) }, markers: function (f, g, p, t, _) { return new Promise(function (t) { var e = p.getPixelBounds().min, i = p.project(f.getLatLng(), p.getZoom()), n = /^data\:/.test(f._icon.src), r = n ? f._icon.src : sf(f._icon.src), o = new Image, s = f.options.icon.options, a = s.iconSize, u = i.subtract(e), l = s.iconAnchor; Array.isArray(a) || (a = [a.x, a.y]), Array.isArray(l) || (l = [l.x, l.y]); var d = Math.round(u.x - a[0] + l[0]) - _.x, h = Math.round(u.y - l[1]) - _.y; o.crossOrigin = ""; function c() { g.drawImage(o, d, h, a[0], a[1]), t() } o.onload = c, o.src = r, n && c() }) }, vectorMap: function (t, i, e, n, r) { var o = e._getMapPanePos(), s = t.getMapboxMap(), a = t.getCanvas(), u = t.getSize().round(), l = n.DomUtil.getPosition(t.getContainer()), d = l.x + o.x - r.x, h = l.y + o.y - r.y; return new Promise(function (t) { function e() { i.drawImage(a, d, h, u.x, u.y), t() } if (s.loaded()) return e(); s.once("idle", e) }) } }; function uf(o, s, a, u, l, d) { var h = { vectorMap: [], tileLayers: [], vectorLayers: [], imageOverlays: [], markers: [] }; return s.eachLayer(function (t) { if (t !== o) { var e = (n = t) instanceof (r = u).TileLayer ? "tileLayers" : n instanceof r.ImageOverlay ? "imageOverlays" : n instanceof r.Path ? "vectorLayers" : n instanceof r.Marker ? "markers" : "MapboxGL" in r && n instanceof r.MapboxGL ? "vectorMap" : void 0; if (e in h) { var i = af[e]; h[e].push(function () { return i(t, a, s, u, l, d) }) } } var n, r }), h } function lf(t, e, i, u) { var n = t.filter(function (t) { return t.isVisible() }), r = 0 === n.size, o = n.reduce(function (t, e) { var i = e.getGeoCoordinates(), n = i.latitude, r = i.longitude, o = u(n, r), s = o.x, a = o.y; return t.mapX.push(s), t.mapY.push(a), t }, { mapX: [], mapY: [] }), s = o.mapX, a = o.mapY, l = n.getAttribute("x"), d = n.getAttribute("y"), h = n.getAttribute("radius"), c = new Uo({ xValues: l, yValues: d, scaledSizeValues: h }), f = new Uo({ xValues: s, yValues: a }); r && (c.cx = c.cy = 0, c.width = c.height = 0), isFinite(f.width) && isFinite(f.height) || (f.cx = f.cy = 0, f.width = f.height = 0); var g = f.cx - c.cx, p = f.cy - c.cy, _ = r ? 1 : Math.max(f.width, f.height) / Math.max(c.width, c.height), v = h.reduce(function (t, e) { return t[0] = Math.min(t[0], e * _), t[1] = Math.max(t[1], e * _), t }, [1 / 0, 0]), m = v[0], y = v[1]; f.pad(y), f.minScaledSize = m, f.maxScaledSize = y; var b, x = i.computeConfigForBounds(f), E = e.zoom / (b = x.zoom, Math.pow(2, Math.ceil(Math.log2(b)))); g += (c.cx - e.x) * E, p += (c.cy - e.y) * E; var A = c.cx + g, S = c.cy + p; return { offsetChanges: { name: "graph-to-geo", nodeAttributes: { radius: function (t) { return t.getAttribute("radius") * E }, x: function (t) { return (t.getAttribute("x") + g - A) * E + A }, y: function (t) { return (t.getAttribute("y") + p - S) * E + S } }, edgeAttributes: { width: function (t) { return t.getAttribute("width") * E } } }, camera: C({ zoom: e.zoom / E, x: (e.x + g - A) * E + A, y: (e.y + p - S) * E + S, angle: 0 }, e.getSize()) } } var df, hf = { "top-left": "left", "bottom-left": "left", "top-right": "right", "bottom-right": "right" }, cf = { "top-left": "top", "bottom-left": "bottom", "top-right": "top", "bottom-right": "bottom" }, ff = { position: "bottom-right", horizontalMargin: 0, verticalMargin: 0, className: null }, gf = (b(pf, df = Ae), pf.prototype.set = function (t, e) { var i = C({}, ff, e), n = i.position, r = i.horizontalMargin, o = i.verticalMargin, s = i.className; hf[n] || (n = ff.position), this.remove(); var a = document.createElement("div"); return a.innerHTML = t, a.style.position = "absolute", _f(a, n, r, o), a.style.padding = "0px 0px 0px 0px", a.style.zIndex = "10", s && a.setAttribute("class", s), this._brand = a, this._dom.setLayer("brand", this._brand), a }, pf.prototype.remove = function () { this._dom.setLayer("brand", null), this._brand = null }, pf); function pf(t) { var e = df.call(this) || this; return e._dom = t.dom, e._brand = null, e } function _f(t, e, i, n) { var r = void 0 === i ? "" : i + "px", o = void 0 === n ? "" : n + "px"; t.style[hf[e]] = r, t.style[cf[e]] = o } var vf, mf = (b(yf, vf = Ae), yf.prototype._onCameraUpdate = function () { var t = this; if (this._enabled && this._map && this._map._loaded) { var e = this._x - this._camera.x, i = this._y - this._camera.y; if (e || i) { this._updating || (this._updating = !0, this._layer.setLocked(!0), this._map._moveStart(!0, !1)); var n = this._fromPointToLatLng(this._camera.x, this._camera.y), r = Hi(this._camera.zoom), o = this.L.latLng(n.latitude, n.longitude); this._map._move(o, r, { pinch: !0, round: !1 }), clearTimeout(this._updateRequest), this._updateRequest = setTimeout(function () { t._updating = !1, t._layer.setLocked(!1), t._map && t._map._move(o, r, { pinch: !0 })._moveEnd(!0) }, this._updateRate) } } }, yf.prototype._onNodesDragStart = function () { this._enabled && (this._setMapDragging(!1), this._nodeDragOffsetX = this._nodeDragOffsetY = 0) }, yf.prototype._onNodesDragged = function (t) { var r = this, e = t.nodes, o = t.dx, s = t.dy; if (this._enabled) { var i = e.map(function (t) { var e = t.getAttributes(["x", "y"]), i = e.x, n = e.y; return r._fromPointToLatLng(i + o - r._nodeDragOffsetX, n + s - r._nodeDragOffsetY) }); return this._nodeDragOffsetX = o, this._nodeDragOffsetY = s, e.setGeoCoordinates(i) } }, yf.prototype._onDataChange = function (t) { var i = this, e = t.filter(function (t) { var e = t.property; return e === i.latitudePath || e === i.longitudePath }); if (e.length) { var n = e.reduce(function (t, e) { var i = e.nodes, n = e.newValues; if (!i) return t; var r = i.filter(function (t, e) { return null != n[e] }); return t ? t.concat(r) : r }, null); this._refreshOrAddNodes(n) } }, yf.prototype._refreshOrAddNodes = function (t) { this._updateNodesCoordinates(t), this._enabled && (this._filter.refresh(), this._updatePrevNodesCoordinates(t)) }, yf.prototype._updatePrevNodesCoordinates = function (t) { Ki(this._graph, t, zi, "geo.prevLat"), Ki(this._graph, t, Bi, "geo.prevLng") }, yf.prototype._restorePrevNodesCoordinates = function (t) { Ki(this._graph, t, "geo.prevLat", zi), Ki(this._graph, t, "geo.prevLng", Bi) }, yf.prototype._updateNodesCoordinates = function (t) { !function (t, e, i) { for (var n = i.longitudePath, r = i.latitudePath, o = i.wrapCoordinates, s = t.getAttributes(!0, [zi, Bi]), a = s[0], u = s[1], l = e._indexes, d = e.getId(), h = l.length, c = e.getData(r), f = e.getData(n), g = 0; g < h; g++) { var p = f[g], _ = c[g], v = l[g], m = d[g]; null != _ && null != p && (Wi(m, p), Xi(m, _), o && (p %= 180, _ = Xe(+_, -Ui, Ui)), u.set(v, p), a.set(v, _)) } }(this._graph, t, this._settings) }, yf.prototype._createMapTileLayer = function (t, e) { if (!J(t)) return t; var i, n = t.wms ? this.L.tileLayer.wms : this.L.tileLayer, r = (i = t, null == e && i.url === Vi.tiles.url ? 'Map data &copy; <a target="_blank" href="http://osm.org/copyright">OpenStreetMap contributors</a>' : null); return n(t.url, C({ attribution: r }, t)) }, yf.prototype._setupTileLayer = function (t, e) { var i = this, n = this._createMapTileLayer(t, e); return n.once("load", function () { i._events.fire(xe.GEO_LOADED) }), n.addTo(this._map), n }, yf.prototype._onSettingsChanged = function (t, e) { var i, n, r = t.wrapCoordinates !== e.wrapCoordinates, o = t.latitudePath !== e.latitudePath || t.longitudePath !== e.longitudePath; (r || o) && this._updateNodesCoordinates(this._graph.getNodes("all")), this._enabled && (n = e, (i = t).attribution === n.attribution && i.tiles === n.tiles || !this._map || (this._map.removeLayer(this._tileLayer), this._tileLayer = this._setupTileLayer(e.tiles, e.attribution)), t.sizeRatio !== e.sizeRatio && this._updateSizes(), t.maxZoomLevel !== e.maxZoomLevel && this._settingsModule.update({ minZoom: 1, maxZoom: Math.pow(2, e.maxZoomLevel) }), t.disableNodeDragging !== e.disableNodeDragging && this._setDragging(!e.disableNodeDragging), t.attributionOptions !== e.attributionOptions && this._setAttributionOptions(e.attributionOptions, e.attribution)) }, yf.prototype._setMapDragging = function (t) { if (this._map) { var e = t ? "enable" : "disable"; this._map.dragging[e]() } }, yf.prototype._fromLatLngToPoint = function (t, e) { return this._map.options.crs.latLngToPoint(this.L.latLng(t, e), 1) }, yf.prototype._fromPointToLatLng = function (t, e) { var i = this._map.options.crs.pointToLatLng(this.L.point({ x: t, y: e }), 1); return { latitude: i.lat, longitude: i.lng } }, yf.prototype._updateSizes = function () { this._enabled && this._projection && this._projection.updateAll() }, yf.prototype.enable = function (t) { return this.setEnabled(!0, t) }, yf.prototype.getMap = function () { if (this._enabled) return this._map }, yf.prototype.getOptions = function () { if (this._enabled) return C({}, this._settings, { tiles: C({}, this._settings.tiles) }) }, yf.prototype.setOptions = function (t) { if (this._enabled) { !function (t, e) { void 0 === t && (t = {}); var i = t.tileUrlSubdomains, n = t.tileUrlTemplate, r = t.attribution, o = t.attributionOptions, s = t.latitudePath, a = t.longitudePath, u = t.sizeRatio, l = t.tiles; if (null != n && "string" != typeof n) throw new TypeError("Geo mode: tileUrlTemplate must be a URL string"); if (null != i && "string" != typeof i) throw new TypeError("Geo mode: tileUrlTemplate must be a string"); if (null != l) { if (!(J(l) || l instanceof e.Layer)) throw new TypeError("Geo mode: tiles must be a object or L.Layer instance"); var d = l; if (null != d.url && "string" != typeof d.url) throw new TypeError("Geo mode: tiles.url must be a string"); if (null != d.subdomains && "string" != typeof d.subdomains) throw new TypeError("Geo mode: tiles.subdomains must be a string"); if (d.tms && "boolean" != typeof d.tms) throw new TypeError("Geo mode: tiles.tms must be a boolean"); if (d.wms && "boolean" != typeof d.wms) throw new TypeError("Geo mode: tiles.wms must be a boolean") } if (null != r && "string" != typeof r) throw new TypeError("Geo mode: Map attribution must be a string"); if (null != o && !J(o)) throw new TypeError("Geo mode: attributionOptions must to be a BrandOptions object"); if (null != s && "string" != typeof s && !Array.isArray(s)) throw new TypeError("Geo mode: Latitude path must be a valid property path: a string or an array of strings."); if (null != a && "string" != typeof a && !Array.isArray(a)) throw new TypeError("Geo mode: Longitude path must be a valid property path: a string or an array of strings."); if (null != u && (!isFinite(u) || u <= 0)) throw new TypeError("Geo mode: sizeRatio must be a positive number.") }(t, this.L); var e = this._settings; this._settings = C({}, Vi, t, { tiles: function (t, e) { if (void 0 === e && (e = {}), void 0 === e.tiles || e.tileUrlTemplate || e.tileUrlSubdomains) { var i = Vi.tiles; return C({}, e.tiles || {}, Vi.tiles, { url: e.tileUrlTemplate || i.url, subdomains: e.tileUrlSubdomains || i.subdomains }) } return J(e.tiles) ? C({}, t.tiles, e.tiles) : e.tiles }(Vi, t) }), this._onSettingsChanged(e, this._settings) } }, yf.prototype.disable = function (t) { return this.setEnabled(!1, t) }, yf.prototype.isEnabled = function () { return this._enabled }, yf.prototype.toggle = function (t) { return this.setEnabled(!this._enabled, t) }, yf.prototype.getContainerCoords = function (t) { var n = this; return t.getGeoCoordinates().map(function (t) { var e = t.latitude, i = t.longitude; return n._map.latLngToContainerPoint([e, i]) }) }, yf.prototype.setEnabled = function (value, t) { var e = this; if (!Gi()) throw new Error("Ogma Geo cannot be used outside a browser"); if (!this.L) throw new Error("You are trying to use Geo mode but Leaflet has not been found. Please follow our migration guide: https://bit.ly/2SYkF8A"); if (this._transition || value === this._enabled) return Promise.resolve(); this._enabled = value, this._transition = !0, this.setOptions(t); var i = this._settingsModule, n = this._settings; return value ? (this._nodeDraggingSetting = i.get("interactions.drag.enabled"), this._setDragging(!n.disableNodeDragging), this._show().then(function () { e._setDragging(!n.disableNodeDragging), e._setMapDragging(n.disableNodeDragging), e._transition = !1, e._updating = !1, e._events.fire(xe.GEO_ENABLED), e._events.fire(xe.GEO_READY) })) : this._hide().then(function () { e._transition = !1, e._events.fire(xe.GEO_DISABLED), e._setDragging(e._nodeDraggingSetting, !0) }) }, yf.prototype._setDragging = function (t, e) { void 0 === e && (e = !1), this._settingsModule.update({ interactions: { drag: { enabled: t, applyResult: e } } }) }, yf.prototype._setAttributionOptions = function (t, e) { if (this._attribution && (this._attribution.remove(), this._attribution = null), this._attribution = this.L.control.attribution({ prefix: !1 }).addTo(this._map), J(t)) { this._attribution.setPrefix(""), t.position = t.position || "bottom-right"; var i = t.position.replace("-", ""); this._attribution.setPosition(i); var n = this._attribution.getContainer(); t.className && this.L.DomUtil.addClass(n, t.className), _f(n, t.position || "bottom-right", t.horizontalMargin, t.verticalMargin) } void 0 !== e && this._attribution.addAttribution(e) }, yf.prototype._nodeIsVisible = function (t) { return e = t, i = this._settings, n = this._hasCustomProjection(), r = i.longitudePath, o = i.latitudePath, s = i.wrapCoordinates, a = e.getData(r), u = e.getData(o), null != a && null != u && (!(!s && !n) || Math.abs(u) <= Ui && Math.abs(a) <= 180); var e, i, n, r, o, s, a, u }, yf.prototype._updateSettingsForMap = function () { var t = this._graphics.getGraphicsEngine().parseColor(this._settings.backgroundColor); t[3] = 0, this._prevSettings = this._settingsModule.update({ backgroundColor: fn(t), minZoom: 1e-6, interactions: { rotation: { enabled: !1 }, drag: { enabled: !1 }, pan: { enabled: !1 }, zoom: { enabled: !1, onDoubleClick: !1 } }, mouse: { wheelEnabled: !1 } }) }, yf.prototype.getGraphPosition = function (t) { var e, i = this.L.latLngBounds((e = [[1 / 0, 1 / 0], [-1 / 0, -1 / 0]], t.getGeoCoordinates().reduce(function (t, e) { var i = e.latitude, n = e.longitude, r = t[0], o = t[1]; return r[0] = Math.min(r[0], i), r[1] = Math.min(r[1], n), o[0] = Math.max(o[0], i), o[1] = Math.max(o[1], n), t }, e))); return { center: 0 < t.size ? i.getCenter() : this.L.latLng([0, 0]), zoom: this._map.getBoundsZoom(i) } }, yf.prototype._initMap = function () { this._updateSettingsForMap(), this._mapContainer = function (t) { var e = yt().createElement("div"); e.className = "ogma-geo-container", e.style.width = e.style.height = "100%"; var i = t || Zi; return i.insertBefore(e, i.firstChild), e }(this._dom.getContainer()); var t = C({}, ji, { minZoom: this._settings.minZoomLevel, maxZoom: this._settings.maxZoomLevel }); this._hasCustomProjection() && (t.crs = this._settings.crs, t.worldCopyJump = !1, t.maxBoundsViscosity = 0), this._map = new this.L.Map(this._mapContainer, t), this._hasCustomProjection() || this._map.setMaxBounds(this.L.latLngBounds([[Ui, -180], [-Ui, 180]])), this._setAttributionOptions(this._settings.attributionOptions, this._settings.attribution), this._setupLayers() }, yf.prototype._show = function () { var u = this; return this._filter = this._filters.addNodeFilter(function (t) { return u._nodeIsVisible(t) }), this._filter.whenApplied().then(function () { u._initMap(); var t = u._graph.getNodes(), e = u._graph.getEdges(), i = u.getGraphPosition(t), n = i.center, r = i.zoom; u._zoom = r; var o = u._transformToGeo(), s = o.offset, a = o.newCameraView; return u._camera.setView(a, { ignoreZoomLimits: !0 }).then(function () { return u._updatePrevNodesCoordinates(t), u._map.setView(n, r), u._zoom = r, u._graphics.animate({ nodes: t, edges: e }, function () { u._projection = u._createFinalPositionLayer() }, u._settings.duration) }).then(function () { return s.destroy() }) }) }, yf.prototype._hasCustomProjection = function () { return null != this._settings.crs }, yf.prototype._setupLayers = function () { var t = this; this._settings.tiles && (this._tileLayer = this._setupTileLayer(this._settings.tiles, this._settings.attribution)), this._layer = new this.L.OgmaOverlay({ container: this._graphics.getDomElement(), mapContainer: this._mapContainer, onUpdate: function () { return t._onMapUpdate() } }), this._layer.addTo(this._map) }, yf.prototype._onMapUpdate = function () { var t, e = this._map.getCenter(), i = e.lat, n = e.lng, r = this._fromLatLngToPoint(i, n); return this._x = r.x, this._y = r.y, this._camera.setView({ zoom: (t = this._map.getZoom(), Math.pow(2, t - 1)), x: r.x, y: r.y }, { ignoreZoomLimits: !0 }) }, yf.prototype._hide = function () { var t = this; if (!this._map) return Promise.resolve(); this._settingsModule.update(this._prevSettings), this._map.removeLayer(this._layer); var e = this._dom.getContainer(), i = this._graphics.getDomElement(); e && e.appendChild(i), this._map.getContainer().style.zIndex = 0; var n = this._graph.getNodes("all"), r = this._graph.getEdges("all"), o = this._transformToGraph(), s = o.offset, a = o.newCameraView; return this._camera.setView(a).then(function () { return Promise.all([Xt(t._map.getContainer(), 1, 0, t._settings.duration / 2).then(function () { t._map.remove(), t._mapContainer.parentNode.removeChild(t._mapContainer) }), t._graphics.animate({ nodes: n, edges: r }, function () { return s.destroy() }, t._settings.duration)]) }).then(function () { return t._map = null, t._filter.delete() }) }, yf.prototype._transformToGeo = function () { var i = this, t = lf(this._graph.getNodes(), this._camera, this._locate, function (t, e) { return i._fromLatLngToPoint(t, e) }), e = t.offsetChanges, n = t.camera; return { offset: this._addGraphAttributesLayer(e), newCameraView: n } }, yf.prototype._addGraphAttributesLayer = function (t) { return this._graphics.addAttributeLayer(C({ priority: 6, nodeSelector: function (t) { return t.isVisible() }, edgeSelector: function (t) { return t.isVisible() } }, t)) }, yf.prototype._transformToGraph = function () { var t = this, e = function (t, e, i, n) { var r = t.getAttributes(["x", "y", "radius"]), o = t.getBoundingBox(), s = 0 === t.size, a = t.reduce(function (t, e, i) { return t[e._index] = i, t }, {}); n(); var u = t.getAttribute("x"), l = t.getAttribute("y"), d = t.getAttribute("radius"), h = new Uo({ xValues: u, yValues: l, scaledSizeValues: d.map(function (t) { return 2 * t }) }); s && (o.reset(), h.reset()); var c, f, g = h.cx - o.cx, p = h.cy - o.cy, _ = 0, v = 0, m = i.computeConfigForBounds(h), y = e.zoom / m.zoom; return f = isNaN(o.cx) || isNaN(o.cy) ? (o.cx = e.x, o.cy = e.y, c = m.x, m.y) : (g += (o.cx - e.x) * y, p += (o.cy - e.y) * y, _ = o.cx + g, v = o.cy + p, c = (e.x + g - _) * y + _, (e.y + p - v) * y + v), { offsetChanges: { name: "geo-to-graph", nodeAttributes: { x: function (t) { return (r[a[t._index]].x + g - _) * y + _ }, y: function (t) { return (r[a[t._index]].y + p - v) * y + v } } }, camera: C({ zoom: m.zoom, x: c, y: f, angle: 0 }, e.getSize()) } }(this._graph.getNodes("all"), this._camera, this._locate, function () { t._projection && (t._projection.destroy(), t._projection = null) }), i = e.offsetChanges, n = e.camera; return { offset: this._addGraphAttributesLayer(i), newCameraView: n } }, yf.prototype.getPointFromLatLng = function (t) { var e = t.getGeoCoordinates(), i = e.latitude, n = e.longitude; return null == i ? t.getAttributes(["x", "y"]) : this._fromLatLngToPoint(i, n) }, yf.prototype._createFinalPositionLayer = function () { var e = this; return this._addGraphAttributesLayer({ name: "graph-2-geo-animation", nodeAttributes: { scalingMethod: "fixed", radius: function (t) { return t.getAttribute("radius") * e._settings.sizeRatio }, x: function (t) { return e.getPointFromLatLng(t).x }, y: function (t) { return e.getPointFromLatLng(t).y } }, edgeAttributes: { scalingMethod: "fixed", width: function (t) { return t.getAttribute("width") * e._settings.sizeRatio } } }) }, yf.prototype.destroy = function () { return Promise.resolve() }, yf.prototype.setCenter = function (t, e) { return this._enabled ? this.setView(t, e, Hi(this._camera.getZoom())) : Promise.resolve() }, yf.prototype.setZoom = function (t) { return this._enabled ? (this._zoom = t, this._map.setZoom(t), this._onMapUpdate()) : Promise.resolve() }, yf.prototype.setView = function (t, e, i) { if (this._enabled) return this._map.setView(this.L.latLng([t, e]), i, { animate: !1 }), this._zoom = i, this._onMapUpdate() }, yf.prototype.getView = function () { if (this._enabled) { var t = this._map.getCenter(); return { zoom: this._zoom, latitude: t.lat, longitude: t.lng } } }, yf.prototype.getCenter = function () { if (this._enabled) { var t = this._map.getCenter(); return { latitude: t.lat, longitude: t.lng } } }, yf.prototype.getZoom = function () { if (this._enabled) return this._zoom }, yf.prototype.resetCoordinates = function () { if (this._enabled) { var t = this._graph.getNodes(); this._restorePrevNodesCoordinates(this._graph.getNodes()); var e = this._graph.getNodeAttribute(zi).getMultiple(t._indexes), i = this._graph.getNodeAttribute(Bi).getMultiple(t._indexes); t.setData(this._settings.latitudePath, e), t.setData(this._settings.longitudePath, i), this._projection.update() } }, yf.prototype.updateCoordinates = function () { hi("The ogma.geo.updateCoordinates() API has been deprecated. The coordinates are updated by default now.") }, yf.prototype.getUnprojectedCoordinates = function (t) { hi("The ogma.geo.getUnprojectedCoordinates() API has been deprecated. Original graph coordinates are only available when in graph mode."), this._projection.destroy(); var e = t.getPosition(); return this._projection = this._createFinalPositionLayer(), e }, Object.defineProperty(yf.prototype, "latitudePath", { get: function () { return this._settings.latitudePath }, enumerable: !0, configurable: !0 }), Object.defineProperty(yf.prototype, "longitudePath", { get: function () { return this._settings.longitudePath }, enumerable: !0, configurable: !0 }), yf.prototype.exportBackground = function (t) { var e = this, i = nr(); i.width = t.width, i.height = t.height; var n = i.getContext("2d"), r = this._map.getSize(), o = this.getView(), s = C({ zoom: Hi(t.zoom) }, this._fromPointToLatLng(t.x, t.y)), a = { x: (r.x - t.width) / 2, y: (r.y - t.height) / 2 }, u = new this.L.Canvas; this._map.addLayer(u); var l = uf(this._layer, this._map, n, this.L, a, u), d = l.vectorMap, h = l.tileLayers, c = l.vectorLayers, f = l.imageOverlays, g = l.markers, p = this._map.options.zoomSnap; return this.setView(s.latitude, s.longitude, s.zoom).then(function () { return e._map._onResize() }).then(function () { return D(d.concat(h, f, c, g)) }).then(function () { e._map._onResize(), e.setView(o.latitude, o.longitude, o.zoom), e._map.options.zoomSnap = p }).then(function () { return new Promise(function (t) { return e.L.Util.requestAnimFrame(t) }) }).then(function () { return e._map.removeLayer(u) }).then(function () { return i }) }, yf); function yf(t) { var e, i = t.camera, n = t.graph, r = t.settings, o = t.filters, s = t.events, a = t.dom, u = t.graphics, l = t.locate, d = vf.call(this) || this; return d._enabled = !1, d._zoom = 0, d._nodeDraggingSetting = !1, d._transition = !1, d._map = null, d._attribution = null, d._updating = !1, d._updateRate = 50, d._x = 0, d._y = 0, d._graph = n, d._camera = i, d._settingsModule = r, d._filters = o, d._events = s, d._dom = a, d._graphics = u, d._locate = l, d._events.register(["geoEnabled", "geoDisabled", "geoLoaded", "geoReady"]), d.L = null, Gi() && (d.L = M("L") || M("leaflet"), d.L && function (s) { s.TileLayer.prototype.getUrl = function () { return this._url }, s.ImageOverlay.prototype.getUrl = function () { return this._url }; var i = "leaflet-zoom-animated"; s.OgmaOverlay || (s.OgmaOverlay = s.Layer.extend({ options: { pane: "overlayPane", padding: 0, onUpdate: function () { } }, initialize: function (t) { var e = t.container; s.Util.setOptions(this, t), this._container = e }, setLocked: function (value) { return this._locked = value, this }, onAdd: function (t) { this._map = t, this.getPane().appendChild(this._container), this._wgsOrigin = s.latLng([0, 0]), this._wgsInitialShift = t.project(this._wgsOrigin, this._initialZoom), s.DomUtil.addClass(this._container, "leaflet-layer"), this._zoomAnimated && (s.DomUtil.addClass(this._container, i), this._container.style.position = "absolute", this._container.style.zIndex = 9999), this._initialZoom = (this._map.getMaxZoom() + this._map.getMinZoom()) / 2, this._mapInitialZoom = this._map.getZoom(), this._updateBounds(), this._update({}) }, _updateBounds: function () { var t = this.options.padding, e = this._map.getSize(), i = this._map.containerPointToLayerPoint(e.multiplyBy(-t)); this._bounds = new s.Bounds(i, i.add(e.multiplyBy(1 + 2 * t))), this._center = this._map.getCenter(), this._zoom = this._map.getZoom() }, _update: function (t) { var e = this; this._updateBounds(), this._redraw(this._bounds.min, t), this._positionTimer = s.Util.requestAnimFrame(function () { return s.DomUtil.setPosition(e._container, e._bounds.min) }) }, _redraw: function (t, e) { this.options.onUpdate() }, _updateTransform: function (t, e) { if (!this._locked) { var i = this._map.getZoomScale(e, this._zoom), n = this._map.getSize().multiplyBy(.5 + this.options.padding), r = this._map.project(this._center, e), o = n.multiplyBy(-i).add(r).subtract(this._map._getNewPixelOrigin(t, e)); s.Browser.any3d ? s.DomUtil.setTransform(this._container, o, i) : s.DomUtil.setPosition(this._container, o) } }, _onZoom: function (t) { this._updateTransform(this._map.getCenter(), this._map.getZoom()) }, _onMoveEnd: function (t) { this._update(t) }, _onAnimZoom: function (t) { var e = t.center, i = t.zoom; this._updateTransform(e, i) }, bringToFront: function () { s.DomUtil.toFront(this._container) }, getEvents: function () { return { zoom: this._onZoom, moveend: this._onMoveEnd, zoomanim: this._onAnimZoom, layeradd: this.bringToFront, zoomend: this.options.onUpdate } }, onRemove: function () { s.DomUtil.removeClass(this._container, i); var e = this._container;["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform", "zIndex", "position"].forEach(function (t) { return e.style[t] = null }), s.Util.cancelAnimFrame(this._positionTimer), this._container = null } })) }(d.L)), d._graph.createNodeAttribute({ name: "geo.prevLat", storage: "float" }), d._graph.createNodeAttribute({ name: "geo.prevLng", storage: "float" }), d._graph.createNodeAttribute({ name: zi, storage: "float" }), d._graph.createNodeAttribute({ name: Bi, storage: "float" }), d._settings = C({}, Vi), d._events.on(((e = { addNodes: function (t) { return d._refreshOrAddNodes(t.nodes) } })[xe.UPDATE_NODE_DATA] = function (t) { d._enabled && d._onDataChange(t.changes) }, e.progressMoveNodesByDragging = function (t) { return d._onNodesDragged(t) }, e.startMoveNodesByDragging = function () { return d._onNodesDragStart() }, e.endMoveNodesByDragging = function () { return d._setMapDragging(!0) }, e[xe.CAMERA_MOVE] = function () { return d._onCameraUpdate() }, e[xe.VIEW_CHANGED] = function () { return d._onCameraUpdate() }, e)), d } function bf(t, e, i, n, r) { for (var o = new Array(t.length), s = 0; s < e.length; s++) { var a = n[e[s]], u = n[i[s]]; o[a] = o[a] || [], o[a].push(u), r && (o[u] = o[u] || [], o[u].push(a)) } return o } function xf(t, e) { return -1 === t[e] ? e : xf(t, t[e]) } function Ef(t, e, i, n, r, o, s, a) { if (n[t] = r, i[t]) return !0; if (e[t]) return !1; e[t] = 1, i[t] = 1; var u = o[t]; if (u) for (var l = 0, d = u; l < d.length; l++) { var h = d[l]; if (Ef(h, e, i, n, t, o, s, a)) return s.push(a[h]), !0 } return i[t] = 0, !1 } function Af(t, e, i) { for (var n = t.length, r = new Uint8Array(n), o = new Uint8Array(n), s = new Int32Array(n), a = {}, u = 0; u < n; u++)a[t[u]] = u; var l = bf(t, e, i, a, !1); for (u = 0; u < n; u++) { var d = []; if (Ef(u, r, o, s, -1, l, d, t) && 1 < d.length) { for (var h = d[0], c = 1; c < d.length; c++)if (d[c] === h) { d.length = c; break } return d.push(h), d.reverse() } } return !1 } function Sf(t, e, i, n, r, o, s) { e[t] = 1, n[t] = i; var a = r[t]; if (a) for (var u = 0, l = a; u < l.length; u++) { var d = l[u]; if (e[d]) { if (d !== i) return n[d] = t, o.push(s[d]), !0 } else if (Sf(d, e, t, n, r, o, s)) return o.push(s[d]), !0 } return !1 } var wf = (Tf.prototype.getCycles = function () { this.visited = new Uint8Array(this.nodes.length), this.visitedStack = []; for (var t = 0; t < this.nodes.length; t++)for (this.backtrack(t, t); 0 !== this.visitedLength;) { var e = this.visitedStack.pop(); this.visited[e] && (this.visited[e] = 0, this.visitedLength--) } return this.cycles }, Tf.prototype.backtrack = function (t, e) { var i = !1; this.stack.push(e), this.visited[e] || (this.visited[e] = 1, this.visitedLength++), this.visitedStack.push(e); for (var n = 0, r = this.adjacency[e] || []; n < r.length; n++) { var o = r[n]; if (this.removed[e] = this.removed[e] || {}, !this.removed[e][o]) if (o < t) this.removed[e][o] = !0; else if (o === t) { for (var s = [], a = 0, u = !(i = !0); a < this.stack.length; a++) { var l = this.stack[a]; t === l && (u = !0), u && s.push(this.nodes[l]) } this.cycles.push(s) } else if (!this.visited[o]) { var d = this.backtrack(t, o); i = i || d } } if (i) for (var h = void 0; h = this.visitedStack.pop(), this.visited[h] && (this.visited[h] = null, this.visitedLength--), h !== e;); return this.stack.pop(), i }, Tf); function Tf(t, e, i) { this.cycles = [], this.visitedLength = 0, this.visitedStack = [], this.stack = [], this.idToIndex = {}, this.removed = {}, this.nodes = t, this.visited = new Uint8Array(this.nodes.length); for (var n = 0; n < t.length; n++)this.idToIndex[t[n]] = n; this.adjacency = bf(t, e, i, this.idToIndex) } var Cf, Mf = (b(If, Cf = Ae), If.prototype.shortestPath = function (t) { void 0 === t && (t = { source: void 0, target: void 0 }); var e = t.source, i = t.target, n = t.directed, r = void 0 !== n && n, o = t.filter, s = void 0 === o ? "visible" : o, a = t.edgeCostFunction, u = void 0 === a ? function () { return 1 } : a, l = t.heuristicFunction, d = void 0 === l ? function () { return 0 } : l, h = this._graph.getNode(e), c = this._graph.getNode(i); if (!h) throw new Error("the source is not a node"); if (!c) throw new Error("the target is not a node"); var f = h._index, g = c._index, p = null; if (f === g) p = { nodes: h.toList(), edges: this._graph.edgeList() }; else { var _ = this._graph.getNodeMaxIndex() + 1, v = new Int32Array(_), m = new Float32Array(_), y = new Float32Array(_), b = new Set, x = new Ro(y); for (m.fill(1 / 0), y.fill(1 / 0), v.fill(-1), x.add(f), m[f] = 0, y[f] = d(h, c); !x.isEmpty();) { var E = x.removeMin(); if (E === g) { p = this._constructPath(v, f, g); break } b.add(E); var A = this._graph.getAdjacentDirections(E); if (A) for (var S = 0; S < A.length; ++S) { for (var w = A[S], T = this._graph.getEdgeIndexesInDirection(w), C = -1, M = 0, I = -1, L = 0; L < T.length; ++L) { var N = T[L], k = this._sourceList.get(N), O = this._targetList.get(N); if (k !== O && !(r && E !== k || "visible" === s && this._excludedList.get(N) || "raw" === s && this._virtualList.get(N))) { var F = u(this._edgeList.get(N)); (-1 === C || F < M) && (C = N, M = F, I = k === E ? O : k) } } if (-1 !== I || b.has(I)) { var R = m[E] + M; if (!x.has(I) || R < m[I]) { var P = this._nodeList.get(E); v[I] = C, m[I] = R, y[I] = R + d(P, c), x.add(I) } } } } } return Promise.resolve(p) }, If.prototype._constructPath = function (t, e, i) { for (var n = [i], r = [], o = i; o !== e;) { var s = t[o], a = this._sourceList.get(s), u = this._targetList.get(s); o = o === a ? u : a, n.push(o), r.push(s) } return n.reverse(), r.reverse(), { nodes: this._graph.nodeList(new Uint32Array(n)), edges: this._graph.edgeList(new Uint32Array(r)) } }, If.prototype.detectCycle = function (t, e) { var i = e.getSource(), n = e.getTarget(), r = Af(t._indexes, i._indexes, n._indexes); return r ? this._graph.nodeList(new Uint32Array(r)).dedupe() : null }, If.prototype.getAllSimpleCycles = function (t, e) { var i = this, n = e.getSource(), r = e.getTarget(); return new wf(t._indexes, n._indexes, r._indexes).getCycles().map(function (t) { return i._graph.nodeList(new Uint32Array(t)) }) }, If); function If(t) { var e = t.graph, i = Cf.call(this) || this; return i._graph = e, i._nodeList = e.getNodeAttribute("object"), i._edgeList = e.getEdgeAttribute("object"), i._sourceList = e.getEdgeAttribute("source"), i._targetList = e.getEdgeAttribute("target"), i._excludedList = e.getEdgeAttribute("excluded"), i._virtualList = e.getEdgeAttribute("virtual"), i } var Lf, Nf = (b(kf, Lf = Ae), kf.prototype._addAttributeLayer = function () { return this._graphics.addAttributeLayer({ name: "curvature", priority: 2, edgeDependencies: { parallelEdges: !0 }, edgeContext: this._context, edgeAttributes: { curvature: function (t, e) { var i, n = e.edgesAlwaysCurvy, r = e.directedEdges, o = t.getSource() === t.getTarget(), s = t.getParallelEdges(), a = s.indexOf(t); if (-1 === a) return 0; if (o) i = a + 1; else { var u = t.getSource(), l = s.size; if (1 === l && !n) return 0; if (r) { for (var d = 0, h = 0; h < a; ++h)s.get(h).getSource() === u && (d += 1); i = d + 1 } else { var c = u !== s.get(0).getSource(); i = l % 2 != 1 || n ? (1 + (a / 2 | 0)) * (a % 2 == 0 ? 1 : -1) * (c ? -1 : 1) : 0 === a ? 0 : ((a + 1) / 2 | 0) * (a % 2 == 0 ? 1 : -1) * (c ? -1 : 1) } } return i } } }) }, kf); function kf(t) { var e = Lf.call(this) || this; return e._context = { edgesAlwaysCurvy: !1, directedEdges: !1 }, e._settings = t.settings, e._graphics = t.graphics, e._attributeLayer = e._addAttributeLayer(), e._settings.register("edgesAlwaysCurvy", !1, function (value) { e._context.edgesAlwaysCurvy = value, e._attributeLayer.updateAll() }), e._settings.register("directedEdges", !1, function (value) { e._context.directedEdges = value, e._attributeLayer.updateAll() }), e } function Of() { return {} } function Ff() { } function Rf() { return !1 } function Pf() { } function Df() { } function zf() { } var Bf, Uf = (b(Vf, Bf = jo), Vf.prototype.configure = function (t) { this._onStart = t.onStart || Df, this._onEnd = t.onEnd || zf, this._update = t.update || Ff, this._onUpdate = t.onUpdate || Pf, this._createContext = t.context || Of, this._isRunning = t.isRunning || Rf }, Vf.prototype.setData = function (t) { this._data = t }, Vf.prototype.getData = function () { return this._data }, Vf.prototype.onStart = function () { return this.fire("start", { target: this }), this._onStart.call(this), this }, Vf.prototype.stop = function () { }, Vf); function Vf(t, e, i) { var n = Bf.call(this) || this; return n._complete = !1, n._data = null, n._dependencies = e, n._dom = i, n.configure(t), n } var jf, Gf = (b(Hf, jf = Uf), Hf.prototype.sync = function (t) { var e = t.data.isRunning, i = t.data.result, n = this._onUpdate.call(this, i, this._dependencies, e); return this.fire("update", { target: this, isRunning: e }), e ? this.send(n) : this.stop(i) }, Hf.prototype.stop = function (t) { return this._complete || (this._onEnd.call(this, t, this._dependencies), this._worker.terminate(), this.fire("stop", { target: this })), this._complete = !0, this }, Hf.prototype.send = function (t) { return this._worker.postMessage(vo(t)), this }, Hf); function Hf(t, e, i) { var n = jf.call(this, t, e, i) || this, r = [function (t) { void 0 === t && (t = {}); for (var e = Object.keys(t), i = [], n = 0, r = e.length; n < r; n++) { var o = e[n], s = t[o]; if ("function" != typeof s) throw new Error('Asynchronous task: dependency "' + o + '" is not found'); var a = Xf(s); a ? (i.push(Wf(s, o)), a !== o && i.push("var " + o + " = " + a + ";")) : i.push("var " + o + " = " + Wf(s, o) + ";") } return i.join("\n") }(t.imports), "", "", "var __CONTEXT = (" + n._createContext.toString() + ")();", "var __UPDATE_FUNC = " + n._update.toString() + ";", "var __IS_RUNNING_FUNC = " + n._isRunning.toString() + ";", "", 'self.addEventListener("message", function (evt) {', "  var result    = __UPDATE_FUNC(evt.data, __CONTEXT);", "  var isRunning = __IS_RUNNING_FUNC(__CONTEXT, evt.data);", "  self.postMessage({ result: result, isRunning: isRunning });", "});"].join("\n"); return n._worker = mo(r), n._worker.addEventListener("message", function (t) { n._dom.isDestroyed() || n.sync(t) }), n } var qf = /^function\s*\(/; function Wf(t, e) { var i = t.toString(); return qf.test(i) ? "function " + (t.name || e) + " " + i.substring(i.indexOf("(")) : i } function Xf(t) { var e = t.toString(); return t.name ? t.name : qf.test(e) ? null : e.substring("function ".length, e.indexOf("(")).trim() } var Yf, Zf = (b(Kf, Yf = Uf), Kf.prototype.sync = function (t) { var e = this._update(t, this._context), i = this._isRunning(this._context, t), n = this._onUpdate.call(this, e, this._dependencies, i); this.fire("update", { target: this, isRunning: i }), i ? this.send(n) : this.stop(e) }, Kf.prototype.send = function (t) { var e = this; return this._complete || this._dom.setTimeout(function () { return e.sync(t) }, 0), this }, Kf.prototype.stop = function (t) { return this._complete || (this._onEnd(t, this._dependencies), this._complete = !0), this }, Kf); function Kf(t, e, i) { var n = Yf.call(this, t, e, i) || this; return n._context = n._createContext(), n } var Qf, Jf = (b($f, Qf = Ae), $f.prototype.run = function (t, e, i, n) { var r = i, o = function (t, e, i) { var n = t(e, i); return void 0 === n && (n = e), n }(t.configure || function (t) { return t }, e, n); return new (r ? Gf : Zf)(t, n, this._dom).onStart().send(o) }, $f); function $f(t) { var e = t.dom, i = Qf.call(this) || this; return i._dom = e, i } var tg, eg = "complete", ig = 500, ng = !0, rg = !0, og = !1, sg = (b(ag, tg = Ae), ag.prototype.register = function (t, e) { if (t in this._layouts) throw new Error("Layout " + t + " already exists"); var i = C({}, e, { name: t }); this._layouts[t] = i }, ag.prototype.getAvailableLayouts = function () { return Object.keys(this._layouts) }, ag.prototype.start = function (l, d) { var h = this; void 0 === d && (d = {}); var c = this._layouts[l]; return new Promise(function (n) { if (!c) throw new Error("layout " + l + " does not exist"); h._currentLayout && h.stop(), d.duration = "number" == typeof d.duration ? d.duration : ig; var r = c.onSync, o = -1 / 0; d.skipTextDrawing = void 0 === d.skipTextDrawing ? ng : d.skipTextDrawing; var t = d.locate || og; t && "boolean" == typeof t && (t = {}), d.locate = t; var e = h._onTaskStart, s = h._onTaskUpdate, a = h._onTaskComplete, i = { name: l, update: c.update, isRunning: c.isRunning, configure: c.configure, context: c.context, imports: c.imports, onStart: function () { e(c, d, this) }, onUpdate: function (t, e, i) { var n = Kt(); i && n - o < 40 || (o = n, s(this, l, t, i, r, d)) }, onEnd: function (e) { var i = this; this.once(eg, function (t) { a(e, t, c, d, n, i.getData()) }) } }; h._graphics.forceAttributesComputation(); var u = void 0 === d.useWebWorker ? rg : d.useWebWorker; h._currentLayout = h._tasks.run(i, d, u, h._modules) }) }, ag.prototype._animateCamera = function (t, e, i) { if (0 === t.indexes.length) return Promise.resolve(); var n = this._locate.layoutDataBoundingBox(t), r = this._locate.computeConfigForBounds(n, e); return this._camera.setView(r, { duration: i, easing: e.easing }) }, ag.prototype.stop = function () { return null !== this._currentLayout && (this._currentLayout.stop(), this._currentLayout.fire(eg, null), this._currentLayout = null), Promise.resolve() }, ag.prototype.isRunning = function () { return null !== this._currentLayout }, ag.prototype._assignNodePositions = function (t, e, i) { if (!t || i) { var n = t ? new Uint32Array(t.indexes) : void 0, r = this._graph.nodeList(n); return Promise.resolve(r) } for (var o = t.indexes, s = t.x, a = t.y, u = this._graph.nodeList(new Uint32Array(o)), l = ug(t), d = 0; d < l.length; d++)l[d] = { x: s[d], y: a[d] }; return u.setAttributes(l, e) }, ag); function ag(t) { var f = tg.call(this) || this; return f._currentLayout = null, f._onTaskUpdate = function (t, e, i, n, r, o) { var s = o.duration, a = o.onSync, u = o.onUpdate, l = o.dryRun, d = o.locate; if (a && f._dom.setTimeout(function () { return a(i, f._modules, n) }, s), r) { var h = r(i, f._modules, n); f._events.fire(xe.LAYOUT_COMPUTED, { type: xe.LAYOUT_COMPUTED, name: e, positions: h }), u && u(i, h, n); var c = f._assignNodePositions(h, s, l); n || (d && f._animateCamera(h, d, o.duration), c.then(function () { return t.fire(eg, h) })) } else n || t.fire(eg, i) }, f._onTaskComplete = function (t, e, i, n, r, o) { f._currentLayout = null, i.onEnd && t && i.onEnd(t, f._modules), n.skipTextDrawing && f._dom.setTimeout(function () { return f._graphics.showTexts() }, 50); var s = f._graph.nodeList(new Uint32Array(o.indexes)), a = n.dryRun && t ? e : lg(s), u = s.getId(), l = { before: ug(o), current: ug(a) }; f._events.fire(xe.LAYOUT_END, { type: xe.LAYOUT_END, name: i.name, positions: l, ids: u }), f._dom.setTimeout(function () { n.onEnd && n.onEnd(t), r({ name: i.name, positions: l, ids: u }) }) }, f._onTaskStart = function (t, e, i) { e.skipTextDrawing && f._graphics.hideTexts(); var n = lg(f._graph.getNodes(e.nodes)), r = n.ids; i.setData(n), f._events.fire(xe.LAYOUT_START, { type: xe.LAYOUT_START, name: t.name, ids: r, task: i }) }, f._modules = t, f._dom = t.dom, f._events = t.events, f._graph = t.graph, f._graphics = t.graphics, f._tasks = t.tasks, f._locate = t.locate, f._camera = t.camera, f._layouts = {}, f._events.register([xe.LAYOUT_START, xe.LAYOUT_END, xe.LAYOUT_COMPUTED]), f._currentLayout = null, f._events.on(xe.CLEAR_GRAPH, function () { return f.stop() }), f } function ug(t) { for (var e = t.x, i = t.y, n = t.indexes.length, r = new Array(n), o = 0; o < n; o++)r[o] = { x: e[o], y: i[o] }; return r } function lg(t) { var e = t.getAttribute("x"), i = t.getAttribute("y"); return { ids: t.getId(), indexes: t._indexes, x: e, y: i } } function dg(value) { return "number" == typeof value && isFinite(value) } var hg = (cg.prototype.onUpdate = function (t) { this._onUpdateHandlers.push(t) }, cg.prototype.getPropertyInfo = function () { return this._info }, cg.prototype.getPath = function () { return this._path.slice() }, cg.prototype.destroy = function () { this._module.unwatchPropertyInformation(this._isNode, this._path, this._triggerUpdate, this._filter, this._unwindArrays) }, cg.prototype.kill = function () { return this.destroy() }, cg); function cg(t, e, i) { var n = i.path, r = i.filter, o = i.unwindArrays, s = this; this._module = t, this._isNode = e, this._path = n || [], this._filter = r, this._unwindArrays = o, this._onUpdateHandlers = [], this._triggerUpdate = function (t) { for (var e = 0; e < s._onUpdateHandlers.length; ++e)s._onUpdateHandlers[e](t) }, this._info = t.watchPropertyInformation(this._isNode, this._path, this._triggerUpdate, this._filter, this._unwindArrays) } var fg = (Object.defineProperty(gg.prototype, "path", { get: function () { return this._path }, enumerable: !0, configurable: !0 }), gg.prototype.onPropertyAdded = function (t) { return this._onAddHandlers.push(t), this }, gg.prototype.onPropertyRemoved = function (t) { return this._onRemoveHandlers.push(t), this }, gg.prototype.onPropertyUpdated = function (t) { return this._onUpdateHandlers.push(t), this }, gg.prototype.getPath = function () { return this._path.slice() }, gg.prototype.getProperties = function () { return this._propertyList.slice() }, gg.prototype.getPropertyInfo = function (t) { var e = this._properties[t]; return e ? e.info : null }, gg.prototype.destroy = function () { var r = this; V(this._properties, function (t, e) { var i = t.handler, n = r._path.concat([e]); r._module.unwatchPropertyInformation(r._isNode, n, i, r._filter, r._unwindArrays) }), this._propertyList = void 0, this._properties = void 0, this._onAddHandlers = void 0, this._onRemoveHandlers = void 0, this._onUpdateHandlers = void 0; var t = this._module._objectPropertyWatchers.indexOf(this); this._module._objectPropertyWatchers.splice(t, 1) }, gg.prototype.kill = function () { return this.destroy() }, gg.prototype.updateSubPropertiesToWatch = function (t, e) { if (t === this._isNode) for (var i = e.getData(this._path), n = 0; n < i.length; n++) { var r = i[n]; if (B(r)) for (var o = Object.keys(r), s = 0; s < o.length; s++)this._addSubPropertyToWatch(o[s]) } }, gg.prototype._addSubPropertyToWatch = function (t) { var e = this; if (!this._properties[t]) { var i = this._path.concat([t]), n = function () { return e._triggerPropertyUpdate(t) }, r = this._unwindArrays, o = this._isNode, s = this._filter, a = this._module.watchPropertyInformation(o, i, n, s, r); this._properties[t] = { handler: n, info: a }, this._triggerPropertyUpdate(t) } }, gg.prototype._triggerPropertyUpdate = function (t) { var e = this._properties[t].info, i = this._propertyList.indexOf(t), n = -1 !== i, r = "undefined" !== e.getType(); !n && r ? (this._propertyList.push(t), this._triggerHandlers("_onAddHandlers", t, e), this._triggerHandlers("_onUpdateHandlers", t, e)) : n && !r ? (this._propertyList.splice(i, 1), this._triggerHandlers("_onUpdateHandlers", t, e), this._triggerHandlers("_onRemoveHandlers", t, e)) : n && r && this._triggerHandlers("_onUpdateHandlers", t, e) }, gg.prototype._triggerHandlers = function (t, e, i) { for (var n = this[t], r = 0, o = n.length; r < o; r++)n[r](e, i) }, gg); function gg(t, e, i) { var n = i.path, r = i.filter, o = i.unwindArrays; this._module = t, this._isNode = e, this._path = n, this._filter = r, this._unwindArrays = o, this._propertyList = [], this._properties = {}, this._onAddHandlers = [], this._onRemoveHandlers = [], this._onUpdateHandlers = [] } var pg = (_g.prototype.isNode = function () { return this._watcher.isNode }, _g.prototype.getPath = function () { return this._watcher.property.slice() }, _g.prototype.getBoundaries = function () { var t = this._watcher.boundaries; return t ? { min: t.min, max: t.max } : null }, _g.prototype.getValues = function () { return this._watcher.values.keys() }, _g.prototype.getValueCount = function (value) { return this._watcher.values.get(value) || 0 }, _g.prototype.getCount = function () { return this._watcher.total }, _g.prototype.getType = function () { return 0 < this._watcher.any ? "any" : 0 < this._watcher.numbers ? "number" : "undefined" }, _g); function _g(t) { this._watcher = t } function vg(t) { return "number" == typeof t && isNaN(t) } var mg = (yg.prototype.set = function (t, value) { var e = this._getIndex(t); return -1 === e ? (this._keys.push(t.slice()), this._values.push(value), !0) : (this._values[e] = value, !1) }, yg.prototype.get = function (t) { var e = this._getIndex(t); return -1 === e ? void 0 : this._values[e] }, yg.prototype.has = function (t) { return -1 !== this._getIndex(t) }, yg.prototype.delete = function (t) { var e = this._getIndex(t); return -1 !== e && (this._keys.splice(e, 1), this._values.splice(e, 1), !0) }, yg.prototype.keys = function () { return this._keys.map(function (t) { return t.slice() }) }, yg.prototype.values = function () { return this._values.slice() }, yg.prototype._getIndex = function (t) { for (var e = 0; e < this._keys.length; e++) { var i = this._keys[e]; if (i.length === t.length) { for (var n = !0, r = 0; r < t.length; r++) { var o = i[r], s = t[r]; if (!(o === s || vg(o) && vg(s))) { n = !1; break } } if (n) return e } } return -1 }, Object.defineProperty(yg.prototype, "size", { get: function () { return this._keys.length }, enumerable: !0, configurable: !0 }), yg); function yg() { this._keys = [], this._values = [] } var bg = (xg.prototype.clear = function () { return this._arrays = new mg, this._map.clear() }, xg.prototype.delete = function (t) { return I(t) ? this._arrays.delete(t) : this._map.delete(t) }, xg.prototype.get = function (t) { return I(t) ? this._arrays.get(t) : this._map.get(t) }, xg.prototype.set = function (t, value) { return I(t) ? this._arrays.set(t, value) : this._map.set(t, value), this }, xg.prototype.keys = function () { return eo(this._map).concat(this._arrays.keys()) }, xg.prototype.values = function () { return io(this._map).concat(this._arrays.values()) }, Object.defineProperty(xg.prototype, "size", { get: function () { return this._map.size + this._arrays.size }, enumerable: !0, configurable: !0 }), xg); function xg() { this._map = new Map, this._arrays = new mg } var Eg, Ag = (b(Sg, Eg = Ae), Sg.prototype.watchNodeObjectProperty = function (t) { return this._watchObjectProperty(!0, Ng(t)) }, Sg.prototype.watchEdgeObjectProperty = function (t) { return this._watchObjectProperty(!1, Ng(t)) }, Sg.prototype.watchNodeNonObjectProperty = function (t) { return this._watchNonObjectProperty(!0, Ng(t)) }, Sg.prototype.watchEdgeNonObjectProperty = function (t) { return this._watchNonObjectProperty(!1, Ng(t)) }, Sg.prototype.watchPropertyInformation = function (t, e, i, n, r) { var o = this._findWatcher(t, e, n, r) || this._createWatcher(t, e, n, r); return i && o.onChange.push(i), o.info }, Sg.prototype.unwatchPropertyInformation = function (t, e, i, n, r) { var o = this._findWatcher(t, e, n, r); if (o) { var s = o.onChange, a = s.indexOf(i); if (-1 !== a && (s.splice(a, 1), 0 === s.length)) { var u = this._propertyWatchers.indexOf(o); this._propertyWatchers.splice(u, 1) } } }, Sg.prototype._watchObjectProperty = function (t, e) { var i = new fg(this, t, e); return this._objectPropertyWatchers.push(i), i.updateSubPropertiesToWatch(t, this._graph[t ? "getNodes" : "getEdges"](e.filter)), i }, Sg.prototype._watchNonObjectProperty = function (t, e) { return new hg(this, t, e) }, Sg.prototype._findWatcher = function (t, e, i, n) { for (var r = 0; r < this._propertyWatchers.length; ++r) { var o = this._propertyWatchers[r]; if (o.isNode === t && o.filter === i && o.unwindArrays === n && Cg(o.property, e)) return o } return null }, Sg.prototype._createWatcher = function (t, e, i, n) { var r = { isNode: t, property: e, numbers: 0, any: 0, total: 0, values: new bg, boundaries: null, onChange: [], filter: i, unwindArrays: n, info: void 0 }; return r.info = new pg(r), Ig(r, this._graph[t ? "getNodes" : "getEdges"](i).getData(e)), this._propertyWatchers.push(r), r }, Sg); function Sg(t) { var e, i = t.graph, n = t.events, m = Eg.call(this) || this; return m._onExcludedStateChange = function (t) { for (var e = t.elements, i = !t.value, n = 0, r = m._propertyWatchers.length; n < r; n++) { var o = m._propertyWatchers[n]; o.isNode === e.isNode && "visible" === o.filter && (i ? Ig(o, e.getData(o.property)) : Lg(o, e.getData(o.property)), Tg(o)) } }, m._onDataChange = function (t) { for (var e = t.isNode, a = t.changes, i = 0; i < m._propertyWatchers.length; ++i) { var n = (p = m._propertyWatchers[i]).property, r = "all" === p.filter; if (p.isNode === e) for (var o = 0; o < a.length; ++o) { var s = a[o], u = Mg(s.property || [], n); if (u) { for (var l = s.nodes || s.edges, d = [], h = [], c = 0; c < l.size; ++c) { var f = l.get(c); (r || f.isVisible()) && (d.push(H(s.newValues[c], u)), h.push(H(s.previousValues[c], u))) } d.length && (Ig(p, d), Lg(p, h), Tg(p)) } } } i = 0; for (var g = m._objectPropertyWatchers.length; i < g; i++) { var p, _ = (p = m._objectPropertyWatchers[i]).path, v = function (t) { var e = a[t], i = e.property, n = e.nodes, r = e.edges, o = n || r, s = o.isNode; (!i || i.length <= _.length + 1 && _.every(function (t, e) { return t === i[e] })) && p.updateSubPropertiesToWatch(s, o) }; for (o = 0; o < a.length; ++o)v(o) } }, m._onElementsAdded = function (t) { for (var e = t.nodes || t.edges, i = 0; i < m._propertyWatchers.length; ++i) { var n = m._propertyWatchers[i]; if (n.isNode === e.isNode) { var r = e.getData(n.property); r.length && (Ig(n, r), Tg(n)) } } for (i = 0; i < m._objectPropertyWatchers.length; i++)m._objectPropertyWatchers[i].updateSubPropertiesToWatch(e.isNode, e) }, m._onElementsRemoved = function (t) { for (var e = t.nodes || t.edges, i = 0; i < m._propertyWatchers.length; ++i) { var n = m._propertyWatchers[i], r = "all" === n.filter; if (n.isNode === e.isNode && r) { var o = e.getData(n.property); o.length && (Lg(n, o), Tg(n)) } } }, m._onGraphClear = function () { m._propertyWatchers.forEach(function (t) { t.numbers = 0, t.any = 0, t.total = 0, t.boundaries = null, t.values.clear() }) }, m._graph = i, m._propertyWatchers = [], m._objectPropertyWatchers = [], n.on(((e = {})[xe.EXCLUDED_STATE_CHANGE] = m._onExcludedStateChange, e[xe.UPDATE_NODE_DATA + " " + xe.UPDATE_EDGE_DATA] = m._onDataChange, e[xe.ADD_NODES + " " + xe.ADD_EDGES] = m._onElementsAdded, e[xe.REMOVE_NODES + " " + xe.REMOVE_EDGES] = m._onElementsRemoved, e[xe.CLEAR_GRAPH] = m._onGraphClear, e)), m } function wg(value) { return null == value ? [] : F(value) } function Tg(t) { for (var e = 0; e < t.onChange.length; ++e)t.onChange[e](t.info) } function Cg(t, e) { if (t.length !== e.length) return !1; for (var i = 0; i < t.length; ++i)if (t[i] !== e[i]) return !1; return !0 } function Mg(t, e) { if (t.length > e.length) return null; for (var i = 0; i < t.length; ++i)if (t[i] !== e[i]) return null; return e.slice(i) } function Ig(t, e, i) { for (var n = t.values, r = !i && t.unwindArrays, o = 0; o < e.length; ++o) { var value = e[o]; if (i || void 0 === value || (t.total += 1), r && Array.isArray(value)) Ig(t, value, !0); else { var s = n.get(value); s ? n.set(value, s + 1) : (n.set(value, 1), dg(value) ? (t.boundaries ? value < t.boundaries.min ? t.boundaries.min = value : value > t.boundaries.max && (t.boundaries.max = value) : t.boundaries = { min: value, max: value }, t.numbers += 1) : void 0 !== value && (t.any += 1)) } } } function Lg(t, e, i) { for (var n = t.values, r = !i && t.unwindArrays, o = t.boundaries, s = !1, a = 0; a < e.length; ++a) { var value = e[a]; if (i || void 0 === value || --t.total, r && Array.isArray(value)) s = s || Lg(t, value, !0); else { var u = n.get(value); 1 < u ? n.set(value, u - 1) : (n.delete(value), dg(value) ? (--t.numbers, !o || o.min !== value && o.max !== value || (s = !0)) : void 0 !== value && --t.any) } } return !i && s && (t.boundaries = function (t) { for (var e = void 0, i = void 0, n = 0; n < t.length; ++n) { var value = t[n]; dg(value) && ((void 0 === e || value < e) && (e = value), (void 0 === i || i < value) && (i = value)) } return void 0 === e ? null : { min: e, max: i } }(n.keys())), s } function Ng(t) { return "object" != typeof t || null === t || Array.isArray(t) ? { path: wg(t), filter: "visible", unwindArrays: !1 } : { path: wg(t.path), filter: "all" === t.filter ? "all" : "visible", unwindArrays: !!t.unwindArrays } } function minHeap(o, s, a, u) { void 0 === o && (o = function (t, e) { return t - e }), void 0 === s && (s = []), void 0 === a && (a = {}), void 0 === u && (u = function (t) { return t }); var l = s.length; function e(t) { for (; ;) { var e = 2 * t + 1, i = 1 + e, n = t; if (e < l && o(s[e], s[n]) < 0 && (n = e), i < l && o(s[i], s[n]) < 0 && (n = i), n === t) return t; var r = s[n]; s[n] = s[t], s[t] = r, a[u(s[n])] = n, a[u(r)] = t, t = n } } return { get keys() { return a }, get size() { return l }, heapify: e, pop: function () { if (!(l <= 0)) { if (1 === l) return l-- , s[0]; var t = s[0]; return s[0] = s[l - 1], l-- , e(0), t } }, decreaseKey: function (t, value) { for (void 0 !== value && (s[t] = value, a[u(value)] = t); 0 < t;) { var e = t - 1 >> 1; if (!(0 < o(s[e], s[t]))) break; var i = s[t]; s[t] = s[e], s[e] = i, a[u(s[t])] = t, t = a[u(i)] = e } return t }, min: function () { return s[0] }, remove: function (t) { return this.decreaseKey(t, Number.NEGATIVE_INFINITY), this.pop() }, push: function (t) { var e = ++l - 1; for (s[e] = t; 0 < e;) { var i = e - 1 >> 1; if (!(0 < o(s[i], s[e]))) break; var n = s[e]; s[e] = s[i], s[i] = n, a[u(s[e])] = e, e = a[u(n)] = i } return e }, empty: function () { return l <= 0 }, toArray: function () { return s.slice(0, l) } } } function dijkstra(t, e, i, n, r, o, s) { void 0 === n && (n = t.map(function (t, e) { return e + 1 })); var a = n ? n.length : t.length, u = new Float32Array(a), l = new Int32Array(a), d = new Uint32Array(a), h = Number.POSITIVE_INFINITY, c = {}; if (0 === a) return { distances: u, path: null, pathLength: null }; if (!r) { r = {}; for (var f = 0; f < a; f++)r[n[f]] = f } for (f = 0; f < a; f++)u[f] = h, l[f] = -1, d[f] = c[f] = f; var g = minHeap(function (t, e) { return u[t] - u[e] }, d, c); for (u[r[e]] = 0, g.decreaseKey(c[r[e]]); 0 !== g.size;) { var p = g.pop(), _ = u[p], v = t[p]; if (_ === h) break; f = 0; for (var m = v.nodes.length; f < m; f++) { var y = v.nodes[f], b = o ? 1 : s ? s(n[p], y) : v.weights[f], x = r[y]; if (void 0 !== x) { var E = _ + b; E < u[x] && (u[x] = E, l[x] = p, g.decreaseKey(c[x])) } } } var A = null, S = null; if (void 0 !== i) { var w = r[i]; if (u[w] !== h) { A = []; for (f = w; -1 !== f; f = l[f])A.push(n[f]); A.reverse(), S = u[i] } } return { distances: u, path: A, pathLength: S } } function kg(t, e) { var i = t.getPosition(), n = e.getPosition(); return distance(i.x, i.y, n.x, n.y) } var Og, Fg = { pathLengthFunction: kg, heuristicLengthFunction: kg }, Rg = { pathLengthFunction: function () { return 1 }, heuristicLengthFunction: function () { return 0 } }, Pg = (b(Dg, Og = Ae), Dg.prototype.astar = function (t, e, i) { return zg(this._graph, t, e, this._cachedObjectList, C({}, Fg, i)) }, Dg.prototype.dijkstra = function (t, e, i) { return zg(this._graph, t, e, this._cachedObjectList, C({}, Rg, i)) }, Dg.prototype.dijkstraBig = function (t, e, i) { var n = this._graph.getNodes(), r = dijkstra(this._graph.getAdjacencyList({ directed: i.directed, weight: 1, nodes: n }), this._graph.getNode(t)._index, this._graph.getNode(e)._index, n._indexes, void 0, !1); return r.path && this._graph.nodeList(new Uint32Array(r.path)) }, Dg); function Dg(t) { var e = t.graph, i = Og.call(this) || this; return i._graph = e, i._cachedObjectList = e.getNodeAttribute("object"), i } function zg(t, e, i, n, r) { var o = void 0 === r ? {} : r, s = o.pathLengthFunction, a = o.heuristicLengthFunction, u = o.filter, l = o.directed, d = t.getNode(e)._index, h = t.getNode(i)._index, c = s, f = a, g = l ? ni.OUT : ni.BOTH, p = n.get(d), _ = n.get(h), v = null; if (d === h) return t.nodeList(new Uint32Array([d])); for (var m = t.getNodeMaxIndex() + 1, y = new no, b = new no, x = new Int32Array(m), E = new Float32Array(m), A = new Float32Array(m), S = 0; S < m; ++S)x[S] = -1, E[S] = 1 / 0, A[S] = 1 / 0; for (b.add(d), E[d] = 0, A[d] = f(p, _); 0 !== b.length;) { var w = b.length, T = b.get(0), C = 0, M = A[T]; for (S = 1; S < w; ++S) { var I = b.get(S), L = A[I]; L < M && (M = L, T = I, C = S) } if (T === h) { v = Bg(x, d, h); break } var N = n.get(T); b.removeByPosition(C), y.add(T); var k = t.node(T).getAdjacentNodes({ direction: g, filter: u })._indexes; for (S = 0; S < k.length; ++S) { var O = k[S], F = n.get(O); if (!y.has(O)) { var R = E[T] + c(N, F); !b.add(O) && R >= E[O] || (x[O] = T, E[O] = R, A[O] = R + f(F, _)) } } } return v && t.nodeList(v) } function Bg(t, e, i) { for (var n = [i], r = i; r !== e;)r = t[r], n.push(r); return n.reverse(), n } var Ug, Vg = (b(jg, Ug = Ae), Object.defineProperty(jg.prototype, "x", { get: function () { return this._position.x || 0 }, enumerable: !0, configurable: !0 }), Object.defineProperty(jg.prototype, "y", { get: function () { return this._position.y || 0 }, enumerable: !0, configurable: !0 }), jg.prototype._later = function () { return this._dom.afterNextFrame() }, jg.prototype.move = function (t) { var i = this, n = t.x, r = t.y; return void 0 !== n && void 0 !== r ? this._dom.afterNextFrame().then(function () { var t = n - i.x, e = r - i.y; return i._events.fire(xe.VIRTUAL_MOVE, { x: n, y: r, dx: t, dy: e }), i._later() }) : Promise.resolve() }, jg.prototype.down = function (t) { var e = this, i = void 0 === t ? {} : t, n = i.x, r = i.y, o = i.button, s = void 0 === o ? gc.LEFT : o; return this.move({ x: n, y: r }).then(function () { return e._events.fire(xe.VIRTUAL_DOWN, { x: e.x, y: e.y, button: s }), e._events.fire(xe.VIRTUAL_MOVE, { x: e.x, y: e.y, dx: 0, dy: 0, button: s }), e._later() }) }, jg.prototype.up = function (t) { var e = this, i = void 0 === t ? {} : t, n = i.x, r = i.y, o = i.button, s = void 0 === o ? gc.LEFT : o; return this.move({ x: n, y: r }).then(function () { return e._events.fire(xe.VIRTUAL_UP, { x: n, y: r, button: s }), e._later() }) }, jg.prototype.click = function (t) { var e = this, i = void 0 === t ? {} : t, n = i.x, r = i.y, o = i.button, s = void 0 === o ? gc.LEFT : o; return this.move({ x: n, y: r }).then(function () { return e._events.fire(xe.VIRTUAL_CLICK, { x: n, y: r, button: s }), e._later() }) }, jg.prototype.rightClick = function (t) { var e = this, i = void 0 === t ? {} : t, n = i.x, r = i.y, o = i.button, s = void 0 === o ? gc.RIGHT : o; return this.move({ x: n, y: r }).then(function () { return e._events.fire(xe.VIRTUAL_CLICK, { x: n, y: r, button: s }), e._later() }) }, jg.prototype.doubleClick = function (t) { var e = this, i = void 0 === t ? {} : t, n = i.x, r = i.y, o = i.button, s = void 0 === o ? gc.LEFT : o; return this.move({ x: n, y: r }).then(function () { return e._events.fire(xe.VIRTUAL_DOUBLE_CLICK, { x: n, y: r, button: s }), e._later() }) }, jg.prototype.drag = function (t, e) { var i = this; return this.down(t).then(function () { return i.move(e) }).then(function () { return i.up(e) }) }, jg.prototype.wheel = function (t) { var e = this, i = t.x, n = t.y, r = t.delta; return this.move({ x: i, y: n }).then(function () { return e._events.fire(xe.VIRTUAL_WHEEL, { x: i, y: n, delta: r }), e._later() }) }, jg); function jg(t) { var e = t.position, i = t.dom, n = t.events, r = Ug.call(this) || this; return r._dom = i, r._events = n, r._position = e, r._events.register([xe.VIRTUAL_DOWN, xe.VIRTUAL_UP, xe.VIRTUAL_MOVE, xe.VIRTUAL_CLICK, xe.VIRTUAL_DOUBLE_CLICK, xe.VIRTUAL_WHEEL]), r } function Gg(t, e, i, n, r, o) { var s = wt(), a = o.graphToScreenCoordinates(t), u = o.graphToScreenCoordinates(e); r.beginPath(), r.moveTo(a.x * s, a.y * s), r.lineTo(u.x * s, u.y * s), r.strokeStyle = n, r.lineWidth = i, r.stroke() } function Hg(t, e, i, n) { for (var r, o, s = 0, a = t.length - 1; s < a;)r = (s + a) / 2 | 0, o = Math.abs(e[t[r]] - i), Math.abs(e[t[1 + r]] - i) <= o ? s = 1 + r : a = r; return n ? a : t[a] } function qg(t, e, i, n, r, o, s) { for (var a, u, l, d, h, c, f = !1, g = 0, p = t.length; !f && g < p; g++)for (var _ = 0; !f && _ < p; _++)if (g !== _) { var v = t[g], m = t[_]; _ < g && (d = m, m = v, v = d); var y = e[v], b = e[m], x = o.get(v), E = o.get(m); y + x < n - r && n + r < b - E && Math.abs(Math.abs(y + x - (n - r)) - Math.abs(b - E - (n + r))) <= s ? (a = v, u = i, l = m, h = [y + x, (c = y + x + Math.abs(b - E - (y + x)) / 2) - r, c + r, b - E], f = !0) : y + x < n - r && b + E < n - r && Math.abs(Math.abs(y + x - (b - E)) - Math.abs(Math.max(y + x, b + E) - (n - r))) <= s ? (a = v, u = m, l = i, h = [y + x, b - E, b + E, (c = b + x + Math.abs(Math.abs(y + x - (b - E))) + r) - r], f = !0) : n + r < y - x && n + r < b - E && Math.abs(Math.abs(y + x - (b - E)) - Math.abs(Math.min(y - x, b - E) - (n + r))) <= s && (a = i, u = v, l = m, h = [(c = y - x - Math.abs(Math.abs(y + x - (b - E))) - r) + r, y - x, y + x, b - E], f = !0) } return f ? { a: a, b: u, c: l, current: i, target: c, points: h } : null } var Wg, Xg, Yg = { tolerance: 5, centerSnapDistance: 240, sideSnapDistanceFactor: 3, guidelineWidth: 1, guidelineColor: "#ff0000", preferredDistance: { enabled: !0, ratio: 1.13, tolerance: 10, lineColor: "#00C3FF", lineWidth: 1 }, neighbours: { enabled: !0, offset: 5, tolerance: 3, lineColor: "#00C3FF", lineWidth: 1 } }; (Xg = Wg = Wg || {})[Xg.NONE = 0] = "NONE", Xg[Xg.CENTER = 1] = "CENTER", Xg[Xg.LEFT = 2] = "LEFT", Xg[Xg.RIGHT = 3] = "RIGHT", Xg[Xg.TOP = 4] = "TOP", Xg[Xg.BOTTOM = 5] = "BOTTOM"; var Zg, Kg = (b(Qg, Zg = Ae), Qg.prototype.enable = function (t) { var r = this; this._enabled || (this._options = Q(t, Yg), this._enabled = !0, this._graphics.addCanvas(this._canvas), this._events.on(xe.NODES_DRAG_START, this._onNodeDragStart), this._events.on(xe.NODES_DRAG_END, this._onNodeDragEnd), this._settings.update({ "interactions.drag.onBeforeDrag": function (t, e, i, n) { return r._onBeforeDrag(e, i, n) } })) }, Qg.prototype.disable = function () { this._enabled && (this._events.removeListener(this._onNodeDragStart), this._events.removeListener(this._onNodeDragEnd), this._graphics.removeCanvas(this._canvas), this._settings.update({ "interactions.drag.onBeforeDrag": null }), this._enabled = !1) }, Qg.prototype.enabled = function () { return this._enabled }, Qg.prototype._onBeforeDrag = function (t, e, i) { if (this._node) { var n = i[0]; this._scan(n), this._node.setAttributes(n) } }, Qg.prototype._cacheViewportData = function () { var t = this._camera, e = t.screenToGraphCoordinates({ x: 0, y: 0 }), i = t.screenToGraphCoordinates({ x: t.width, y: t.height }); this._nodes = this._spatial.getNodesByBoundingBox(e.x, e.y, i.x, i.y); var n = this._node._index, r = Array.from(this._nodes._indexes); r.splice(r.indexOf(n), 1); var o = this._graph.getNodeAttribute("radius"), s = this._graph.getNodeAttribute("x"), a = this._graph.getNodeAttribute("y"), u = s.buffer(), l = a.buffer(), d = X(r.slice(), s), h = X(r.slice(), a), c = {}, f = {}; this._gridResolution = this._node.getAttribute("radius"); for (var g = this._gridResolution, p = 0, _ = r.length; p < _; p++) { var v = d[p], m = h[p], y = u[v] / g | 0, b = l[m] / g | 0; c[y] || (c[y] = []), f[b] || (f[b] = []), c[y].push(v), f[b].push(m) } this._nodesByX = d, this._nodesByY = h, this._xGrid = c, this._yGrid = f, this._xList = s, this._yList = a, this._X = u, this._Y = l, this._R = o }, Qg.prototype._scan = function (t) { rr(this._canvas, this._ctx); var e, i, n, r, o, s, a, u, l, d = this._node._index, h = t.x, c = t.y, f = this._r, g = this._options, p = this._xList, _ = this._yList, v = this._R, m = this._X, y = this._Y, b = this._camera.zoom, x = Math.min(f, this._options.tolerance / b), E = 2 * f * g.sideSnapDistanceFactor, A = g.guidelineWidth, S = g.guidelineColor, w = d, T = d, C = !1, M = !1; if (w = Hg(this._nodesByX, m, h), T = Hg(this._nodesByY, y, c), Math.abs(m[w] - h) > g.centerSnapDistance && (w = d), Math.abs(y[T] - c) > g.centerSnapDistance && (T = d), this._xsnap = Wg.NONE, w !== d) { e = this._vguideline.start, i = this._vguideline.end, n = m[l = w], r = y[l], o = v.get(l), u = Math.abs(h - n); var I = Math.abs(h - f - (n - o)), L = Math.abs(h + f - (n + o)); u < Math.max(f, o) && (r < c ? (e.y = r - o, i.y = c + f) : (e.y = r + o, i.y = c - f), (N = Math.min(I, u, L)) === u ? (e.x = i.x = n, i.y = c, e.y = r, this._xsnap = Wg.CENTER) : Math.abs(c - r) < o + f + E && (N === I ? (e.x = i.x = n - o, this._xsnap = Wg.LEFT) : (e.x = i.x = n + o, this._xsnap = Wg.RIGHT)), N < x && (C = !0)), this._xsnap !== Wg.NONE && Gg(e, i, A, S, this._ctx, this._camera) } if (this._ysnap = Wg.NONE, T !== d) { e = this._hguideline.start, i = this._hguideline.end, n = m[l = T], r = y[l], o = v.get(l), u = Math.abs(c - r); var N, k = Math.abs(c - f - (r - o)), O = Math.abs(c + f - (r + o)); u < Math.max(f, o) && (n < h ? (e.x = n - o, i.x = h + f) : (e.x = n + o, i.x = h - f), (N = Math.min(k, u, O)) === u ? (e.y = i.y = r, i.x = h, e.x = n, this._ysnap = Wg.CENTER) : Math.abs(h - n) < o + f + E && (N === k ? (e.y = i.y = r - o, this._ysnap = Wg.TOP) : (e.y = i.y = r + o, this._ysnap = Wg.BOTTOM)), N < x && (M = !0)), this._ysnap !== Wg.NONE && Gg(e, i, A, S, this._ctx, this._camera) } if (g.preferredDistance.enabled) { var F = g.preferredDistance.ratio, R = Math.min(g.preferredDistance.tolerance / b, f), P = Math.max(f, o); if (w === d || this._xsnap !== Wg.NONE && C) T !== d && (this._ysnap === Wg.NONE || !M) && (n = m[l = T], r = y[l], o = v.get(l), (a = Math.abs(c - r) - (f + o) * (1 + F)) <= R && -R <= a) && (D = c < r ? -1 : 1, e = this._hguideline.start, i = this._hguideline.end, e.x = n - P, i.x = n + P, e.y = i.y = r, Gg(e, i, A, S, this._ctx, this._camera), e.x = h - P, i.x = h + P, e.y = i.y = r + D * (1 + F) * (f + o), Gg(e, i, A, S, this._ctx, this._camera), this._ysnap = Wg.CENTER, M = !0); else if (n = m[l = w], r = y[l], o = v.get(l), (s = Math.abs(h - n) - (f + o) * (1 + F)) <= R && -R <= s) { var D = h < n ? -1 : 1; e = this._vguideline.start, i = this._vguideline.end, e.x = i.x = n + D * (1 + F) * (f + o), e.y = r - P, i.y = r + P, e.x = i.x = n, Gg(e, i, A, S, this._ctx, this._camera), e.y = c - P, i.y = c + P, e.x = i.x = n + D * (1 + F) * (f + o), Gg(e, i, A, S, this._ctx, this._camera), this._xsnap = Wg.CENTER, C = !0 } } if (g.neighbours.enabled) { var z = this._gridResolution, B = h / z | 0, U = c / z | 0, V = this._xGrid, j = this._yGrid, G = [], H = [].concat(j[U - 1] || G, j[U] || G, j[1 + U] || G), q = [].concat(V[B - 1] || G, V[B] || G, V[1 + B] || G), W = void 0; 1 < H.length && (X(H, p), (W = qg(H, m, d, h, f, v, x)) && (this._drawNeighbourGuidelines(W, t, !1), C = !1)), 1 < q.length && !W && (X(q, _), (W = qg(q, y, d, c, f, v, x)) && (this._drawNeighbourGuidelines(W, t, !0), M = !1)) } (C || M) && this._snap(t, !C, !M) }, Qg.prototype._drawNeighbourGuidelines = function (t, e, i) { var n, r, o = t.a, s = t.b, a = t.c, u = t.points, l = t.target, d = { x: 0, y: 0 }, h = { x: 0, y: 0 }, c = this._R, f = this._X, g = this._Y, p = c.getMultiple([o, s, a]), _ = p[0], v = p[1], m = p[2], y = this._options.neighbours, b = y.offset, x = y.lineWidth, E = y.lineColor; r = i ? (e.y = l, _ = -_, v = -v, m = -m, n = h.x = d.x = Math.min(f[o] + _, f[s] + v, f[a] + m) - b, f) : (e.x = l, n = h.y = d.y = Math.max(g[o] + _, g[s] + v, g[a] + m) + b, g); var A = i ? "y" : "x", S = i ? "x" : "y"; d[A] = u[0], h[A] = u[1], Gg(d, h, x, E, this._ctx, this._camera), d[A] = u[2], h[A] = u[3], Gg(d, h, x, E, this._ctx, this._camera), d[A] = u[0], d[S] = n - b / 2, h[A] = u[0], d[S] = r[o] + _, Gg(d, h, x, E, this._ctx, this._camera), d[A] = u[1], d[S] = n - b / 2, h[A] = u[1], d[S] = r[s] + v, Gg(d, h, x, E, this._ctx, this._camera), d[A] = u[2], d[S] = n - b / 2, h[A] = u[2], d[S] = r[s] + v, Gg(d, h, x, E, this._ctx, this._camera), d[A] = u[3], d[S] = n - b / 2, h[A] = u[3], d[S] = r[a] + m, Gg(d, h, x, E, this._ctx, this._camera) }, Qg.prototype._snap = function (t, e, i) { var n, r = this._xsnap, o = this._ysnap; e || r === Wg.NONE || (n = this._vguideline.end, r === Wg.LEFT ? t.x = n.x + this._r : r === Wg.RIGHT ? t.x = n.x - this._r : t.x = n.x), i || o === Wg.NONE || (n = this._hguideline.end, o === Wg.TOP ? t.y = n.y + this._r : o === Wg.BOTTOM ? t.y = n.y - this._r : t.y = n.y) }, Qg); function Qg(t) { var e = t.graph, i = t.graphics, n = t.spatial, r = t.camera, o = t.events, s = t.settings, a = Zg.call(this) || this; return a._options = j(Yg), a._enabled = !1, a._ysnap = Wg.NONE, a._xsnap = Wg.NONE, a._node = null, a._nodes = null, a._r = 0, a._vguideline = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } }, a._hguideline = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } }, a._gridResolution = 0, a._onNodeDragStart = function (t) { var e = t.nodes; 1 === e.size && (a._node = e.get(0), a._cacheViewportData(), a._r = a._node.getAttribute("radius")) }, a._onNodeDragEnd = function () { a._node = null, rr(a._canvas, a._ctx) }, a._graph = e, a._graphics = i, a._spatial = n, a._settings = s, a._events = o, a._camera = r, a._options = j(Yg), a._enabled = !1, a._canvas = nr(), a._ctx = a._canvas.getContext("2d"), a } var Jg = ($g.prototype.getId = function () { return this._id }, $g.prototype.whenApplied = function () { return this._whenApplied }, $g.prototype.refresh = function () { return this._module.refreshRule(this._id) }, $g.prototype.getIndex = function () { return this._module.getRuleIndex(this._id) }, $g.prototype.setIndex = function (t) { return this._module.setRuleIndex(this._id, t) }, $g.prototype.update = function (t) { return this._module.updateRule(this._id, t) }, $g.prototype.getDefinition = function () { return this._module.getRuleDefinition(this._id) }, $g.prototype.destroy = function () { return this._module.destroyRule(this._id) }, $g.prototype.delete = function () { return this.destroy() }, $g); function $g(t, e, i) { var n = this; this._module = t, this._id = e, this._whenApplied = i.then(function () { return n }) } var tp, ep = (b(ip, tp = Ae), ip.prototype._get = function (t) { for (var e = 0; e < this._rules.length; ++e) { var i = this._rules[e]; if (i.id === t) return i.index = e, i } throw new Error("calling a method on a destroyed style rule") }, ip.prototype._updatePriorities = function () { for (var t = 0; t < this._rules.length; ++t) { var e = 3 + .001 * t; this._rules[t].attributeLayer.update({ priority: e }) } }, ip.prototype.addRule = function (t) { void 0 === t && (t = {}); var e = this._idCounter++, i = this._graphics.addAttributeLayer(C({ name: "rule(" + e + ")" }, np(t))), n = this._dom.afterNextFrame(), r = new Jg(this, e, n), o = { id: e, attributeLayer: i, wrapper: r }; return this._rules.push(o), this._updatePriorities(), r }, ip.prototype.getRuleIndex = function (t) { return this._get(t).index }, ip.prototype.setRuleIndex = function (t, e) { var i = this._get(t), n = Xe(e, 0, this._rules.length - 1); return this._rules.splice(i.index, 1), this._rules.splice(n, 0, i), this._updatePriorities(), this._dom.afterNextFrame() }, ip.prototype.updateRule = function (t, e) { var i = this._get(t), n = Object.assign({ fullOverwrite: e.fullOverwrite }, np(e)); return i.attributeLayer.update(n), this._dom.afterNextFrame() }, ip.prototype.getRuleDefinition = function (t) { return np(this._get(t).attributeLayer.getDefinition()) }, ip.prototype.destroyRule = function (t) { var e = this._get(t); return e.attributeLayer.destroy(), this._rules.splice(e.index, 1), this._dom.afterNextFrame() }, ip.prototype.refreshRule = function (t) { return this._get(t).attributeLayer.updateAll(), this._dom.afterNextFrame() }, ip.prototype.refreshAllRules = function () { for (var t = 0; t < this._rules.length; t++)this._rules[t].attributeLayer.updateAll(); return this._dom.afterNextFrame() }, ip.prototype.getRuleList = function () { return this._rules.map(function (t) { return t.wrapper }) }, ip); function ip(t) { var e = tp.call(this) || this; return e._idCounter = 1, e._rules = [], e._graphics = t.graphics, e._dom = t.dom, e._rules = [], e } function np(t) { return { nodeAttributes: t.nodeAttributes, edgeAttributes: t.edgeAttributes, nodeSelector: t.nodeSelector, edgeSelector: t.edgeSelector, nodeDependencies: t.nodeDependencies, edgeDependencies: t.edgeDependencies, nodeOutput: t.nodeOutput, edgeOutput: t.edgeOutput } } var rp, op = { strokeColor: "#00C3FF", fillColor: "rgba(0,195,255,0.1)", strokeWidth: 1, cursorStyle: "cell", callback: function (t) { return t.nodes.setSelected(!0) }, bothExtremities: !1 }, sp = (b(ap, rp = Ae), ap.prototype.enable = function (t) { if (!this._enabled) return this._enabled = !0, this._captor.setDetectionEnabled(!1), this._options = Q(t, op), this._graphics.addCanvas(this._canvas), Vt(this._canvas, this._options.cursorStyle), this._captor.isLeftPressed() && this._interaction.start(this._captor.getCursorPosition()), this }, ap.prototype.disable = function () { if (this._enabled) return this._enabled = !1, this._captor.setDetectionEnabled(!0), this._graphics.removeCanvas(this._canvas), this }, ap.prototype.enabled = function () { return this._enabled }, ap.prototype.savePoint = function (t, e, i) { var n = wt(), r = this._ctx, o = this._options, s = this._points; if (this._bbox.addPoint(t, e), r.clearRect(0, 0, this._canvas.width, this._canvas.height), s.push({ x: t, y: e }), i) { var a = s[0]; r.lineWidth = o.strokeWidth, r.lineJoin = "bevel", r.strokeStyle = o.strokeColor, r.fillStyle = o.fillColor, r.beginPath(), r.moveTo(a.x * n, a.y * n); for (var u = 1; u < s.length; ++u) { var l = s[u]; r.lineTo(l.x * n, l.y * n) } r.stroke(), o.fillColor && r.fill() } }, ap.prototype.filterByExtremities = function (t, r) { var o = this._graph.getEdgeAttribute("source"), s = this._graph.getEdgeAttribute("target"); return t.filter(function (t) { var e = t._index, i = o.get(e), n = s.get(e); return r[i] && r[n] }) }, ap); function ap(t) { var e = t.locate, i = t.graphics, n = t.captor, r = t.graph, o = t.spatial, s = t.interactions, h = rp.call(this) || this; return h._enabled = !1, h._points = [], h._bbox = new Uo, h._onStart = function (t) { var e = t.x, i = t.y; h._bbox.reset(), h.savePoint(e, i, !1) }, h._onStop = function () { var t = h._bbox, e = t.minX, i = t.minY, n = t.maxX, r = t.maxY, o = h._spatial.queryProjected(e, i, n, r), s = o.nodes, a = o.edges, u = {}, l = s.filter(function (t) { var e = t.isVisible(), i = t.getAttribute("detectable"), n = e && i && h._locate.isNodeInPolygon(t, h._points); return u[t._index] = n }), d = a.filter(function (t) { var e = t.isVisible(), i = t.getAttribute("detectable"); return e && i && h._locate.isEdgeInPolygon(t, h._points) }); h._options.bothExtremities && (d = h.filterByExtremities(d, u)), h._ctx.clearRect(0, 0, h._canvas.width, h._canvas.height), h._points = [], h.disable(), h._options.callback({ nodes: l, edges: d }) }, h._locate = e, h._graph = r, h._graphics = i, h._captor = n, h._interactions = s, h._spatial = o, h._options = j(op), h._canvas = nr(), h._ctx = h._canvas.getContext("2d"), h._interaction = h._interactions.onDrag({ priority: "lasso", check: function () { return h._enabled }, onStart: h._onStart, onProgress: function (t) { var e = t.x, i = t.y; return h.savePoint(e, i, !0) }, onStop: h._onStop }), h } var up, lp = { strokeColor: "#00C3FF", fillColor: "rgba(0,195,255,0.1)", strokeWidth: 1, cursorStyle: "cell", callback: function (t) { var e = t.nodes, i = t.edges; e.size ? e.setSelected(!0) : i.setSelected(!0) }, bothExtremities: !1 }, dp = (b(hp, up = sp), hp.prototype.enable = function (t) { this._enabled || (this._enabled = !0, this._options = Q(t, lp), this._graphics.addCanvas(this._canvas), Vt(this._canvas, this._options.cursorStyle), this._captor.isLeftPressed() && this._interaction.start(this._captor.getCursorPosition())) }, hp.prototype.disable = function () { if (this._enabled) return this._enabled = !1, this._graphics.removeCanvas(this._canvas), this }, hp.prototype.enabled = function () { return this._enabled }, hp.prototype._formatRectangle = function (t) { var e = this._start.x, i = this._start.y, n = t.x, r = t.y, o = Math.abs(e - n), s = Math.abs(i - r), a = e < n ? e : n, u = i < r ? i : r; return this._rectangle.reset().addPoint(a, u).addPoint(a + o, u + s) }, hp.prototype._refreshRectangle = function (t) { var e = this._formatRectangle(t), i = e.minX, n = e.minY, r = e.width, o = e.height, s = wt(); rr(this._canvas, this._ctx), this._ctx.strokeRect(i * s, n * s, r * s, o * s), this._options.fillColor && this._ctx.fillRect(i * s, n * s, r * s, o * s) }, hp); function hp(t) { var u = up.call(this, t) || this; return u._options = j(lp), u._canvas = nr(), u._ctx = u._canvas.getContext("2d"), u._enabled = !1, u._start = null, u._rectangle = new Uo, u._interaction = u._interactions.onDrag({ priority: "lasso", disableDetection: !0, check: function () { return u._enabled }, onStart: function (t) { var e = t.x, i = t.y; u._rectangle.reset(), u._start = { x: e, y: i }, u._ctx.fillStyle = u._options.fillColor, u._ctx.strokeStyle = u._options.strokeColor, u._ctx.lineWidth = u._options.strokeWidth }, onProgress: function (t) { var e = t.x, i = t.y; return u._refreshRectangle({ x: e, y: i }) }, onStop: function () { var t = u._captor.getCursorPosition(), r = u._formatRectangle(t), e = u._spatial.queryProjected(r.minX, r.minY, r.maxX, r.maxY), i = e.nodes, n = e.edges, o = {}, s = i.filter(function (t) { var e = t.isVisible(), i = t.getAttribute("detectable"), n = e && i && u._locate.isNodeInRectangle(t, r); return o[t._index] = n }), a = n.filter(function (t) { var e = t.isVisible(), i = t.getAttribute("detectable"); return e && i && u._locate.isEdgeInRectangle(t, r) }); u._options.bothExtremities && (a = u.filterByExtremities(a, o)), rr(u._canvas, u._ctx), u.disable(), u._options.callback({ nodes: s, edges: a }) } }), u } function cp(t, e, i, n, r, o, s, a) { void 0 === r && (r = 0), void 0 === o && (o = Math.sin(r)), void 0 === s && (s = Math.cos(r)), void 0 === a && (a = [0, 0, 0, 0]); var u, l, d, h, c, f, g, p, _ = i / 2, v = n / 2, m = t + _, y = e + v; return 0 === r ? (a[0] = t, a[1] = e, a[2] = t + i, a[3] = e + n) : (c = g = u = m + (d = -_) * s - (h = -v) * o, f = p = l = y + d * o + h * s, (u = m + (d = -_) * s - (h = v) * o) < c ? c = u : g < u && (g = u), (l = y + d * o + h * s) < f ? f = l : p < l && (p = l), (u = m + (d = _) * s - (h = v) * o) < c ? c = u : g < u && (g = u), (l = y + d * o + h * s) < f ? f = l : p < l && (p = l), (u = m + (d = _) * s - (h = -v) * o) < c ? c = u : g < u && (g = u), (l = y + d * o + h * s) < f ? f = l : p < l && (p = l), a[0] = c, a[1] = f, a[2] = g, a[3] = p), a } function fp(t, e, i, n, r) { void 0 === r && (r = 0); var o = i / 2, s = n / 2, a = t + o, u = e + s; if (0 === r) return [{ x: t, y: e }, { x: t + i, y: e }, { x: t + i, y: e + n }, { x: t, y: e + n }]; var l, d, h = Math.sin(r), c = Math.cos(r); return [{ x: a + (l = -o) * c - (d = -s) * h, y: u + l * h + d * c }, { x: a + (l = -o) * c - (d = s) * h, y: u + l * h + d * c }, { x: a + (l = o) * c - (d = s) * h, y: u + l * h + d * c }, { x: a + (l = o) * c - (d = -s) * h, y: u + l * h + d * c }] } function gp(t, e, i, n) { void 0 === e && (e = 0), void 0 === i && (i = 1), void 0 === n && (n = ua.slice()); var r = i * Math.sin(e), o = i * Math.cos(e); return n[0] = t[0] + r, n[1] = t[1] + o, n[2] = t[2] + r, n[3] = t[3] + o, n } function pp(t, e, i, n, r, o, s, a) { return r < t && t < s && o < e && e < a || r < i && i < s && o < n && n < a } function _p(t, e, i, n, r, o, s, a) { return o <= n && e <= a && r <= i && t <= s } function vp(t, e, i, n, r, o) { return { minX: t, minY: e, maxX: i, maxY: n, leaf: !0, level: o, parent: r, objects: [], final: !1, children: null } } function mp(t) { return [t.minX, t.minY, t.maxX, t.maxY] } function yp(t, e, i, n, r, o, s, a) { var u = (t + i) / 2, l = (e + n) / 2; return r <= u && u <= s && o <= l && l <= a } var bp = 0, xp = 1, Ep = 2, Ap = 3; function Sp(t, e, i, n, r, o, s, a) { var u = (o + a) / 2, l = (e + n) / 2; return (t + i) / 2 <= (r + s) / 2 ? l <= u ? bp : xp : l <= u ? Ap : Ep } function wp(t) { return t } var Tp = (Object.defineProperty(Cp.prototype, "size", { get: function () { return this._size }, enumerable: !0, configurable: !0 }), Object.defineProperty(Cp.prototype, "root", { get: function () { return this._root }, enumerable: !0, configurable: !0 }), Cp.prototype.clear = function () { return this._root = null, this._objects = {}, this._size = 0, this._idToCell = {}, this._rootLevel = 0, this._maxLevel = this._rootLevel + 30, this }, Cp.prototype.insert = function (t, e, i) { if (void 0 === i && (i = this._root), e = e || this._getBBox(t), !this._objects[t]) { if (this._objects[t] = !0, this._size++ , !this._root) { var n = Math.max(Math.abs(e[2] - e[0]), Math.abs(e[3] - e[1])); return this._root = vp(e[0], e[1], e[0] + n, e[1] + n, null, this._rootLevel), this._root.objects.push(t), t } for (var r, o = [i], s = !1, a = this._nodeCapacity, u = this._idToCell, l = this._maxLevel; r = o.pop();) { var d = r.minX, h = r.minY, c = r.maxX, f = r.maxY; _p(e[0], e[1], e[2], e[3], d, h, c, f) && (r.leaf ? r.objects.length < a || r.final ? (r.objects.push(t), u[t] ? u[t].push(r) : u[t] = [r], s = !0, (r.level >= l || Math.abs(c - d) <= Math.abs(e[2] - e[0]) || Math.abs(f - h) <= Math.abs(e[3] - e[1])) && (r.final = !0)) : (this.splitNode(r), o.push(r)) : o.push.apply(o, r.children)) } if (s) return t; if (i = this._root, !yp(e[0], e[1], e[2], e[3], i.minX, i.minY, i.maxX, i.maxY)) { for (var g = this._rootLevel, p = (e[0] + e[2]) / 2, _ = (e[1] + e[3]) / 2; !yp(e[0], e[1], e[2], e[3], this._root.minX, this._root.minY, this._root.maxX, this._root.maxY);) { var v = d = (i = this._root).minX, m = h = i.minY, y = c = i.maxX, b = f = i.maxY, x = Math.abs(c - d), E = Math.abs(f - h); if (0 === E && 0 === x) break; var A = Math.max(x, E); p <= d && (v -= A), _ <= h && (m -= A), d < p && (y += A), h < _ && (b += A); var S = vp(v, m, y, b, null, --g); this.splitNode(S), S.children[Sp(d, h, c, f, v, m, y, b)] = i, this._root = i.parent = S } for (o = [this._root], this._root.level = this._rootLevel; r = o.shift();)if (!r.leaf) for (var w = 0; w < 4; w++) { var T = r.children[w]; T.level = r.level + 1, o.push(T) } } return (r = (i = this._root).children[Sp(e[0], e[1], e[2], e[3], i.minX, i.minY, i.maxX, i.maxY)]).leaf && (r.objects.push(t), u[t] ? u[t].push(r) : u[t] = [r]), t } }, Cp.prototype.removeById = function (t) { if (!this._objects[t]) return t; this._size--; for (var e = this._idToCell[t], i = 0; i < e.length; i++)for (var n = e[i].objects, r = 0, o = n.length; r < o; r++)if (n[r] === t) { n.splice(r, 1); break } return delete this._objects[t], delete this._idToCell[t], t }, Cp.prototype.remove = function (t) { for (var e, i, n, r = this._getBBox(t), o = r[0], s = r[1], a = r[2], u = r[3], l = [this._root]; e = l.pop();)if (_p(o, s, a, u, e.minX, e.minY, e.maxX, e.maxY)) if (e.leaf) { for (var d = e.objects, h = 0, c = d.length; h < c; h++)if (d[h] === t) { d.splice(h, 1), 1 === c && (n = n || []).push(e); break } } else l.push.apply(l, e.children); if (delete this._idToCell[t], delete this._objects[t], this._size-- , n) for (; i = n.pop();)for (var f = i.parent, g = !0; f && g;) { if (!f.leaf) { for (h = 0; h < 4; h++)if (!(e = f.children[h]).leaf || 0 !== e.objects.length) { g = !1; break } g && (f.leaf = !0, f.children = null, f.objects = []) } f = f.parent } return t }, Cp.prototype.splitNode = function (t) { var e = t.minX, i = t.minY, n = t.maxX, r = t.maxY, o = (e + n) / 2, s = (i + r) / 2, a = t.level + 1, u = this._idToCell, l = this._maxLevel, d = [vp(e, i, o, s, t, a), vp(e, s, o, r, t, a), vp(o, s, n, r, t, a), vp(o, i, n, s, t, a)]; if (null !== t.objects) for (var h = t.objects, c = this._getBBox, f = 0, g = h.length; f < g; f++) { for (var p = h[f], _ = c(p), v = u[p], m = 0; m < 4; m++) { var y = d[m], b = y.minX, x = y.minY, E = y.maxX, A = y.maxY; _p(_[0], _[1], _[2], _[3], b, x, E, A) && (y.objects.push(p), (y.level >= l || Math.abs(E - b) <= Math.abs(_[2] - _[0]) || Math.abs(A - x) <= Math.abs(_[3] - _[1])) && (y.final = !0), v ? v.push(y) : v = [y]) } v.splice(v.indexOf(t), 1) } t.children = d, t.objects = null, t.leaf = !1 }, Cp.prototype.point = function (t, e, i) { for (var n, r, o, s = [], a = [this._root], u = this._getBBox; n = a.pop();)if (t >= n.minX && t <= n.maxX && e >= n.minY && e <= n.maxY) { if (n.leaf) { i && (s = n.objects); for (var l = n.objects, d = 0, h = l.length; d < h; d++)t >= (r = u(o = l[d]))[0] && t <= r[2] && e >= r[1] && e <= r[3] && s.push(o); break } a.push.apply(a, n.children) } return s }, Cp.prototype.neigbours = function (t, e) { for (var i, n = [], r = [this._root]; i = r.pop();)if (t >= i.minX && t <= i.maxX && e >= i.minY && e <= i.maxY) { if (i.leaf) { n = i.objects; break } r.push.apply(r, i.children) } return n }, Cp.prototype.query = function (t, e, i, n) { for (var r, o, s, a = [], u = [this._root], l = this._getBBox, d = {}; r = u.pop();)if (_p(t, e, i, n, r.minX, r.minY, r.maxX, r.maxY)) if (r.leaf) for (var h = r.objects, c = 0, f = h.length; c < f; c++)d[s = h[c]] || (_p(t, e, i, n, (o = l(s))[0], o[1], o[2], o[3]) && a.push(s), d[s] = !0); else u.push.apply(u, r.children); return a }, Cp.prototype.getOverlaps = function () { for (var t, e, i, n = [this._root], r = [], o = this._getBBox, s = {}; t = n.pop();)if (t.leaf) { for (var a = t.objects, u = a.length, l = 0; l < u; l++)for (var d = 0; d < u; d++)if (e = a[l], i = a[d], l !== d && !s[e + ":" + i] && !s[i + ":" + e]) { s[e + ":" + i] = !0; var h = o(e), c = o(i); _p(h[0], h[1], h[2], h[3], c[0], c[1], c[2], c[3]) && r.push(e, i) } } else n.push.apply(n, t.children); return r }, Cp.prototype.getAll = function () { return Object.keys(this._objects).map(function (t) { return Number(t) }) }, Cp.prototype.forEach = function (t, e) { for (var i, n = [this._root]; i = n.pop();)if (i.leaf) for (var r = 0, o = i.objects.length; r < o; r++)t.call(e, i.objects[r]); else n.push.apply(n, i.children); return this }, Cp.prototype.getLeafs = function () { for (var t, e = [this._root], i = []; t = e.pop();)t.leaf ? i.push(t) : e.push.apply(e, t.children); return i }, Cp.prototype.traverse = function (t, e) { for (var i, n = [this._root]; i = n.pop();)t.call(e, i, i.objects) || i.leaf || n.push.apply(n, i.children); return this }, Cp.prototype.update = function (t) { return this.remove(t), this.insert(t, this._getBBox(t)), this }, Cp.prototype.getNodeBounds = function (t) { return mp(t) }, Cp.flatAccessor = function (i, n) { return function (t) { var e = n * t; return i.slice(e, e + n) } }, Cp.inside = yp, Cp.intersects = pp, Cp.overlaps = _p, Cp.getNodeBBox = mp, Cp); function Cp(t, e, i, n) { void 0 === t && (t = wp), void 0 === e && (e = 10), void 0 === n && (n = 0), this._nodeCapacity = 10, this._root = null, this._objects = {}, this._size = 0, this._rootLevel = 0, this._maxLevel = 30, this._idToCell = {}, this._nodeCapacity = e, this._root = null, this._getBBox = t, this._rootLevel = n, this._maxLevel = n + 30, this._idToCell = {}, i && (this._root = vp(i[0], i[1], i[2], i[3], null, n)) } var Mp = { left: -1, right: 1, top: 0, bottom: 0, center: 0 }, Ip = { left: 0, right: 0, top: -1, bottom: 1, center: 0 }, Lp = { left: -1, right: 0, top: -.5, bottom: -.5, center: -.5 }, Np = { left: -.5, right: -.5, top: -1, bottom: 0, center: -.5 }; var kp = { x1: 0, y1: 0, x2: 0, y2: 0 }, Op = { x: 0, y: 0 }, Fp = { x: 0, y: 0 }, Rp = Math.PI / 2; function Pp(t, e, i, n) { void 0 === n && (n = "#ff0000"), e.strokeStyle = n, e.lineWidth = 1, e.beginPath(); for (var r = wt(), o = 0, s = t.length; o < s; o++) { var a = i.graphToScreenCoordinates(t[o]); 0 === o ? e.moveTo(a.x * r, a.y * r) : e.lineTo(a.x * r, a.y * r) } e.closePath(), e.stroke() } function Dp(e, t, i, n, r, o) { e.clearRect(0, 0, t.width, t.height); for (var s = 0, a = n.length; s < a; s += 6)u = n.slice(s, s + 4), l = e, d = i, void 0 === (h = "#aaaaaa") && (h = "#22ff00"), Pp([[u[0], u[1]], [u[2], u[1]], [u[2], u[3]], [u[0], u[3]]].map(function (t) { return { x: t[0], y: t[1] } }), l, d, h); var u, l, d, h; for (s = 0; s < r.length; s += 5) { Pp(fp(r[s], r[s + 1], r[s + 2], r[s + 3], r[s + 4]), e, i, "green") } o.forEach(function (t) { return Pp(t, e, i, "red") }) } var zp, Bp = ["x", "y", "radius", "width", "text.content", "text.minVisibleSize", "text.size", "text.scale", "text.scaling", "text.padding", "text.margin", "text.position", "text.style"], Up = (b(Vp, zp = Ae), Vp.prototype.getTextsBoundingBox = function () { this._updateLabels(); for (var t = this._rects, e = this._textBBoxes, i = new Uo, n = this._graphics.getNodeAttributes(), r = this._graphics.getEdgeAttributes(), o = n.excluded, s = r.excluded, a = 0; a < t.length; a++) { var u = 5 * a, l = 1 === e[6 * a + 4], d = e[6 * a + 4]; if (!(l ? o.get(d) : s.get(d))) { var h = cp(t[u], t[1 + u], t[2 + u], t[3 + u], t[4 + u]), c = h[0], f = h[1], g = h[2], p = h[3]; i.addPoint(c, f).addPoint(g, p) } } return i }, Vp.prototype.setRate = function (t) { var e = this; this._updateDebounced = this._sync.debounceIdle(function (t) { return e._updateLabels(t) }, t) }, Vp.prototype.forceEnable = function () { this._forceEnabled = !0 }, Vp.prototype.update = function () { this._update() }, Vp.prototype.forceUpdate = function () { this._updateLabels() }, Vp.prototype._enable = function () { this._enabled = !0, this._update() }, Vp.prototype._disable = function () { this._textBBoxes = [], this._rects = [], this._intersects = [], this._enabled = !1 }, Vp.prototype._onCameraMove = function () { this._update() }, Vp.prototype._updateLabels = function (t) { if (void 0 === t && (t = this._camera.getZoom()), this._settings.get("texts.preventOverlap")) { var e = this._graphics.getNodeAttributes(), i = this._graphics.getEdgeAttributes(); this._intersects = [], this._textBBoxes = [], this._rects = []; var n = this._textQuad.clear(), r = this._camera.getAngle(), o = this._camera.getProjectedScreenBounds(.25), s = "bottomUp" === this._settings.get("texts.removalStrategy"), a = { angle: r, zoom: t, screen: o, sin: Math.sin(r), cos: Math.cos(r) }, u = { remove: { nodes: [], edges: [] }, redraw: { nodes: [], edges: [] }, rects: this._rects, bboxes: this._textBBoxes, intersects: this._intersects }, l = this._spatial.queryRaw(o[0], o[1], o[2], o[3]), d = l.nodes, h = l.edges; d.length + h.length !== 0 && (function (t, e, i, n, r, o, s) { var a, u, l = s.remove.nodes, d = s.remove.edges, h = s.redraw.nodes, c = i.angle, f = i.zoom, g = i.sin, p = i.cos, _ = n.x, v = n.y, m = n.radius, y = n.layer, b = n.innerStroke.width, x = n.outerStroke.width, E = n.scalingMethod, A = n.text.content, S = n.text.position, w = n.text.size, T = n.text.font, C = n.text.style, M = n.text.maxLineLength, I = n.text.scaling, L = n.text.scale, N = n.text.minVisibleSize, k = n.text.padding, O = n.text.margin, F = n.animationDuration, R = n.textHidden, P = n.excluded; At(t, y); for (var D = [0, 0, 0, 0], z = [0, 0, 0, 0, 0], B = s.bboxes, U = s.rects, V = s.intersects, j = 0, G = t.length; j < G; j++) { a = t[j]; var H = F.get(a), q = A.get(a); if (null !== q && "" !== q && 0 === H) { var W = m.get(a), X = N.get(a); if (1 !== P.get(a)) if (2 * W * f < X) 0 === R.get(a) && l.push(a); else { "fixed" === E.get(a) && (W /= f); var Y = _.get(a), Z = v.get(a); "number" == typeof q && (q = q.toString()); var K = !I.get(a), Q = S.get(a), J = k.get(a), $ = L.get(a), tt = 1 * (K ? w.get(a) : $ * W), et = C.get(a), it = T.get(a), nt = is(q, M.get(a)).lines, rt = J + b.get(a) + x.get(a) + O.get(a), ot = Mp[Q], st = Ip[Q], at = r(q, it, et, tt).width / nt, ut = nt * tt * 1, lt = at / 2 / f, dt = ut / 2 / f, ht = rt / f, ct = Lp[Q] * at, ft = Np[Q] * ut; K && (ct /= f, ft /= f), ct = ct + ot * ht + lt + ot * W, ft = ft + st * ht + dt + st * W, cp(Y - lt, Z - dt, at / f, ut / f, -c, g, -p, D), z[0] = Y - lt, z[1] = Z - dt, z[2] = at / f, z[3] = ut / f, z[4] = c; var gt = p * ct - g * ft, pt = g * ct + p * ft; D[0] += gt, D[1] += pt, D[2] += gt, D[3] += pt, z[0] += gt, z[1] += pt; var _t = e.query(D[0], D[1], D[2], D[3]); if (0 !== _t.length) { for (var vt = !1, mt = fp(z[0], z[1], z[2], z[3], z[4]), yt = 0; yt < _t.length; yt++) { var bt = _t[yt], xt = 5 * bt, Et = fp(U[xt], U[1 + xt], U[2 + xt], U[3 + xt], U[4 + xt]); if (qd(mt, Et)) { if (V.push(mt, Et), vt = !0, !o) break; e.remove(bt), 1 === B[6 * bt + 4] ? l.push(B[6 * bt + 5]) : d.push(B[6 * bt + 5]) } } if (vt && !o) { l.push(a); continue } } h.push(a), u = B.length / 6, B.push(D[0], D[1], D[2], D[3], 1, a), e.insert(u, D), U.push(z[0], z[1], z[2], z[3], z[4]) } else l.push(a) } } }(d, n, a, e, this._measureText, s, u), function (t, e, i, n, r, o, s, a) { var u, l, d = a.remove.nodes, h = a.remove.edges, c = a.redraw.edges, f = i.angle, g = i.zoom, p = r.x, _ = r.y, v = r.radius, m = Math.PI, y = n.source, b = n.target, x = n.scalingMethod, E = n.width, A = n.curvature, S = n.layer, w = n.text.content, T = n.text.scaling, C = n.text.size, M = n.text.font, I = n.text.style, L = n.text.scale, N = n.text.maxLineLength, k = n.text.margin, O = n.text.minVisibleSize, F = n.animationDuration; At(t, S); for (var R = [0, 0, 0, 0], P = [0, 0, 0, 0, 0], D = a.bboxes, z = a.rects, B = a.intersects, U = 0, V = t.length; U < V; U++) { u = t[U]; var j = F.get(u), G = w.get(u); if (null !== G && "" !== G && !j) { var H = y.get(u), q = b.get(u), W = E.get(u), X = A.get(u); if (!(W * g < O.get(u))) { "fixed" === x.get(u) && (W /= g); var Y = (p.get(H) + p.get(q)) / 2, Z = (_.get(H) + _.get(q)) / 2; G = G.toString(); var K = !T.get(u), Q = L.get(u), J = M.get(u), $ = 1 * (K ? C.get(u) : Q * W), tt = I.get(u), et = N.get(u), it = k.get(u), nt = p.get(H), rt = _.get(H), ot = p.get(q), st = _.get(q), at = void 0, ut = H === q; if (ut) at = m / 4 - f, ta(nt, rt, X, v.get(H), 0, kp), fu(.5, nt, rt, ot, st, kp.x1, kp.y1, kp.x2, kp.y2, Fp), Y = Fp.x, Z = Fp.y, it /= -g; else { if (nt === ot && rt === st) continue; at = Ka(nt, rt, ot, st) - f, 0 !== X && (at = Ka(nt, rt, ot, st) - f, $s(nt, rt, ot, st, X, Op), hu(.5, nt, rt, ot, st, Op.x, Op.y, Fp), Y = Fp.x, Z = Fp.y) } var lt = it + 4, dt = is(G, et).lines, ht = dt * $, ct = 1 * o(G, J, tt, $).width / dt / g / 2, ft = ht / g / 2, gt = Math.abs(at) < Rp ? 1 : -1, pt = ut ? ht / g + W / 2 : gt * (lt / g + W / 2 + ft); P[0] = Y - ct, P[1] = Z - ft, P[2] = Y + ct, P[3] = Z + ft, P[4] = at + f, gp(P, -(at + f), -pt, P), P[2] = P[2] - P[0], P[3] = P[3] - P[1], cp(Y - ct, Z - ft, 2 * ct, 2 * ft, at = m - at - f, void 0, void 0, R), gp(R, at, pt, R); var _t = e.query(R[0], R[1], R[2], R[3]); if (_t.length) { for (var vt = !1, mt = fp(P[0], P[1], P[2], P[3], P[4]), yt = 0; yt < _t.length; yt++) { var bt = _t[yt], xt = 5 * bt, Et = fp(z[xt], z[1 + xt], z[2 + xt], z[3 + xt], z[4 + xt]); if (qd(mt, Et)) { if (vt = !0, B.push(mt, Et), !s) break; e.remove(bt), 1 === D[6 * bt + 4] ? d.push(D[6 * bt + 5]) : h.push(D[6 * bt + 5]) } } if (vt && !s) { h.push(u); continue } } c.push(u), l = D.length / 6, D.push(R[0], R[1], R[2], R[3], 0, u), e.insert(l, R), z.push(P[0], P[1], P[2], P[3], P[4]) } } } }(h, n, a, i, e, this._measureText, s, u), this._clearOverlaps(u), this._settings.get("texts.debug") && this.drawAll()) } }, Vp.prototype._clearOverlaps = function (t) { var e = this._graph.nodeList, i = this._graph.edgeList, n = e(new Uint32Array(t.remove.nodes)), r = i(new Uint32Array(t.remove.edges)), o = e(new Uint32Array(t.redraw.nodes)), s = i(new Uint32Array(t.redraw.edges)); this._graphics.setTextHidden(n, !0), this._graphics.setTextHidden(r, !0), this._graphics.setTextHidden(o, !1), this._graphics.setTextHidden(s, !1), this._events.fire("labelCollisionsRemoved", t) }, Vp.prototype._reset = function () { this._graphics.resetTextHidden() }, Vp.prototype.drawAll = function () { Dp(this._ctx, this._canvas, this._camera, this._textBBoxes, this._rects, this._intersects) }, Vp); function Vp(t, e) { var i, n = t.graph, r = t.graphics, o = t.camera, s = t.events, a = t.settings, u = t.sync, l = t.spatial, d = zp.call(this) || this; return d._textBBoxes = [], d._rects = [], d._enabled = !1, d._intersects = [], d._onZoomStart = R(function (t) { var e = t.startZoom, i = t.endZoom; d._enabled && i < e && d._updateLabels(i) }, 80), d._onAttributesChanged = function (t) { t.edgeAttributes.concat(t.nodeAttributes).some(function (t) { return Bp.includes(t) }) && d._update() }, d._onItemsAdded = function (t) { var e = t.nodes || t.edges; (d._enabled || d._forceEnabled) && d._settings.get("texts.preventOverlap") && d._graphics.setTextHidden(e, !0) }, d._onToggle = function (t) { return t ? d._update() : d._reset(), d }, d._update = function () { (d._enabled || d._forceEnabled) && d._updateDebounced() }, d._toggleDebug = function (t) { t ? (d._canvas = nr(), d._graphics.addCanvas(d._canvas), d._ctx = d._canvas.getContext("2d"), d._update()) : d._canvas && (d._graphics.removeCanvas(d._canvas), d._canvas = d._ctx = null) }, d._measureText = function (t, e, i, n) { return d._engine.measureText(t, e, i, n) }, d._graph = n, d._graphics = r, d._camera = o, d._events = s, d._settings = a, d._sync = u, d._spatial = l, d._engine = r.getGraphicsEngine(), d._textQuad = new Tp(function (t) { var e = 6 * t; return d._textBBoxes.slice(e, 6 + e) }, 5), e.forceEnableTextOverlapRemoval && d.forceEnable(), d._events.register(["labelCollisionsRemoved"]), d.setRate(200), a.register("texts.preventOverlap", !0, d._onToggle), a.register("texts.debug", !1, d._toggleDebug), a.register("texts.removalStrategy", "topDown"), d._events.on(((i = {})[xe.ADD_NODES + " " + xe.ADD_EDGES] = d._onItemsAdded, i[xe.LAYOUT_END] = function () { return d._updateLabels() }, i[xe.VIEW_CHANGED] = d._update, i[xe.UPDATE_ATTRIBUTES] = d._onAttributesChanged, i[xe.SET_CONTAINER] = function (t) { if (t.element) return d._enable(); d._disable() }, i[xe.START_ZOOM] = d._onZoomStart, i)), d } function jp() { } function Gp() { return !1 } var Hp, qp, Wp = (Xp.prototype._startInteraction = function (t, e) { t.onStart(e), t.onStop && (this._current = t).disableDetection && this._captor.setDetectionEnabled(!1) }, Xp.prototype._stopCurrentInteraction = function (t) { this._current.disableDetection && this._captor.setDetectionEnabled(!0), this._current.onStop(t), this._current = null }, Xp.prototype._forceStartInteraction = function (t, e) { this._current && this._stopCurrentInteraction(e), this._startInteraction(t, e) }, Xp.prototype._createWrapper = function (e) { var i = this; return { start: function (t) { return i._forceStartInteraction(e, t) } } }, Xp.prototype._addInteraction = function (t, e) { var i = this._interactionsByStartEvent[t]; return i ? i.push(e) : (this._interactionsByStartEvent[t] = [e], this._events.on(t, this._onStartInteractionEvent)), this._createWrapper(e) }, Xp.prototype._createProgressiveInteraction = function (t, e, i, n) { var r = { priority: Yp(n.priority), check: n.check || Gp, onStart: n.onStart || jp, onProgress: n.onProgress || jp, onStop: n.onStop || jp, disableDetection: !!n.disableDetection, progressEventName: e, stopEventName: i }; return this._boundProgressEvents[e] || (this._boundProgressEvents[e] = !0, this._events.on(e, this._onProgressInteractionEvent)), this._boundStopEvents[i] || (this._boundStopEvents[i] = !0, this._events.on(i, this._onStopInteractionEvent)), this._addInteraction(t, r) }, Xp.prototype._createNonProgressiveInteraction = function (t, e) { return this._addInteraction(t, { priority: Yp(e.priority), check: e.check || Gp, onStart: e.handler || jp, onProgress: null, onStop: null, disableDetection: !1, progressEventName: null, stopEventName: null }) }, Xp.prototype.onDrag = function (t) { return this._createProgressiveInteraction(xe.DRAG_START, xe.DRAG_PROGRESS, xe.DRAG_END, t) }, Xp.prototype.onGesture = function (t) { return this._createProgressiveInteraction(xe.GESTURE_START, xe.GESTURE_PROGRESS, xe.GESTURE_END, t) }, Xp.prototype.onClick = function (t) { return this._createNonProgressiveInteraction(xe.CLICK, t) }, Xp.prototype.onDoubleClick = function (t) { return this._createNonProgressiveInteraction(xe.DOUBLE_CLICK, t) }, Xp.prototype.onHover = function (t) { return this._createNonProgressiveInteraction(xe.HOVER, t) }, Xp.prototype.onUnhover = function (t) { return this._createNonProgressiveInteraction(xe.UNHOVER, t) }, Xp.prototype.onMouseWheel = function (t) { return this._createNonProgressiveInteraction(xe.WHEEL, t) }, Xp.prototype.onMouseDown = function (t) { return this._createNonProgressiveInteraction(xe.DOWN, t) }, Xp.prototype.onMouseUp = function (t) { return this._createNonProgressiveInteraction(xe.UP, t) }, Xp.prototype.onMouseMove = function (t) { return this._createNonProgressiveInteraction(xe.MOVE, t) }, Xp); function Xp(t) { var e = t.captor, i = t.events, s = this; this._current = null, this._onStartInteractionEvent = function (t, e) { if (!s._current) { for (var i = null, n = 0, r = s._interactionsByStartEvent[e]; n < r.length; n++) { var o = r[n]; o.check(t) && (!i || o.priority >= i.priority) && (i = o) } i && s._startInteraction(i, t) } }, this._onProgressInteractionEvent = function (t, e) { s._current && s._current.progressEventName === e && s._current.onProgress(t) }, this._onStopInteractionEvent = function (t, e) { s._current && s._current.stopEventName === e && s._stopCurrentInteraction(null) }, this._captor = e, this._events = i, this._interactionsByStartEvent = {}, this._boundProgressEvents = {}, this._boundStopEvents = {} } function Yp(t) { return "string" == typeof t ? vl.indexOf(t) : "number" != typeof t || isNaN(t) ? 0 : t } (qp = Hp = Hp || {}).MOUSE = "mouse", qp.TOUCH = "touch"; var Zp, Kp = [xe.VIRTUAL_UP, xe.MOUSE_UP, xe.TOUCH_UP].join(" "), Qp = [xe.VIRTUAL_DOWN, xe.MOUSE_DOWN, xe.TOUCH_DOWN].join(" "), Jp = [xe.VIRTUAL_MOVE, xe.MOUSE_MOVE, xe.TOUCH_MOVE].join(" "), $p = [xe.VIRTUAL_CLICK, xe.MOUSE_CLICK, xe.TOUCH_TAP].join(" "), t_ = [xe.VIRTUAL_DOUBLE_CLICK, xe.MOUSE_DOUBLE_CLICK, xe.TOUCH_DOUBLE_TAP].join(" "), e_ = [xe.VIRTUAL_WHEEL, xe.MOUSE_WHEEL].join(" "), i_ = (b(n_, Zp = Ae), n_.prototype.triggerUnhover = function () { this._hover = !1, this._hoveredElt = null }, n_.prototype.triggerDetection = function () { this._detectElement(this._position.x, this._position.y), this._elt && (this._hoveredElt = this._elt, this._hover = !0) }, n_.prototype.getElementAt = function (t, e) { var i = t.x, n = t.y; return this._detectElementAt(i, n, e) }, n_.prototype.getPointedElement = function () { return this._hoveredElt }, n_.prototype.getDraggedElement = function () { return this._draggedElt }, n_.prototype.isAnyButtonPressed = function () { return this._buttons[gc.LEFT].isPressed || this._buttons[gc.RIGHT].isPressed || this._buttons[gc.MIDDLE].isPressed }, n_.prototype.isAnyButtonDragging = function () { return this._buttons[gc.LEFT].isDragging || this._buttons[gc.RIGHT].isDragging || this._buttons[gc.MIDDLE].isDragging }, n_.prototype.isButtonPressed = function (t) { return this._buttons[t].isPressed }, n_.prototype.isLeftPressed = function () { return this.isButtonPressed(gc.LEFT) }, n_.prototype.getCursorPosition = function () { return { x: this._position.x, y: this._position.y } }, n_.prototype.getCursorInformation = function () { return { x: this._position.x, y: this._position.y, target: this._hoveredElt } }, n_.prototype.setDetectionEnabled = function (value) { this._disabledCounter = Math.max(0, this._disabledCounter + (value ? -1 : 1)) }, n_.prototype._resetCurrent = function (t, e) { for (var i in this._buttons) { var n = this._buttons[i]; n.isDragging && this._events.fire(xe.DRAG_END, { domEvent: null, x: t, y: e, button: i, target: this._draggedElt }), n.isPressed = !1, n.isDragging = !1 } this._hover && this._hoveredElt && this._events.fire(xe.UNHOVER, { domEvent: null, x: t, y: e, target: this._hoveredElt }), this._hover = !1, this._hoveredElt = null, this._draggedElt = null }, n_.prototype._onMove = function (t) { var e = t.domEvent, i = t.x, n = t.y, r = t.source, o = this._setPointerPosition(i, n), s = o.dx, a = o.dy; for (var u in this._events.fire(xe.MOVE, { domEvent: e, x: i, y: n, dx: s, dy: a, source: r }), this._buttons) { var l = this._buttons[u]; if (l.isPressed) if (l.isDragging) { var d = this._getStoredDXY(); s += d.dx, a += d.dy, this._events.fire(xe.DRAG_PROGRESS, { domEvent: e, x: i, y: n, dx: s, dy: a, button: u, source: r, target: this._draggedElt }) } else l.isDragging = !0, this._hoveredElt && this._hover && (this._events.fire(xe.UNHOVER, { domEvent: e, x: i, y: n, source: r, target: this._hoveredElt }), this._hover = !1), this._draggedElt || (this._draggedElt = this._hoveredElt), this._storeDXY(s, a), this._events.fire(xe.DRAG_START, { domEvent: e, x: i, y: n, button: u, source: r, target: this._draggedElt }) } e && !this._graphics.getDomElement().contains(e.target) || this._detectElement(i, n), this._elt !== this._hoveredElt && (this._hoveredElt && this._hover && (this._hover = !0, this._events.fire(xe.UNHOVER, { domEvent: e, x: i, y: n, source: r, target: this._hoveredElt })), this._hoveredElt = this._elt, this._elt && (this._hover = !0, this._events.fire(xe.HOVER, { domEvent: e, x: i, y: n, source: r, target: this._hoveredElt }))) }, n_.prototype._onDocumentMove = function (t) { var e = t.domEvent, i = t.x, n = t.y, r = t.source; for (var o in this._buttons) if (this._buttons[o].isDragging) { var s = this._setPointerPosition(i, n), a = s.dx, u = s.dy; this._events.fire(xe.DRAG_PROGRESS, { domEvent: e, x: i, y: n, dx: a, dy: u, button: o, source: r, target: this._draggedElt }) } }, n_.prototype._onDocumentUp = function (t) { var e = t.domEvent, i = t.x, n = t.y, r = t.source, o = t.button; if (this._buttons[o].isDragging) { this._events.fire(xe.DRAG_END, { domEvent: e, x: i, y: n, button: o, source: r, target: this._draggedElt }); var s = this._buttons[o]; s.isDragging = !1, s.isPressed = !1, this.isAnyButtonDragging() || (this._draggedElt = null) } }, n_.prototype._onDown = function (t) { var e = t.domEvent, i = t.x, n = t.y, r = t.button, o = t.source; this._detectElement(i, n), this._elt !== this._hoveredElt && this._resetCurrent(i, n); var s = this._buttons[r]; this._hoveredElt = this._elt, s.isPressed = !0, this._events.fire(xe.DOWN, { domEvent: e, x: i, y: n, button: r, source: o, target: this._hoveredElt }) }, n_.prototype._onDoubleClick = function (t) { var e = t.domEvent, i = t.x, n = t.y, r = t.button, o = t.source; a_(e, "doubleclick") || this._events.fire(xe.DOUBLE_CLICK, { domEvent: e, x: i, y: n, button: r, source: o, target: this._hoveredElt }) }, n_.prototype._onUp = function (t) { var e = t.domEvent, i = t.x, n = t.y, r = t.button, o = t.source, s = this._buttons[r]; s.isPressed && (s.isDragging && (this._events.fire(xe.DRAG_END, { domEvent: e, x: i, y: n, button: r, source: o, target: this._draggedElt }), s.isDragging = !1, this.isAnyButtonDragging() || (this._draggedElt = null)), s.isPressed = !1, this._detectElement(i, n), this._events.fire(xe.UP, { domEvent: e, x: i, y: n, button: r, source: o, target: this._elt }), this.isAnyButtonPressed() || this._hover || o === Hp.TOUCH || (this._hoveredElt = this._elt, this._hoveredElt && (this._events.fire(xe.HOVER, { domEvent: e, x: i, y: n, source: o, target: this._hoveredElt }), this._hover = !0))) }, n_.prototype._onClick = function (t) { var e = t.domEvent, i = t.x, n = t.y, r = t.button, o = t.source; a_(e, "click") || this._events.fire(xe.CLICK, { domEvent: e, x: i, y: n, button: r, source: o, target: this._hoveredElt }) }, n_.prototype._onWheel = function (t) { var e = t.domEvent, i = t.x, n = t.y, r = t.delta, o = t.source; this._position.x = i, this._position.y = n, this._events.fire(xe.WHEEL, { domEvent: e, x: i, y: n, delta: r, source: o, target: this._hoveredElt }) }, n_.prototype._storeDXY = function (t, e) { this._accDx = t, this._accDy = e }, n_.prototype._getStoredDXY = function () { var t = this._accDx, e = this._accDy; return this._accDx = 0, this._accDy = 0, { dx: t, dy: e } }, n_.prototype._setPointerPosition = function (t, e) { var i = t - this._prevX, n = e - this._prevY; return this._position.x = t, this._position.y = e, this._prevX = t, this._prevY = e, this._accDx = 0, this._accDy = 0, { dx: i, dy: n } }, n_.prototype._detectElement = function (t, e, i) { this._elt = this._detectElementAt(t, e, i) }, n_.prototype._detectElementAt = function (t, e, i) { if (0 !== this._disabledCounter) return null; var n, r, o = this._settings, s = o.get("detect.enableSpatialIndex"), a = o.get("detect.nodeErrorMargin"), u = o.get("detect.edgeErrorMargin"), l = o.get("detect.nodes"), d = o.get("detect.edges"), h = null; if (!i && s && (l || d)) { var c = o.get("detect.spatialIndexMarginRatio"), f = Math.max(a * c, u * c), g = this._spatial.queryRawProjected(t - f, e - f, t + f, e + f); n = g.nodes, r = g.edges } return l && (h = this._graphics.detectNode({ x: t, y: e, indexes: n, margin: a, texts: o.get("detect.nodeTexts") })), !h && d && (h = this._graphics.detectEdge({ x: t, y: e, indexes: r, margin: u, texts: o.get("detect.edgeTexts") })), h }, n_); function n_(t) { var e, i, n = t.dom, r = t.events, o = t.graphics, s = t.spatial, a = t.settings, u = t.position, l = Zp.call(this) || this; return l._elt = null, l._hoveredElt = null, l._draggedElt = null, l._hover = !1, l._disabledCounter = 0, l._accDx = 0, l._accDy = 0, l._timeout = null, l._prevX = 0, l._prevY = 0, l._buttons = ((e = {})[gc.LEFT] = { isPressed: !1, isDragging: !1 }, e[gc.MIDDLE] = { isPressed: !1, isDragging: !1 }, e[gc.RIGHT] = { isPressed: !1, isDragging: !1 }, e), l._onGraphChanged = function () { l._resetCurrent(l._position.x, l._position.y), l._timeout || (l._timeout = l._dom.setTimeout(function () { l._onMove({ x: l._position.x, y: l._position.y, source: null, domEvent: null }), l._timeout = null }, 0)) }, l._dom = n, l._graphics = o, l._events = r, l._settings = a, l._spatial = s, l._position = u, r.register([xe.MOVE, xe.DOWN, xe.UP, xe.CLICK, xe.DOUBLE_CLICK, xe.HOVER, xe.UNHOVER, xe.WHEEL, xe.DRAG_START, xe.DRAG_PROGRESS, xe.DRAG_END, xe.GESTURE_START, xe.GESTURE_PROGRESS, xe.GESTURE_END]), a.register("detect.nodes", !0).register("detect.edges", !0).register("detect.nodeTexts", !0).register("detect.edgeTexts", !0).register("detect.nodeErrorMargin", 5).register("detect.edgeErrorMargin", 7).register("detect.enableSpatialIndex", !0).register("detect.spatialIndexMarginRatio", 3), r.on(((i = {})[[xe.REMOVE_NODES, xe.REMOVE_EDGES, xe.CLEAR_GRAPH].join(" ")] = l._onGraphChanged, i[Jp] = function (t, e) { var i = t.domEvent, n = t.x, r = t.y; l._onMove({ domEvent: i, x: n, y: r, source: r_(e) }) }, i[Qp] = function (t, e) { var i = t.domEvent, n = t.x, r = t.y, o = t.button, s = void 0 === o ? gc.LEFT : o; l._onDown({ domEvent: i, x: n, y: r, button: s, source: r_(e) }) }, i[Kp] = function (t, e) { var i = t.domEvent, n = t.x, r = t.y, o = t.button, s = void 0 === o ? gc.LEFT : o; l._onUp({ domEvent: i, x: n, y: r, button: s, source: r_(e) }) }, i[$p] = function (t, e) { var i = t.domEvent, n = t.x, r = t.y, o = t.button, s = void 0 === o ? gc.LEFT : o; l._onClick({ domEvent: i, x: n, y: r, button: s, source: r_(e) }) }, i[t_] = function (t, e) { var i = t.domEvent, n = t.x, r = t.y, o = t.button, s = void 0 === o ? gc.LEFT : o; l._onDoubleClick({ domEvent: i, x: n, y: r, button: s, source: r_(e) }) }, i[e_] = function (t) { var e = t.domEvent, i = t.x, n = t.y, r = t.delta; l._onWheel({ domEvent: e, x: i, y: n, delta: r, source: Hp.MOUSE }) }, i.touchStartGesture = function (t) { return r.fire(xe.GESTURE_START, t) }, i.touchProgressGesture = function (t) { return r.fire(xe.GESTURE_PROGRESS, t) }, i.touchEndGesture = function (t) { return r.fire(xe.GESTURE_END, t) }, i.documentMouseMove = function (t, e) { var i = t.domEvent, n = t.x, r = t.y; l._onDocumentMove({ domEvent: i, x: n, y: r, source: r_(e) }) }, i.documentMouseUp = function (t, e) { var i = t.domEvent, n = t.x, r = t.y, o = t.button, s = void 0 === o ? gc.LEFT : o; l._onDocumentUp({ domEvent: i, x: n, y: r, source: r_(e), button: s }) }, i)), l } function r_(t) { return 0 === t.indexOf(Hp.TOUCH) ? Hp.TOUCH : Hp.MOUSE } var o_ = !1, s_ = { down: { trigger: "pointerdown", duplicate: "mousedown" }, click: { trigger: "pointerdown", duplicate: "mouseup" }, doubleclick: { trigger: "pointerdown", duplicate: "mouseup" } }; function a_(t, e) { if (t) return t.type === s_[e].trigger && (o_ = !0), t.type === s_[e].duplicate && o_ ? !(o_ = !1) : void 0 } var u_, l_ = (b(d_, u_ = Ae), d_); function d_(t) { t.graph; var e = t.graphics, i = t.camera, n = t.selection, r = t.events, o = t.captor, s = t.individualAttributes, a = t.interactions, u = t.classes, l = t.settings, d = u_.call(this) || this; return d._dragged = null, d._start = null, d._end = null, d._startDrag = null, d._shouldDrag = function (t) { var e = t.target, i = t.button === gc.LEFT, n = d._settings.get("interactions.drag.enabled"), r = null !== e && e.isNode && !0 === e.getAttribute("draggable"); return i && n && r }, d._onDragStart = function (t) { var e = t.x, i = t.y, n = t.target; n.isSelected() ? d._dragged = d._selection.getSelectedNodes().filter(function (t) { return t.getAttribute("draggable") }) : d._dragged = n.toList(), d._start = d._dragged.getPosition(), d._end = j(d._start), d._onBeforeDrag = d._settings.get("interactions.drag.onBeforeDrag"), d._startDrag = d._camera.screenToGraphCoordinates({ x: e, y: i }), d._dragged.addClass(hl), d._events.fire(xe.NODES_DRAG_START, { nodes: d._dragged }), d._graphics.addCursorStyle(d._settings.get("interactions.drag.cursor")) }, d._onDrag = function () { for (var t = d._captor.getCursorInformation(), e = t.x, i = t.y, n = d._dragged._indexes, r = d._camera.screenToGraphCoordinates({ x: e, y: i }), o = r.x - d._startDrag.x, s = r.y - d._startDrag.y, a = 0; a < n.length; ++a) { var u = d._start[a], l = d._end[a]; l.x = u.x + o, l.y = u.y + s } d._onBeforeDrag && d._onBeforeDrag(d._dragged, e, i, d._end), d._settings.get("interactions.drag.applyResult") && d._attributes.setMultipleAttributes(d._dragged, d._end, null, ["x", "y"]), d._events.fire(xe.NODES_DRAG_PROGRESS, { nodes: d._dragged, dx: o, dy: s }) }, d._onDragEnd = function () { d._dragged.removeClass(hl), d._graphics.removeCursorStyle(d._settings.get("interactions.drag.cursor")), d._events.fire(xe.NODES_DRAG_END, { nodes: d._dragged, start: d._start, end: d._end }), d._dragged = null, d._start = null, d._end = null }, d._camera = i, d._graphics = e, d._selection = n, d._events = r, d._settings = l, d._captor = o, d._attributes = s, d._interactions = a, u.createClass({ name: hl, isBuiltin: !0, nodeAttributes: { layer: 3 } }), r.register([xe.NODES_DRAG_START, xe.NODES_DRAG_PROGRESS, xe.NODES_DRAG_END]), l.register("interactions.drag.enabled", !0), l.register("interactions.drag.cursor", "move"), l.register("interactions.drag.onBeforeDrag", null), l.register("interactions.drag.applyResult", !0), d._interactions.onDrag({ priority: "drag", disableDetection: !0, check: d._shouldDrag, onStart: d._onDragStart, onProgress: d._onDrag, onStop: d._onDragEnd }), d } function h_(t) { var e = t.graphWidth, i = t.graphHeight, n = t.viewWidth, r = t.viewHeight; return .2 * Math.min(n / e, r / i) } function c_(t) { var e = t.smallestNodeSize, i = t.viewWidth, n = t.viewHeight; return e === 1 / 0 ? 1 / 0 : Math.min(i, n) / e * .5 } var f_, g_; (g_ = f_ = f_ || {}).ROTATION = "rotation", g_.PAN = "pan", g_.ZOOM = "zoom", g_.GESTURE = "gesture"; var p_, __ = (b(v_, p_ = Ae), v_.prototype._setupInteractions = function () { var a = this; this._interactions.onMouseWheel({ priority: "zoom", check: function () { return a._settings.get("interactions.zoom.enabled") }, handler: R(function (t) { var e = t.x, i = t.y, n = t.delta; return a._smoothZoom(n, e, i) }, 50) }), this._interactions.onDoubleClick({ priority: "zoom", check: function () { var t = a._settings.get("interactions.zoom.enabled"), e = a._settings.get("interactions.zoom.onDoubleClick"); return t && e }, handler: function (t) { var e = t.x, i = t.y; return a._smoothZoom(1, e, i) } }), this._interactions.onDrag({ priority: "panning", disableDetection: !0, check: function (t) { var e = t.button, i = a._settings.get("interactions.pan.enabled"); return "left" === e && i }, onStart: function () { return a._updateVisibility(f_.PAN, !0) }, onProgress: function (t) { var e = t.dx, i = t.dy; return a._camera.move({ x: -e, y: -i }) }, onStop: function () { return a._updateVisibility(f_.PAN, !1) } }), this._interactions.onDrag({ priority: "rotation", disableDetection: !0, check: function (t) { var e = t.button, i = t.domEvent; return ("right" === e || i && 2 === i.buttons) && a._settings.get("interactions.rotation.enabled") }, onStart: function (t) { var e = t.x, i = t.y; a._rotationStart = { x: e, y: i }, a._updateVisibility(f_.ROTATION, !0) }, onProgress: function (t) { var e = t.x, i = t.y; return a._rotate({ x: e, y: i }) }, onStop: function () { return a._updateVisibility(f_.ROTATION, !1) } }), this._interactions.onGesture({ priority: "gesture", disableDetection: !0, check: function () { return a._settings.get("interactions.gesture.enabled") }, onStart: function () { return a._updateVisibility(f_.GESTURE, !0) }, onProgress: function (t) { var e = t.dx, i = t.dy, n = t.rotation, r = t.scale, o = t.x, s = t.y; a._settings.get("interactions.rotation.enabled") && a._camera.rotate(-n), a._camera.zoomIn(r, void 0, { refX: o, refY: s }), a._camera.move({ x: -e, y: -i }) }, onStop: function () { return a._updateVisibility(f_.GESTURE, !0) } }) }, v_.prototype._rotate = function (t) { var e = t.x, i = t.y, n = this._camera.getSize(), r = n.width / 2, o = n.height / 2, s = this._rotationStart.x - r, a = this._rotationStart.y - o, u = e - r, l = i - o, d = Math.atan2(a, s) - Math.atan2(l, u); this._rotationStart.x = e, this._rotationStart.y = i, this._camera.rotate(d) }, v_.prototype._updateVisibility = function (t, e) { var value = !e, i = this._settings, n = i.get("interactions." + t + ".hideNodes"), r = i.get("interactions." + t + ".hideEdges"), o = i.get("interactions." + t + ".hideNodeTexts"), s = i.get("interactions." + t + ".hideEdgeTexts"); n && this._graphics.setNodesVisibility(value), o && this._graphics.setNodeTextsVisibility(value), r && this._graphics.setEdgesVisibility(value), s && this._graphics.setEdgeTextsVisibility(value) }, v_.prototype._smoothZoom = function (t, e, i) { var n = this, r = this._settings, o = r.get("interactions.zoom.modifier"), s = r.get("interactions.zoom.duration"), a = r.get("interactions.zoom.easing"), u = this._camera.getZoom() * (0 < t ? o : 1 / o), l = { duration: s, easing: a }; this._zooming || (this._zooming = !0, this._updateVisibility(f_.ZOOM, !0)), this._camera.setZoom(u, l, { refX: e, refY: i }).then(function () { n._zooming && (n._zooming = !1, n._updateVisibility(f_.ZOOM, !1)) }) }, v_); function v_(t, e) { t.locate, t.dom; var i = t.camera, n = t.graphics, r = t.settings, o = t.interactions, s = p_.call(this) || this; return s._zooming = !1, s._camera = i, s._settings = r, s._interactions = o, s._graphics = n, r.register("interactions.zoom.enabled", !0), r.register("interactions.zoom.onDoubleClick", !1), r.register("interactions.zoom.duration", 150), r.register("interactions.zoom.modifier", 1.8), r.register("interactions.zoom.easing", "quadraticOut"), r.register("interactions.zoom.minValue", e ? null : h_), r.register("interactions.zoom.maxValue", e ? null : c_), r.register("interactions.zoom.hideNodes", !1), r.register("interactions.zoom.hideEdges", !1), r.register("interactions.zoom.hideNodeTexts", !1), r.register("interactions.zoom.hideEdgeTexts", !1), r.register("interactions.pan.enabled", !0), r.register("interactions.pan.hideNodes", !1), r.register("interactions.pan.hideEdges", !1), r.register("interactions.pan.hideNodeTexts", !1), r.register("interactions.pan.hideEdgeTexts", !1), r.register("interactions.rotation.enabled", !0), r.register("interactions.rotation.hideNodes", !1), r.register("interactions.rotation.hideEdges", !1), r.register("interactions.rotation.hideNodeTexts", !1), r.register("interactions.rotation.hideEdgeTexts", !1), r.register("interactions.gesture.enabled", !0), r.register("interactions.gesture.hideNodes", !1), r.register("interactions.gesture.hideEdges", !1), r.register("interactions.gesture.hideNodeTexts", !1), r.register("interactions.gesture.hideEdgeTexts", !1), s._setupInteractions(), s } var m_, y_ = { color: "#00C3FF", radius: 7, cursorOnHover: "grab", cursorOnDrag: "grabbing" }, b_ = (b(x_, m_ = Ae), x_.prototype.onMounted = function (t) { t.events.onEdgesSelected(this._refreshHandles), t.events.onEdgesUnselected(this._refreshHandles) }, x_.prototype.enable = function (t) { this._enabled || (this._options = C({}, y_, t), this._enabled = !0, this._graphics.addCanvas(this._canvas), this._refreshHandles()) }, x_.prototype.disable = function () { this._enabled && (this._interaction.stop(), this._graphics.removeCursorStyle(this._options.cursorOnDrag), this._disableCursorOnHover(), this._restoreSettings(), this._graphics.removeCanvas(this._canvas), this._rewirableClass.clearEdges(), this._enabled = !1) }, x_.prototype.enabled = function () { return this._enabled }, x_.prototype._restoreSettings = function () { this._prevSettings && (this._settings.update(this._prevSettings), this._prevSettings = null) }, x_.prototype._disableCursorOnHover = function () { this._hoverHandle && !this._grabHandle && (this._hoverHandle = !1, this._graphics.removeCursorStyle(this._options.cursorOnHover)) }, x_.prototype._enableCursorOnHover = function () { this._hoverHandle || (this._hoverHandle = !0, this._graphics.addCursorStyle(this._options.cursorOnHover)) }, x_.prototype._displayMovedEdges = function () { var d = this; if (this._movedEdges) { var t = this._x, e = this._y, h = this._ctx, c = wt(), f = { x: t, y: e }, g = this._camera.getZoom(); this._movedEdges.forEach(function (t, e) { var i = d._edgeColors[e], n = t.getSource(), r = t.getTarget(), o = d._getPointedNode(), s = r === d._startNode ? n : r, a = t.getAttribute("width") * g, u = s.getPositionOnScreen(), l = o ? o.getPositionOnScreen() : f; s.addClass(dl), h.beginPath(), h.moveTo(u.x * c, u.y * c), h.lineTo(l.x * c, l.y * c), h.strokeStyle = i, h.lineWidth = a * c, h.stroke() }) } }, x_.prototype._getPointedNode = function () { var t = this._captor.getPointedElement(); return t && t.isNode ? t : null }, x_); function x_(t) { var e = t.classes, i = t.graphics, n = t.camera, r = t.captor, o = t.selection, s = t.events, a = t.settings, u = t.interactions, c = m_.call(this) || this; return c._canvas = nr(), c._ctx = c._canvas.getContext("2d"), c._nodesToHighlight = null, c._movedEdges = null, c._startNode = null, c._hoverHandle = !1, c._grabHandle = !1, c._prevSettings = null, c._x = 0, c._y = 0, c._enabled = !1, c._onDragStart = function () { c._nodesToHighlight = c._nodesToHighlight.filter(function (t) { return t !== c._startNode }), c._movedEdges.setExcluded(!0); var t = c._options.cursorOnDrag; c._prevSettings = c._settings.update({ edgeHover: !1, cursor: { default: t, node: t, edge: t } }) }, c._onDragEnd = function () { c._restoreSettings(); var e = c._getPointedNode(); e && c._movedEdges.forEach(function (t) { t.getTarget() === c._startNode ? t.setTarget(e) : t.setSource(e) }), c._movedEdges.setExcluded(!1), c._movedEdges.setSelected(!0), c._movedEdges = null, c._refreshHandles() }, c._refreshHandles = function () { if (c._enabled && !c._movedEdges) { var t = c._selection.getSelectedEdges(); c._nodesToHighlight = t.getExtremities().dedupe(), c._rewirableClass.clearEdges(), c._rewirableClass.add(t), c._refreshCanvas() } }, c._shouldInteractionStart = function (t) { var e = t.target; if (!(c._enabled && e && e.isNode && c._hoverHandle)) return !1; var i = e.getAdjacentEdges().filter(function (t) { return t.isSelected() }); return !!i.size && (c._movedEdges = i, c._edgeColors = c._movedEdges.getAttribute("color"), c._startNode = e, !0) }, c._refreshCanvas = function () { if (c._enabled && c._nodesToHighlight) { var o = c._captor.getCursorPosition(), t = c._getPointedNode(), s = c._camera.zoom, a = c._canvas.getContext("2d"), u = wt(), e = c._options.color, l = c._options.radius, d = 2 * l * u; a.clearRect(0, 0, c._canvas.width, c._canvas.height), c._displayMovedEdges(), a.fillStyle = e, a.strokeStyle = e; var h = !1; if (c._nodesToHighlight.forEach(function (t) { var e = t.getPositionOnScreen(), i = e.x, n = e.y, r = t.getAttribute("radius") * ("fixed" === t.getAttribute("scalingMethod") ? 1 : s); l < r && (a.fillRect((i - l) * u, (n - l) * u, d, d), distance(i, n, o.x, o.y) < l && (h = !0)) }), c._movedEdges) { var i = t ? t.getPositionOnScreen() : o; a.fillRect((i.x - l) * u, (i.y - l) * u, d, d) } h ? c._enableCursorOnHover() : c._disableCursorOnHover() } }, c._captor = r, c._camera = n, c._graphics = i, c._selection = o, c._events = s, c._settings = a, c._interactions = u, c._classes = e, c._rewirableClass = c._classes.createClass({ name: cl, isBuiltin: !0, edgeAttributes: { layer: 4 } }), c._events.on({ cameraMove: c._refreshCanvas, move: c._refreshCanvas, progressMoveNodesByDragging: c._refreshCanvas, down: function () { c._hoverHandle && (c._grabHandle = !0) }, up: function () { c._grabHandle = !1 } }), c._interaction = c._interactions.onDrag({ priority: "rewiring", check: c._shouldInteractionStart, onStart: c._onDragStart, onProgress: function (t) { var e = t.x, i = t.y; c._x = e, c._y = i }, onStop: c._onDragEnd }), c } var E_, A_ = { cursor: "nesw-resize", color: "#00C3FF", lineWidth: 1, handleSize: 6, detectionMargin: 5, snappingRatio: 1.25, nbNodesToSnapTo: 5, previewColor: "rgba(0, 0, 0, 0.2)", sizeIndicatorColor: "black", sizeIndicatorOffset: 5, sizeIndicatorWidth: 3, sizeIndicatorThickness: 1 }, S_ = (b(w_, E_ = Ae), w_.prototype.onMounted = function (t) { t.events.onNodesSelected(this._onSelectionChange), t.events.onNodesUnselected(this._onSelectionChange) }, w_.prototype._enableCursor = function () { this._cursorEnabled || (this._graphics.addCursorStyle(this._options.cursor), this._cursorEnabled = !0) }, w_.prototype._disableCursor = function () { this._cursorEnabled && (this._graphics.removeCursorStyle(this._options.cursor), this._cursorEnabled = !1) }, w_.prototype._detectBoundingBoxes = function (a, u) { var l = this; if (this._enabled && !this._nodeBeingResized && this._nodesToHighlight) { var d = this._options.handleSize / 2, h = this._options.detectionMargin; return this._pointedNode = null, this._forEachNodeToHighlight(function (t, e, i) { var n = e.x + i - d - h, r = e.x + i + d + h, o = e.y - i - d - h, s = e.y - i + d + h; n <= a && a <= r && o <= u && u <= s && (l._pointedNode = t) }), this._pointedNode ? this._enableCursor() : this._disableCursor() } }, w_.prototype._forEachNodeToHighlight = function (n) { var r = this; this._nodesToHighlight.forEach(function (t) { var e = t.getPositionOnScreen(), i = r._getTotalOnScreenRadius(t); n(t, e, i) }) }, w_.prototype._displayHandles = function () { var d = this; if (this._enabled && this._nodesToHighlight) { var t = this._canvas, h = this._ctx, e = t.width, i = t.height, c = wt(), n = this._options, f = n.color, g = n.lineWidth, p = n.handleSize, _ = 0; if (h.clearRect(0, 0, e, i), this._nodeBeingResized) { var r = this._getTotalOnScreenRadius(this._nodeBeingResized), o = this._nodeBeingResized.getPositionOnScreen(); _ = Math.max(this._x - (o.x + r), -(this._y - (o.y - r))) / 2 } this._additionalRadiuses = [], this._forEachNodeToHighlight(function (t, e, i) { var n = 0; if (d._nodeBeingResized) { n = _; var r = -i + t.getAttribute("innerStroke.width") + t.getAttribute("outerStroke.width") + g / 2 + 1; n = n < r ? r : d._snap(t, n), d._additionalRadiuses.push(n); var o = t.getAttribute("shape"), s = d._engine.getShapePoints(o), a = e.x + n, u = e.y - n, l = i + n; d._displayNodePreview(h, c, a, u, l, s) } h.strokeStyle = f, h.fillStyle = f, h.lineWidth = g, h.strokeRect((e.x - i) * c, (e.y - i - 2 * n) * c, 2 * (n + i) * c, 2 * (n + i) * c), h.fillRect((e.x + i + 2 * n - p / 2) * c, (e.y - i - 2 * n - p / 2) * c, p * c, p * c) }) } }, w_.prototype._displayNodePreview = function (t, e, i, n, r, o) { if (i *= e, n *= e, r *= e, t.beginPath(), 1 === o.length) t.arc(i, n, r, 0, 2 * Math.PI); else for (var s = 0; s < o.length; ++s) { var a = o[s], u = i + a.x * r, l = n + a.y * r; 0 === s ? t.moveTo(u, l) : t.lineTo(u, l) } t.fillStyle = this._options.previewColor, t.fill() }, w_.prototype._getTotalOnScreenRadius = function (t) { return t.getAttribute("radius") * this._camera.zoom + t.getAttribute("innerStroke.width") + t.getAttribute("outerStroke.width") + this._options.lineWidth / 2 }, w_.prototype._snap = function (t, e) { var i = this, n = this._spatial.getNodesInScreenByDistance(t).filter(function (t) { return !t.isSelected() }).slice(0, this._options.nbNodesToSnapTo), r = this._ctx, o = this._getTotalOnScreenRadius(t), s = o + e, a = this._options.snappingRatio, u = s / o, l = Math.round(Je(u, a)), d = o * Math.pow(a, l), h = null; if (n.forEach(function (t) { var e = i._getTotalOnScreenRadius(t); Math.abs(e - s) <= Math.abs(d - s) && (d = e, h = t) }), h) { r.save(), r.strokeStyle = this._options.sizeIndicatorColor, r.lineWidth = this._options.sizeIndicatorThickness; var c = h.getAttribute("radius"); this._displaySizeIndicator(t, d), n.filter(function (t) { return t.getAttribute("radius") === c }).forEach(function (t) { return i._displaySizeIndicator(t) }), r.restore() } return d - o }, w_.prototype._displaySizeIndicator = function (t, e) { var i = this._ctx, n = wt(), r = t.getPositionOnScreen(), o = this._getTotalOnScreenRadius(t), s = e || o, a = e ? e - o : 0, u = a - this._options.sizeIndicatorOffset - (e ? t.getAttribute("innerStroke.width") + t.getAttribute("outerStroke.width") : 0), l = r.x - s + u | 0, d = r.y - s - a | 0, h = r.y + s - a | 0, c = this._options.sizeIndicatorWidth; i.beginPath(), i.moveTo((l - c) * n, d * n), i.lineTo((l + c) * n, d * n), i.moveTo(l * n, d * n), i.lineTo(l * n, h * n), i.moveTo((l - c) * n, h * n), i.lineTo((l + c) * n, h * n), i.stroke() }, w_.prototype.enable = function (t) { this._enabled || (this._options = C({}, A_, t), this._graphics.addCanvas(this._canvas), this._ctx = this._canvas.getContext("2d"), this._events.on({ "cameraMove progressMoveNodesByDragging": this._displayHandlesHandler, "move down": this._moveHandler }), this._enabled = !0) }, w_.prototype.disable = function () { this._enabled && (this._events.removeListener(this._displayHandlesHandler), this._events.removeListener(this._moveHandler), this._graphics.removeCanvas(this._canvas), this._disableCursor(), this._reset()) }, w_.prototype._reset = function () { this._enabled = !1, this._nodesToHighlight = null, this._options = null, this._nodeBeingResized = null, this._pointedNode = null, this._cursorEnabled = !1, this._x = 0, this._y = 0, this._additionalRadiuses = [] }, w_.prototype.enabled = function () { return this._enabled }, w_); function w_(t) { var e = t.dom, i = t.interactions, n = t.camera, r = t.events, o = t.graphics, s = t.spatial, a = t.selection, u = E_.call(this) || this; return u._enabled = !1, u._nodesToHighlight = null, u._options = null, u._nodeBeingResized = null, u._pointedNode = null, u._cursorEnabled = !1, u._x = 0, u._y = 0, u._additionalRadiuses = [], u._onSelectionChange = function () { u._enabled && (u._nodesToHighlight = u._selection.getSelectedNodes(), u._displayHandles()) }, u._displayHandlesHandler = function () { return u._displayHandles() }, u._moveHandler = function (t) { var e = t.x, i = t.y; u._dom.setTimeout(function () { return u._detectBoundingBoxes(e, i) }) }, u._dom = e, u._interactions = i, u._events = r, u._camera = n, u._dom = e, u._spatial = s, u._graphics = o, u._selection = a, u._engine = u._graphics.getGraphicsEngine(), u._canvas = nr(), u._ctx = u._canvas.getContext("2d"), u._interactions.onDrag({ priority: "resizing", disableDetection: !0, check: function () { return !(!u._enabled || !u._pointedNode) }, onStart: function (t) { var e = t.x, i = t.y; u._x = e, u._y = i, u._nodeBeingResized = u._pointedNode }, onProgress: function (t) { var e = t.x, i = t.y; u._x = e, u._y = i, u._displayHandles() }, onStop: function () { u._nodesToHighlight.forEach(function (t, e) { var i = u._additionalRadiuses[e] / u._camera.zoom; t.setAttributes({ radius: t.getAttribute("radius") + i, x: t.getPosition().x + i, y: t.getPosition().y - i }) }), u._pointedNode = null, u._nodeBeingResized = null, u._displayHandles() } }), u } var T_, C_, M_, I_ = { strokeColor: "black", strokeWidth: 5, dashed: !0, cursorStyle: "cell", createNodes: !0, condition: function () { return !0 }, onNodeCreated: function () { }, onEdgeCreated: function () { }, onComplete: function () { } }, L_ = (b(N_, T_ = Ae), N_.prototype._onStart = function (t) { t && (this._cursorEnabled = !0, this._startNode = t, this._startPos = t.getPosition(), this._graphics.addCursorStyle(this._options.cursorStyle), this._blockId = this._graphics.allocateGraphicsEngineBlockId()) }, N_.prototype._onMove = function (t, e) { null !== this._startNode && (this._endPos = this._camera.screenToGraphCoordinates({ x: t, y: e }), this._drawLine()) }, N_.prototype._onStop = function () { if (null !== this._startNode) { var t = this._options, e = t.condition, i = t.onNodeCreated, n = t.onEdgeCreated, r = t.onComplete, o = t.createNodes, s = this._captor.getPointedElement(), a = null, u = null; this._graphics.releaseGraphicsEngineBlockId(this._blockId), !s && o && (u = s = this._graph.addNode({ attributes: { x: this._endPos.x, y: this._endPos.y } }), i && i(u)), s && (u || !e || e(this._startNode, s)) && (a = this._graph.addEdge({ source: this._startNode.getId(), target: s.getId() }), n && n(a)), r && (this._events.fire(xe.CONNECT_NODES, { source: this._startNode, target: s, edge: a }), r(this._startNode, s, a)), this.disable() } }, N_.prototype._drawLine = function () { this._block.reset(1, !1, this._depth); var t = this._block.nextAndReset().end; t.pieceId = wn, t.shape = "line", t.x1 = this._startPos.x, t.y1 = this._startPos.y, t.x2 = this._endPos.x, t.y2 = this._endPos.y, t.fillColor = this._options.strokeColor, t.thicknessOrFontSizeFixed = this._options.strokeWidth, this._options.dashed && (t.dashLength = 3, t.gapLength = 1), this._engine.storeBlock(this._blockId, this._block), this._dom.refresh() }, N_.prototype.enable = function (t) { if (void 0 === t && (t = {}), !this._enabled) return this._options = C({}, I_, t), this._enabled = !0, this._cursorEnabled = !1, this._startNode = null, this._prevSettings = this._settings.update({ "cursor.node": this._options.cursorStyle, "detect.edges": !1 }), this._captor.isLeftPressed() && this._interaction.start(this._captor.getCursorInformation()), this }, N_.prototype.disable = function () { this._enabled && (this._enabled = !1, this._settings.update(this._prevSettings), this._cursorEnabled && this._graphics.removeCursorStyle(this._options.cursorStyle)) }, N_.prototype.enabled = function () { return this._enabled }, N_); function N_(t) { var e = t.dom, i = t.camera, n = t.captor, r = t.graph, o = t.graphics, s = t.interactions, a = t.events, u = t.settings, l = T_.call(this) || this; return l._enabled = !1, l._options = null, l._blockId = null, l._startNode = null, l._startPos = null, l._endPos = null, l._cursorEnabled = !1, l._dom = e, l._camera = i, l._captor = n, l._graph = r, l._graphics = o, l._interactions = s, l._events = a, l._settings = u, l._engine = l._graphics.getGraphicsEngine(), l._block = l._engine.createBlock(), l._depth = Gl(0).edgeBody, l._events.register([xe.CONNECT_NODES]), l._interaction = l._interactions.onDrag({ priority: "connectNodes", check: function (t) { var e = t.target, i = t.button, n = void 0 === i ? "left" : i; return l._enabled && "left" === n && e && e.isNode }, onStart: function (t) { var e = t.target; return l._onStart(e) }, onProgress: function (t) { var e = t.x, i = t.y; return l._onMove(e, i) }, onStop: function () { return l._onStop() } }), l._events.on({ clear: function () { return l.disable() } }), l } var k_, O_ = ["top", "bottom", "left", "right", "cssDefined"], F_ = { top: { x: 0, y: -1 }, bottom: { x: 0, y: 1 }, left: { x: -1, y: 0 }, right: { x: 1, y: 0 } }, R_ = { position: "top", autoAdjust: !0, delay: 100, className: null }, P_ = { hover: { node: function (t) { var e = t.target; return e && e.isNode }, edge: function (t) { var e = t.target; return e && !e.isNode } }, click: ((C_ = {})[gc.LEFT] = { node: function (t) { var e = t.target; return t.button === gc.LEFT && e && e.isNode }, edge: function (t) { var e = t.target; return t.button === gc.LEFT && e && !e.isNode }, background: function (t) { var e = t.target; return t.button === gc.LEFT && !e } }, C_[gc.RIGHT] = { node: function (t) { var e = t.target; return t.button === gc.RIGHT && e && e.isNode }, edge: function (t) { var e = t.target; return t.button === gc.RIGHT && e && !e.isNode }, background: function (t) { var e = t.target; return t.button === gc.RIGHT && !e } }, C_), doubleClick: ((M_ = {})[gc.LEFT] = { node: function (t) { var e = t.target; return t.button === gc.LEFT && e && e.isNode }, edge: function (t) { var e = t.target; return t.button === gc.LEFT && e && !e.isNode }, background: function (t) { var e = t.target; return t.button === gc.LEFT && !e } }, M_[gc.RIGHT] = { node: function (t) { var e = t.target; return t.button === gc.RIGHT && e && e.isNode }, edge: function (t) { var e = t.target; return t.button === gc.RIGHT && e && !e.isNode }, background: function (t) { var e = t.target; return t.button === gc.RIGHT && !e } }, M_) }, D_ = (b(z_, k_ = Ae), z_.prototype.hide = function () { this._hideTooltip(!0) }, z_.prototype.isShown = function () { return !!this._tooltip }, z_.prototype.refresh = function () { this._refreshTooltip() }, z_.prototype.show = function (t, e) { var i = void 0 === e ? {} : e, n = i.position, r = void 0 === n ? "top" : n, o = i.autoAdjust, s = void 0 === o || o, a = i.className, u = void 0 === a ? null : a, l = i.x, d = void 0 === l ? 0 : l, h = i.y, c = void 0 === h ? 0 : h; this._showTooltip(t, { position: r, autoAdjust: s, className: u }, { x: d, y: c }) }, z_.prototype.setHandler = function (t, e, i) { var n = C({}, R_, i); -1 === O_.indexOf(n.position) && (n.position = "top"), this._handlers[t] = { handler: e, condition: H(P_, t), settings: n } }, z_.prototype._hideTooltip = function (t) { if (this._timeout && (this._dom.clearTimeout(this._timeout), this._timeout = null), t && (this._currentHandlerName = null), this._tooltip) { var e = this._tooltip; this._tooltip.parentNode && this._tooltip.parentNode.removeChild(this._tooltip), this._tooltip = null, this._events.fire(xe.TOOLTIP_HIDE, { tooltip: e }) } }, z_.prototype._createInteraction = function (r, o) { var s = this; return void 0 === o && (o = !1), { priority: "tooltip", check: function (t) { var e = B_(r, t), i = s._handlers[e]; return !(o && s._connectNodes.enabled() || (!i || !i.condition(t)) && (o || !s._currentHandlerName || s._isHover || null === s._tooltip)) }, handler: function (t) { var e = t.target, i = t.x, n = t.y; s._hideTooltip(!1), s._isHover = o, s._elt = e, s._x = i, s._y = n, s._currentHandlerName = B_(r, t), s._refreshTooltip() } } }, z_.prototype._refreshTooltip = function () { var e = this; if (this._currentHandlerName) { var t = this._handlers[this._currentHandlerName]; if (t) { var i = t.settings, n = t.handler, r = this._elt; if (r) { var o = r.isNode ? "node" : "edge"; if (-1 === this._currentHandlerName.indexOf(o)) return } var s = n(r); (s instanceof Promise ? s : Promise.resolve(s)).then(function (t) { e._schedule(function () { return e._showTooltip(t, i) }, i.delay) }) } } else this._hideTooltip(!1) }, z_.prototype._schedule = function (t, e) { var i = this; this._timeout && this._dom.clearTimeout(this._timeout), this._timeout = this._dom.setTimeout(function () { i._timeout = null, t() }, e) }, z_.prototype._showTooltip = function (t, e, i) { this._hideTooltip(!1); var n = e.position, r = e.className, o = e.autoAdjust, s = this._x, a = this._y, u = this._elt, l = this._dom.getDimensions(), d = 0, h = 0; if (i && (s = i.x, a = i.y, u = null), "string" == typeof t) this._tooltip = function (t) { return ht ? document.createElement(t) : St() }("div"), this._tooltip.innerHTML = t; else { if (!Ut(t)) throw new Error("invalid tooltip " + t + ", expected HTML string or HTML element"); this._tooltip = t } var c = this._tooltip; if (r && this._tooltip.classList.add(r), "cssDefined" !== n && (c.style.position = "absolute"), this._dom.appendElement(c), u && u.isNode) { var f = u, g = f.getPositionOnScreen(), p = f.getAttribute("radius"); p = "fixed" === f.getAttribute("scalingMethod") ? p + f.getAttribute("innerStroke.width") + f.getAttribute("outerStroke.width") : p * this._camera.getZoom() + f.getAttribute("innerStroke.width") + f.getAttribute("outerStroke.width"), s = g.x, a = g.y, h = d = p } var _ = c.offsetWidth / 2, v = c.offsetHeight / 2; if (d += _, h += v, "cssDefined" !== n) { var m = F_[n], y = m.x, b = m.y; if (o) { var x = s + d * m.x, E = a + h * m.y; (x - _ < 0 || x + _ >= l.width) && ("left" === n || "right" === n ? y *= -1 : y = x - _ < 0 ? (_ - x + 1) / d : (l.width - (x + _) - 1) / d), (E - v < 0 || E + v >= l.height) && ("top" === n || "bottom" === n ? b *= -1 : b = E - v < 0 ? (v - E + 1) / h : (l.height - (E + v) - 1) / h) } c.style.left = s + d * y - _ + "px", c.style.top = a + h * b - v + "px" } this._events.fire(xe.TOOLTIP_SHOW, { tooltip: c }) }, z_); function z_(t) { var e = t.dom, i = t.connectNodes, n = t.interactions, r = t.camera, o = t.events, s = k_.call(this) || this; return s._x = 0, s._y = 0, s._dom = e, s._connectNodes = i, s._interactions = n, s._camera = r, s._events = o, s._handlers = {}, s._currentHandlerName = null, s._tooltip = null, s._isHover = !1, s._events.register(["showTooltip", "hideTooltip"]), s._events.on({ "up dragStart": function () { s._isHover || s._hideTooltip(!1) }, unhover: function () { s._isHover && s._hideTooltip(!1) }, clear: function () { return s._hideTooltip(!1) } }), s._interactions.onHover(s._createInteraction("hover", !0)), s._interactions.onClick(s._createInteraction("click")), s._interactions.onDoubleClick(s._createInteraction("doubleClick")), s } function B_(t, e) { var i = e.button, n = e.target; return t + (i ? "." + i : "") + "." + (null !== n ? n.isNode ? "node" : "edge" : "background") } var U_, V_ = { 65: "a", 66: "b", 67: "c", 68: "d", 69: "e", 70: "f", 71: "g", 72: "h", 73: "i", 74: "j", 75: "k", 76: "l", 77: "m", 78: "n", 79: "o", 80: "p", 81: "q", 82: "r", 83: "s", 84: "t", 85: "u", 86: "v", 87: "w", 88: "x", 89: "y", 90: "z", 48: "0", 49: "1", 50: "2", 51: "3", 52: "4", 53: "5", 54: "6", 55: "7", 56: "8", 57: "9", 13: "enter", 16: "shift", 17: "ctrl", 18: "alt", 27: "esc", 46: "del", 8: "backspace", 32: "space", 224: "cmd", 91: "cmd", 92: "cmd", 93: "cmd", 187: "+", 189: "-" }, j_ = Object.keys(V_).reduce(function (t, e) { var i = V_[e]; return t[i] || (t[i] = []), t[i].push(e), t }, {}), G_ = (b(H_, U_ = Ae), H_.prototype.setIdleTimeout = function (t) { if (!isFinite(t) || t <= 1) throw new TypeError("Idle timeout must be a positive number > 1"); this._idleTimeout = t }, H_.prototype.resetKeys = function () { for (var t = 0; t < this._pressed.length; t++)this._pressed[t] && (this._pressed[t] = !1, this._events.fire("keyUp", { key: V_[t], code: t })) }, H_.prototype.onKeyPress = function (t, e) { var i, n = this; if ("number" == typeof t && (i = [t]), "string" == typeof t && (i = t.split(" ")), Array.isArray(t) && (i = t), !i) throw new TypeError(t + " is not a number, string or array"); if (0 === i.length) throw new Error("the array should contain at least one element"); var r = i.map(function (t) { if ("number" == typeof t) return [t]; if ("string" != typeof t) throw new TypeError(t + " is not a valid key identifier"); var e = j_[t]; if (!e) throw new Error(t + " is not a valid key identifier"); return e }), o = r.pop(), s = { keys: r, handler: e }; o.forEach(function (t) { n._binds[t] || (n._binds[t] = []), n._binds[t].push(s) }) }, H_.prototype.isPressed = function (t) { var e = this; if ("number" == typeof t) return this._pressed[t]; if ("string" == typeof t) { var i = j_[t]; if (i) return i.some(function (t) { return e._pressed[t] }) } return !1 }, H_); function H_(t) { var e = t.dom, i = t.events, s = U_.call(this) || this; return s._onBlur = function () { return s.resetKeys() }, s._onKeyUp = function (t) { var e = t.keyCode || t.which; s._pressed[e] = !1, s._events.fire("keyUp", { domEvent: t, key: V_[e], code: e }) }, s._onKeyDown = function (t) { var e = t.keyCode || t.which, i = s._binds[e]; if (!s._pressed[e]) { if (s._pressed[e] = !0, i) for (var n = 0, r = i; n < r.length; n++) { var o = r[n]; o.keys.every(function (t) { return t.some(function (t) { return s._pressed[t] }) }) && o.handler({ domEvent: t }) } s._events.fire("keyDown", { domEvent: t, key: V_[e], code: e }) } }, s._dom = e, s._events = i, s._events.register(["keyUp", "keyDown"]), s._binds = [], s._pressed = [], s._dom.addWindowEventListener("keydown", s._onKeyDown), s._dom.addWindowEventListener("keyup", s._onKeyUp), s._dom.addWindowEventListener("visibilitychange", s._onBlur), s._dom.addWindowEventListener("blur", s._onBlur, !1), s._idleTimeout = 4e3, s._prevEventTimeStamp = Kt(), s._events.onAnyEvent(function () { var t = Kt(); t - s._prevEventTimeStamp > s._idleTimeout && s.resetKeys(), s._prevEventTimeStamp = t }), s } var q_ = [{ name: "color", isNode: !0 }, { name: "shape", isNode: !0 }, { name: "radius", isNode: !0 }, { name: "icon.content", isNode: !0 }, { name: "image.url", isNode: !0 }, { name: "image", isNode: !0 }, { name: "color", isNode: !1 }, { name: "shape", isNode: !1 }, { name: "width", isNode: !1 }], W_ = Math.PI, X_ = 2 * Math.PI, Y_ = Math.cos(W_ / 2 - X_ / 5), Z_ = Math.cos(W_ / 2 - X_ / 5 * 2), K_ = Math.cos(W_ / 2 - X_ / 5 * 3), Q_ = Math.cos(W_ / 2 - X_ / 5 * 4), J_ = Math.sin(-W_ / 2 + X_ / 5), $_ = Math.sin(-W_ / 2 + X_ / 5 * 2), tv = Math.sin(-W_ / 2 + X_ / 5 * 3), ev = Math.sin(-W_ / 2 + X_ / 5 * 4), iv = 1.6, nv = 3, rv = .9, ov = .31, sv = 1 / 3, av = [8, 3], uv = [3, 3], lv = { position: "bottom", widgetWidth: 130, fontFamily: "Arial", fontSize: 10, fontColor: "black", titleFontSize: 12, titleFontColor: "black", titleMaxLength: 20, titleTextAlign: "left", shapeColor: "grey", backgroundColor: "white", borderColor: "black", borderRadius: 0, borderWidth: 1, innerMargin: 10, outerMargin: 5, circleStrokeWidth: 3, titleFunction: function (t) { return t[t.length - 1] } }, dv = ["widgetWidth", "fontSize", "titleFontSize", "borderRadius", "borderWidth", "innerMargin", "outerMargin", "circleStrokeWidth"]; function hv(t) { var e = ["K", "M", "B", "T", "P", "E", "Z", "Y"]; if (9999 < t) { for (var i = 0; i < e.length && 999 < t;)t /= 1e3, i++; return (cv(t, 3) + e[i - 1]).toString() } return cv(t, 4).toString() } function cv(t, e) { void 0 === e && (e = 3); var i = 4 === e ? 10 : 1; return t < 10 ? Math.round(100 * t * i) / 100 * i : t < 100 ? Math.round(10 * t * i) / 10 * i : t < 1e3 ? Math.round(t * i) / i : Math.round(t) } function fv(t) { return t.innerMargin + (t.titleFontSize + t.fontSize) * iv } function gv(c, t, e) { var i, n, f = t.getContext("2d"), r = e.x, o = e.y, s = e.height, g = e.isNode, p = e.styleProperty, a = e.title, _ = e.mapping, v = e.iconFont, m = e.iconFontStyle; n = s, function (t, e, i, n, r, o, s, a, u) { t.setLineDash([]), t.beginPath(), t.moveTo(e + o, i), t.lineTo(e + n - o, i), t.quadraticCurveTo(e + n, i, e + n, i + o), t.lineTo(e + n, i + r - o), t.quadraticCurveTo(e + n, i + r, e + n - o, i + r), t.lineTo(e + o, i + r), t.quadraticCurveTo(e, i + r, e, i + r - o), t.lineTo(e, i + o), t.quadraticCurveTo(e, i, e + o, i), t.closePath(), t.fillStyle = s, t.fill(), t.strokeStyle = a, t.lineWidth = u, t.stroke() }(f, r, o, (i = c).widgetWidth, n, i.borderRadius, i.backgroundColor, i.borderColor, i.borderWidth), function (t, e, i, n, r) { pv(t, e.fontFamily, e.titleFontSize, e.titleFontColor, e.titleTextAlign); var o = "center" === e.titleTextAlign, s = e.widgetWidth - 2 * e.innerMargin, a = t.measureText(i).width, u = n + (o ? e.widgetWidth / 2 : e.innerMargin), l = r + e.titleFontSize / 2 + e.innerMargin; if (s < a) { var d = s / a, h = (i.length * d | 0) - 2; i = i.substr(0, h) + "…" } t.fillText(i, u, l) }(f, c, a, r, o); var u, y = c.fontSize * iv, b = c.fontSize / 2 * iv * rv, x = c.fontSize * nv, E = c.fontSize, l = (u = g ? 1 : nv, c.fontSize * u), A = o + fv(c), S = r + c.innerMargin + l / 2, w = r + 2 * c.innerMargin + l, d = U(_), T = function i(t) { return Array.isArray(t) ? t.reduce(function (t, e) { return t && i(e) }, !0) : "undefined" === t || !isNaN(Number(t)) }(d), C = c.fontColor, M = c.shapeColor, h = Object.keys(_); if (T && (h.sort(function (t, e) { return Qe(_[e]) - Qe(_[t]) }), "radius" === p || "width" === p)) { var I = function i(t) { return Array.isArray(t) ? t.reduce(function (t, e) { return Math.min(t, i(e)) }, 1 / 0) : isNaN(t) ? 1 / 0 : +t }(d), L = function i(t) { return Array.isArray(t) ? t.reduce(function (t, e) { return Math.max(t, i(e)) }, -1 / 0) : isNaN(t) ? -1 / 0 : +t }(d), N = Math.round((I + L) / 2); return (g ? vv : mv)(c, f, r, A, I, N, L, M) } h.forEach(function (t) { var e, i, n, r, o, s, a, u, l, d, h = _[t]; "color" === p && (g ? _v(f, S, A, b, t) : (i = S, n = A, r = x, o = E, s = t, (e = f).fillStyle = s, e.fillRect(i - r / 2, n - o / 2, r, o))), "shape" === p && (g ? function (t, e, i, n, r, o) { switch (t.fillStyle = o, r) { case "square": return t.fillRect(e - n, i - n, 2 * n, 2 * n); case "circle": return _v(t, e, i, n, o); case "cross": return function (t, e, i, n) { t.fillRect(e - n, i - n * ov, 2 * n, 2 * n * ov), t.fillRect(e - n * ov, i - n, 2 * n * ov, 2 * n) }(t, e, i, n); case "diamond": return function (t, e, i, n) { t.beginPath(), t.moveTo(e - n, i), t.lineTo(e, i - n), t.lineTo(e + n, i), t.lineTo(e, i + n), t.fill() }(t, e, i, n); case "equilateral": return function (t, e, i, n) { t.beginPath(), t.moveTo(e, i - n), t.lineTo(e + Y_ * n, i + J_ * n), t.lineTo(e + Z_ * n, i + $_ * n), t.lineTo(e + K_ * n, i + tv * n), t.lineTo(e + Q_ * n, i + ev * n), t.fill() }(t, e, i, n); case "star": (function (t, e, i, n) { t.beginPath(), t.moveTo(e, i - n), t.lineTo(e + Z_ * n, i + $_ * n), t.lineTo(e + Q_ * n, i + ev * n), t.lineTo(e + Y_ * n, i + J_ * n), t.lineTo(e + K_ * n, i + tv * n), t.fill() })(t, e, i, n) } }(f, S, A, b, t, M) : function (t, e, i, n, r, o, s) { t.fillStyle = s, "line" === o && t.fillRect(e - n / 2, i - r / 4, n, r / 2); if ("arrow" === o) return function (t, e, i, n, r) { t.fillRect(e - n / 2, i - r / 4, n * (1 - sv), r / 2), t.beginPath(), t.moveTo(e + n * (1 - sv - .5), i - r / 2), t.lineTo(e + n * (1 - sv - .5), i + r / 2), t.lineTo(e + n / 2, i), t.fill() }(t, e, i, n, r); if ("dashed" === o || "dotted" === o) return function (t, e, i, n, r, o, s) { t.beginPath(), t.moveTo(e - n / 2, i), t.lineTo(e + n / 2, i), t.strokeStyle = o, t.lineWidth = r / 2, t.setLineDash("dashed" === s ? av : uv), t.stroke() }(t, e, i, n, r, s, o); if ("tapered" === o) (function (t, e, i, n, r) { t.beginPath(), t.moveTo(e - n / 2, i - r / 2), t.lineTo(e - n / 2, i + r / 2), t.lineTo(e + n / 2, i), t.fill() })(t, e, i, n, r) }(f, S, A, x, E, t, M)), "icon.content" === p && (u = S, l = A, d = t, pv(a = f, v, 2 * b, C, "center", m), a.fillText(d, u, l)), "image" !== p && "image.url" !== p || function (t, e, i, n, r) { if ("undefined" == typeof Image) return; t._imgStore || (t._imgStore = {}); var o = t._imgStore[r]; if (o) return t.drawImage(o, e - n, i - n, 2 * n, 2 * n); (o = new Image).src = r, o.onload = function () { t.drawImage(o, e - n, i - n, 2 * n, 2 * n) }, t._imgStore[r] = o }(f, S, A, b, t), function (t, e, i, n, r, o) { var s = r.join(); if (o) if (1 === r.length) s = hv(r[0]); else { var a = Qe(r), u = Ke(r); s = hv(a) + " - " + hv(u) } pv(t, e.fontFamily, e.fontSize, e.fontColor), t.fillText(s, i, n) }(f, c, w, A, h, T), A += y }) } function pv(t, e, i, n, r, o) { void 0 === r && (r = "left"), void 0 === o && (o = "normal"); t.textAlign = r, t.textBaseline = "middle", t.fillStyle = n, t.font = o + " " + i + 'px "' + e + '"' } function _v(t, e, i, n, r) { t.beginPath(), t.arc(e, i, n, 0, 2 * W_), t.fillStyle = r, t.fill() } function vv(t, e, i, n, r, o, s, a) { for (var u, l, d, h, c, f, g = .7 * t.fontSize, p = 3 * g, _ = (g + p) / 2, v = i + t.innerMargin + p, m = v + p + t.innerMargin, y = n + 2 * p - .5 * t.innerMargin, b = t.circleStrokeWidth, x = 0, E = [g, _, p]; x < E.length; x++) { var A = E[x]; l = v, d = y - A, h = A, c = a, f = b, (u = e).beginPath(), u.arc(l, d, h, 0, X_), u.strokeStyle = c, u.lineWidth = f, u.stroke() } pv(e, t.fontFamily, t.fontSize, t.fontColor, "left"), e.fillText(hv(r), m, y + g - 2 * g), e.fillText(hv(o), m, y + g - 2 * _), e.fillText(hv(s), m, y + g - 2 * p) } function mv(t, e, i, n, r, o, s, a) { var u = (t.widgetWidth - 2 * t.innerMargin) / 3, l = t.fontSize, d = n - t.innerMargin / 2, h = d + 2 * l, c = i + t.innerMargin; e.fillStyle = a, e.fillRect(c, d - l / 2, 1 + u, l), e.fillRect(c + u, d - l / 3, 1 + u, l / 1.5), e.fillRect(c + 2 * u, d - l / 6, u, l / 3), pv(e, t.fontFamily, t.fontSize, t.fontColor, "center"), e.fillText(hv(s), c + .5 * u, h), e.fillText(hv(o), c + 1.5 * u, h), e.fillText(hv(r), c + 2.5 * u, h) } function yv(e, i, t) { var n = { width: i.width, height: i.height }, r = !1; return !!(n.width && n.height && t) && ((r = "top" === e.position || "bottom" === e.position ? function (t, e, i, n) { i = i.slice(); for (var r = e.widgetWidth + e.outerMargin, o = Math.floor((t.width - e.outerMargin) / r), s = t.height - e.outerMargin, a = new Array(Math.min(o, i.length)), u = i.length, l = 0, d = 0, h = 0, c = 0, f = 0; f < u; ++f) { var g = i[f]; g.isNode ? (l += 1, d += g.height) : (h += 1, c += g.height) } var p = d + c, _ = d / p, v = c / p, m = Math.round(_ * o), y = Math.round(v * o); l < m ? m = l : h < y && (m = o - h); if (0 === o) return !1; for (f = 0; f < a.length; f++)a[f] = { content: [], height: 0, isNode: f < m }; for (f = 0; f < u; ++f) { var b = xv(i); bv(i[b], a, e), i.splice(b, 1) } a.every(function (t) { return 1 === t.content.length }) ? a.sort(wv) : a.sort(Sv); var x = e.outerMargin; for (f = 0; f < a.length; ++f) { var E = a[f]; if (E.height > s) return !1; E.content.sort(Av); for (var A = 0, S = 0; S < E.content.length; ++S) { var w = E.content[S]; w.x = x, w.y = n ? t.height - A - w.height - e.outerMargin : A + e.outerMargin, A += w.height + e.outerMargin } x += r } return !0 }(n, e, t, "bottom" === e.position) : function (t, e, i, n) { var r = e.widgetWidth + e.outerMargin, o = Math.floor((t.width - e.outerMargin) / r), s = t.height, a = e.outerMargin, u = n ? e.outerMargin : t.width - r, l = 1; i = i.slice().sort(Ev); for (var d = 0; d < i.length; ++d) { var h = i[d]; if (a + h.height > s) { if (a === e.outerMargin) return !1; a = e.outerMargin, l += 1, n ? u += r : u -= r } h.x = u, h.y = a, a += h.height } return l <= o }(n, e, t, "left" === e.position)) && t.forEach(function (t) { return gv(e, i, t) }), r) } function bv(t, e, i) { for (var n = null, r = 0; r < e.length; ++r) { var o = e[r]; o.isNode !== t.isNode && 1 !== e.length || !(null === n || o.height < e[n].height) || (n = r) } (o = e[n]).content.push(t), o.height += t.height + i.outerMargin } function xv(t) { for (var e = 0, i = 1; i < t.length; ++i)t[i].height > t[e].height && (e = i); return e } function Ev(t, e) { return t.isNode !== e.isNode ? t.isNode ? -1 : 1 : t.title <= e.title ? -1 : 1 } function Av(t, e) { return t.height - e.height } function Sv(t, e) { return t.isNode !== e.isNode ? t.isNode ? -1 : 1 : e.height - t.height } function wv(t, e) { return t.isNode !== e.isNode ? t.isNode ? -1 : 1 : t.content[0].title <= e.content[0].title ? -1 : 1 } var Tv, Cv = (b(Mv, Tv = Ae), Mv.prototype.enable = function (t) { var e = this._settings; return this._settings = C({}, lv, t), this._mustRefresh = !this._enabled || !this._sameOptions(e, this._settings), this._enabled ? Promise.resolve() : (this._enabled = !0, this._graphics.addCanvas(this._canvas), this.refresh()) }, Mv.prototype._afterNextUpdate = function () { var e = this; return new Promise(function (t) { return e._promises.push(t) }) }, Mv.prototype._formatSettings = function (t, e) { var i = C({}, lv, t); return dv.forEach(function (t) { return i[t] *= e }), i }, Mv.prototype.disable = function () { this._enabled && (this._enabled = !1, this._graphics.removeCanvas(this._canvas)) }, Mv.prototype.enabled = function () { return this._enabled }, Mv.prototype.refresh = function () { return this._mustRefresh = !0, this._dom.refresh(), this._afterNextUpdate() }, Mv.prototype.destroy = function () { this._enabled = !1, this._mustRefresh = !1, this._settings = null, this._promises = [] }, Mv.prototype.getOptions = function () { if (this.enabled) return C({}, this._settings) }, Mv.prototype.getCurrentOptions = function () { return this._settings }, Mv.prototype._sameOptions = function (i, n) { return i === n || Object.keys(i).reduce(function (t, e) { return t && i[e] === n[e] }, !0) }, Mv.prototype._drawOnCanvas = function (t, e, i) { var n = this._formatSettings(t, i); yv(n, e, this._computeWidgetList(n)) }, Mv.prototype.exportOnCanvas = function (t, e) { return this._drawOnCanvas(e, t, 1) }, Mv.prototype._computeWidgetList = function (r) { var o = this, s = []; return q_.forEach(function (t) { var e = t.name, i = t.isNode, n = o._computeWidget(r, e, i); n && s.push(n) }), s }, Mv.prototype._computeWidget = function (t, e, i) { var n = this._computePropertyMapping(t, e, i); if (n) { if ("icon.content" !== e) return n; var r = this._getRulesForAttribute(i, "icon.font"), o = this._getRulesForAttribute(i, "icon.style"), s = null, a = null; if (r.length || (s = "Arial", a = "normal"), "string" == typeof r[0] && (s = r[0], a = o[0]), s) return n.iconFont = s, n.iconFontStyle = a, n } return null }, Mv.prototype._computePropertyMapping = function (t, e, i) { var n, r, o, s, a, u, l, d = this._getRulesForAttribute(i, e)[0], h = d && d.mapping, c = h && h.getValues(i); if (h && c) { var f = h.getField(), g = {}; return V(c, function (t, e) { void 0 !== t && "undefined" !== e && (g[t] = g[t] || [], g[t].push(e)) }), 0 === Object.keys(g).length ? null : { isNode: i, title: t.titleFunction(f), styleProperty: e, dataProperty: f, mapping: g, height: (n = g, r = e, o = i, a = (s = t).outerMargin + fv(s), u = s.fontSize * iv, l = a - .8 * s.innerMargin, "radius" === r || "width" === r ? l + u * (o ? 3 : 2) : l + Object.keys(n).length * u) } } return null }, Mv.prototype._getRulesForAttribute = function (i, n) { return this._styleRules.getRuleList().map(function (t) { var e = t.getDefinition(); return H(i ? e.nodeAttributes : e.edgeAttributes, n) }).filter(function (t) { return t }).sort(function (t, e) { return t.mapping && e.mapping ? 0 : t.mapping ? -1 : 1 }) }, Mv); function Mv(t) { var e, i = t.graphics, n = t.dom, r = t.events, o = t.styleRules, s = Tv.call(this) || this; return s._enabled = !1, s._mustRefresh = !1, s._settings = null, s._promises = [], s._graphics = i, s._dom = n, s._events = r, s._styleRules = o, s._canvas = nr(), s._ctx = s._canvas.getContext("2d"), s._events.on(((e = {})[xe.NEW_FRAME] = function () { if (s._enabled && s._mustRefresh) { s._ctx.clearRect(0, 0, s._canvas.width, s._canvas.height), s._drawOnCanvas(s._settings, s._canvas, wt()); var t = s._promises; s._promises = [], t.forEach(function (t) { return t() }), s._mustRefresh = !1 } }, e[xe.RESIZE + " " + xe.RELOAD_FONTS] = function () { s._mustRefresh = !0 }, e)), s } var Iv, Lv = { layer: 3, outline: !0, outerStroke: { color: "red", width: 5 }, innerStroke: { minVisibleSize: 0 }, text: { backgroundColor: "rgb(220, 220, 220)", minVisibleSize: 0 } }, Nv = { layer: 3, outline: !0, color: "red", text: { backgroundColor: "rgb(220, 220, 220)", minVisibleSize: 0 } }, kv = (b(Ov, Iv = Ae), Ov.prototype.setRate = function (t) { this._delay = t }, Ov.prototype.updateNodeAttributes = function (t, e) { this._hoverClass.update({ nodeAttributes: t, fullOverwrite: e }), this._hoverExtremityHighlightedClass.update({ nodeAttributes: t, fullOverwrite: e }), this._updateExtremityHighlightLayer() }, Ov.prototype.updateEdgeAttributes = function (t, e) { this._hoverClass.update({ edgeAttributes: t, fullOverwrite: e }), this._updateExtremityHighlightLayer() }, Ov.prototype.onMounted = function (t) { function e() { i._hoverExtremityHighlightedClass.clearNodes(), i._hoverClass.getEdges().getExtremities().addClass(ul) } var i = this; this._classes.onEdgeClassAdded(al, e), this._classes.onEdgeClassRemoved(al, e) }, Ov.prototype._registerSettings = function () { var e = this; this._settings.register("cursor.node", "pointer", function (value, t) { e._hovered && e._hovered.isNode && (e._graphics.removeCursorStyle(t), e._graphics.addCursorStyle(value)) }), this._settings.register("cursor.edge", "pointer", function (value, t) { e._hovered && !e._hovered.isNode && (e._graphics.removeCursorStyle(t), e._graphics.addCursorStyle(value)) }), this._settings.register("nodeHover", !0, function (value) { !value && e._hovered && e._hovered.isNode && e._unhoverElement(e._hovered) }), this._settings.register("edgeHover", !0, function (value) { value || !e._hovered || e._hovered.isNode || e._unhoverElement(e._hovered) }) }, Ov.prototype._updateExtremityHighlightLayer = function () { var t = this._hoverClass.getDefinition().edgeAttributes, e = t ? t.layer : void 0; this._hoverExtremityHighlightedClass.update({ nodeAttributes: { layer: e }, fullOverwrite: !1 }) }, Ov.prototype._removeTimeout = function () { this._timeout && (this._dom.clearTimeout(this._timeout), this._timeout = null) }, Ov.prototype._isAnimating = function () { return this._graphics.isAnimating() }, Ov.prototype._hoverElement = function (t) { var e = this, i = t.isNode ? "nodeHover" : "edgeHover"; this._settings.get(i) && !this._isAnimating() && (this._removeTimeout(), this._timeout = this._dom.setTimeout(function () { e._isAnimating() || (e._setElementHighlight(!0, t), e._hovered = t), e._timeout = null }, this._delay)) }, Ov.prototype._unhoverElement = function (t) { this._removeTimeout(), this._hovered === t && (this._setElementHighlight(!1, t), this._hovered = null) }, Ov.prototype._setElementHighlight = function (t, e) { var i = this._settings.get(e.isNode ? "cursor.node" : "cursor.edge"); t ? (this._graphics.addCursorStyle(i), e.addClass(al)) : (this._graphics.removeCursorStyle(i), e.removeClass(al)), e.isNode && t && this._graph.getAttribute(e.isNode, "textHidden").set(e._index, !1) }, Ov); function Ov(t) { var e, i = t.dom, n = t.classes, r = t.captor, o = t.graph, s = t.graphics, a = t.settings, u = t.events, l = Iv.call(this) || this; return l._delay = 100, l._manualTriggerDetection = !1, l._hovered = null, l._timeout = null, l._onAnimate = function (t) { t.duration && (l._manualTriggerDetection = !0, l._resetHover()) }, l._onBeforeNewFrame = function () { if (l._manualTriggerDetection && !l._graphics.isAnimating()) { l._manualTriggerDetection = !1, l._captor.triggerDetection(); var t = l._captor.getPointedElement(); t && l._hoverElement(t) } }, l._onClear = function () { l._hovered = null, l._timeout && l._dom.clearTimeout(l._timeout) }, l._resetHover = function () { l._hovered && (l._unhoverElement(l._hovered), l._captor.triggerUnhover()), l._timeout && (l._dom.clearTimeout(l._timeout), l._timeout = null) }, l._dom = i, l._graph = o, l._graphics = s, l._settings = a, l._captor = r, l._events = u, l._classes = n, l._registerSettings(), l._hoverExtremityHighlightedClass = l._classes.createClass({ name: ul, isBuiltin: !0, nodeAttributes: Lv }), l._hoverClass = l._classes.createClass({ name: al, isBuiltin: !0, nodeAttributes: Lv, edgeAttributes: Nv }), l._events.on(((e = {})[xe.HOVER] = function (t) { var e = t.target; return l._hoverElement(e) }, e[xe.UNHOVER] = function (t) { var e = t.target; return l._unhoverElement(e) }, e[xe.ANIMATE] = l._onAnimate, e[xe.BEFORE_NEW_FRAME] = l._onBeforeNewFrame, e[xe.MOUSE_LEAVE] = l._resetHover, e[xe.CLEAR_GRAPH] = l._onClear, e)), l } var Fv = function () { this.x = 0, this.y = 0 }, Rv = (Pv.prototype.getValue = function (t, e) { var i = t.isNode, n = i ? this._nodeMapping : this._edgeMapping; n.valid || (n.values = this._computeMapping(i), n.valid = !0); var r = t.getData(this._field); return Array.isArray(r) ? "color" === e ? r.map(function (t) { return n.values[t] }) : n.values[r[0]] : n.values[r] }, Pv.prototype.markAsInvalid = function () { this._nodeMapping.valid = !1, this._edgeMapping.valid = !1 }, Pv.prototype.getValues = function (t) { return t ? this._nodeMapping.values : this._edgeMapping.values }, Pv.prototype.getField = function () { return this._field }, Pv); function Pv(t, e) { this._nodeMapping = { valid: !1, values: null }, this._edgeMapping = { valid: !1, values: null }, this._computeMapping = e, this._field = t } function Dv(t, e, i) { var n = (e ? t.getNodes() : t.getEdges()).getData(i), r = {}; return n.forEach(function (value) { if (!Array.isArray(value)) return r[value] = 1; value.forEach(function (t) { return r[t] = 1 }) }), "undefined" in r && delete r[void 0], Object.keys(r).sort() } function zv(t, e, i, n) { for (var r = i.values, o = i.fallback, s = Dv(t, n, e), a = {}, u = 0, l = 0; l < s.length; ++l) { var value = s[l]; value in r ? a[value] = r[value] : (a[value] = o[u], u = (u + 1) % o.length) } return a } function Bv(t, e, i, n) { for (var r = i.fallback, o = i.stops, s = i.values, a = i.reverse, u = Dv(t, n, e), l = 1 / 0, d = -1 / 0, h = 0; h < u.length; h++) { dg(value = +u[h]) && (l = Math.min(l, value), d = Math.max(d, value), u[h] = value) } var c = {}; if (!isFinite(l)) { for (h = 0; h < u.length; h++)c[u[h]] = r; return c } var f = function (t, e) { var i = e.nbSlices, n = e.minValue, r = e.maxValue; if (Array.isArray(t)) return t.slice(); for (var o = t.min, s = void 0 === o ? n : o, a = t.max, u = ((void 0 === a ? r : a) - s) / i, l = [], d = 1; d < i; ++d)l.push(s + u * d); return l }(o, { nbSlices: Array.isArray(s) ? s.length : s.nbSlices, minValue: l, maxValue: d }), g = function (t, e) { if (Array.isArray(t)) return t; for (var i = t.min, n = t.max, r = e.length + 1, o = (n - i) / e.length, s = [], a = 0; a < r; a++)s.push(i + a * o); return s }(s, f); a && g.reverse(); for (h = 0; h < u.length; ++h) { var value = u[h]; if (isFinite(value)) { for (var p = 0; p < f.length && f[p] <= value;)p += 1; c[value] = g[p] } else c[value] = r } return c } var Uv, Vv = (b(jv, Uv = Ae), jv.prototype.createMapping = function (t) { var e = void 0 === t ? { field: "" } : t, i = e.field, n = e.values, r = void 0 === n ? {} : n, o = e.fallback, s = void 0 === o ? void 0 : o; if (i = F(i), Array.isArray(s) ? 0 === s.length && (s = [void 0]) : s = [s], !B(r)) throw new Error('"mapping" should be an object'); return this._createMappingFunction(zv, i, { values: r, fallback: s }) }, jv.prototype.createSlices = function (t) { var e = void 0 === t ? { field: "", values: [] } : t, i = e.field, n = e.fallback, r = void 0 === n ? void 0 : n, o = e.stops, s = void 0 === o ? {} : o, a = e.values, u = e.reverse, l = void 0 !== u && u; if (i = F(i), Array.isArray(a) || a.nbSlices || (a.nbSlices = 7), Array.isArray(s) && Array.isArray(a) && s.length !== a.length - 1) throw new Error("there should be exactly one more value that stops"); return this._createMappingFunction(Bv, i, { fallback: r, stops: s, values: a, reverse: l }) }, jv.prototype._createMappingFunction = function (e, i, n) { var r = this, o = new Rv(i, function (t) { return e(r._graph, i, n, t) }); function t(t, e, i) { return o.getValue(t, i) } return this._mappingList.push(o), t.mapping = o, t }, jv.prototype.createTemplate = function (t) { if ("string" != typeof t) throw new TypeError('"template" should be a string'); for (var n = [], e = 0, i = !1; !i;) { var r = -1, o = t.indexOf("{{", e); -1 !== o && (r = t.indexOf("}}", o + 2)), -1 !== r ? (n.push(t.substring(e, o)), n.push(t.substring(o + 2, r)), e = r + 2) : (n.push(t.slice(e)), i = !0) } return function (t) { for (var e = n[0], i = 1; i < n.length; i += 2)e += t.getData(n[i]), e += n[i + 1]; return e } }, jv); function jv(t) { var e, i = t.graph, n = t.events, r = t.styleRules, o = t.legend, s = Uv.call(this) || this; return s._mappingList = [], s._graph = i, s._styleRules = r, s._events = n, s._legend = o, s._events.on(((e = {})[[xe.ADD_NODES, xe.ADD_EDGES, xe.UPDATE_NODE_DATA, xe.UPDATE_EDGE_DATA, xe.REMOVE_NODES, xe.BEFORE_REMOVE_EDGES, xe.EXCLUDED_STATE_CHANGE, xe.CLEAR_GRAPH].join(" ")] = function () { if (s._mappingList.length) { for (var t = 0; t < s._mappingList.length; ++t)s._mappingList[t].markAsInvalid(); s._styleRules.refreshAllRules(), s._legend.refresh() } }, e)), s } var Gv, Hv, qv = (Wv.prototype.run = function (t) { var e = t.ogma, i = t.duration, n = this._getNodesToFilter(e), r = this._getEdgesToFilter(e, n); return Promise.all([n.addClass(pl, i), r.addClass(pl, i)]).then(function () { return n.setExcluded(!0), r.setExcluded(!0), { nodes: n, edges: r } }) }, Wv.prototype.undo = function (t) { var e = t.duration, i = t.context, n = i.nodes, r = i.edges; return n.setExcluded(!1), r.setExcluded(!1), n.addClass(pl), r.addClass(pl), Promise.all([n.removeClass(pl, e), r.removeClass(pl, e)]) }, Wv); function Wv(t) { var e = t.getNodesToFilter, i = t.getEdgesToFilter; this._getNodesToFilter = e, this._getEdgesToFilter = i } (Hv = Gv = Gv || {}).NodeFilter = "node-filter", Hv.EdgeFilter = "edge-filter", Hv.NodeCollapsing = "node-collapsing", Hv.VirtualProperties = "virtual-properties", Hv.NeighborGeneration = "neighbor-generation", Hv.NeighborMerging = "neighbor-merging"; var Xv, Yv = (b(Zv, Xv = qv), Zv.prototype.getName = function () { return Gv.NodeFilter }, Zv); function Zv(e) { return Xv.call(this, { getNodesToFilter: function (t) { return t.getNodes().filter(function (t) { return !e(t) }) }, getEdgesToFilter: function (t, e) { return e.getAdjacentEdges() } }) || this } var Kv, Qv = (b(Jv, Kv = qv), Jv.prototype.getName = function () { return Gv.EdgeFilter }, Jv); function Jv(e) { return Kv.call(this, { getNodesToFilter: function (t) { return t.createNodeList() }, getEdgesToFilter: function (t) { return t.getEdges().filter(function (t) { return !e(t) }) } }) || this } function $v(t) { return "object" != typeof t ? { criteria: t, enabled: !0, duration: 0 } : t } var tm, em = (b(im, tm = Ae), im.prototype.addNodeFilter = function (t) { var e = $v(t), i = e.criteria, n = x(e, ["criteria"]); return this._transformations.add(new Yv(i), n) }, im.prototype.addEdgeFilter = function (t) { var e = $v(t), i = e.criteria, n = x(e, ["criteria"]); return this._transformations.add(new Qv(i), n) }, im); function im(t) { var e = t.transformations, i = tm.call(this) || this; return i._transformations = e, i } var nm = (rm.prototype.destroy = function () { var i = this; Object.keys(this).forEach(function (t) { var e = i[t]; e instanceof Ae && e.destroy(i._ogma) }) }, rm); function rm(t, i) { var n = this; this._ogma = t, "webgl" === yh && Va.cacheInitData(Va.createInitData()), this.settings = new Fh, this.events = new wh, this.dom = new Ce(this, i.dimensions), this.animations = new rf(this), this.camera = new fh(this), this.graph = new an(this, t), this.data = new Le(this), this.graphics = new bh(this, t), this.individualAttributes = new Nh(this), this.algorithms = new Mf(this), this.position = new Fv, this.touch = new Tc(this), this.mouse = new Ec(this), this.virtualMouse = new Vg(this), this.spatial = new hc(this), this.captor = new i_(this), this.interactions = new Wp(this), this.classes = new Bh(this), this.cameraInteractions = new __(this, !!i.debug), this.hover = new kv(this), this.keyboard = new G_(this), this.selection = new jc(this), this.styleRules = new ep(this), this.legend = new Cv(this), this.sync = new qc(this), this.rules = new Vv(this), this.transformations = new Pc(this, t), this.filters = new em(this), this.locate = new _c(this), this.grouping = new Ic(this), this.pulses = new Jc(this), this.drag = new l_(this), this.curvatureManager = new Nf(this), this.tasks = new Jf(this), this.layouts = new sg(this), this.watcher = new Ag(this), this.pathfinding = new Pg(this), this.rectangleSelect = new dp(this), this.labels = new Up(this, i), this.brand = new gf(this), this.lasso = new sp(this), this.rewiring = new b_(this), this.resizing = new S_(this), this.snapping = new Kg(this), this.connectNodes = new L_(this), this.tooltip = new D_(this), this.geo = new mf(this), t.onReady(function () { Object.keys(n).forEach(function (t) { var e = n[t]; e instanceof Ae && e.onMounted(n._ogma, i) }) }) } var om = (sm.initNamespace = function (t) { var r; t.algorithms = (r = t, { shortestPath: function (t) { return r.modules.algorithms.shortestPath(t) }, hasCycle: function (t) { var e = void 0 === t ? {} : t, i = e.nodes, n = e.edges; return null !== r.algorithms.detectCycle({ nodes: i, edges: n }) }, getAllSimpleCycles: function (t) { var e = void 0 === t ? {} : t, i = e.nodes, n = e.edges; return i = i || r.getNodes(), n = n || i.getAdjacentEdges({ bothExtremities: !0 }), r.modules.algorithms.getAllSimpleCycles(i, n) }, detectCycle: function (t) { var e = void 0 === t ? {} : t, i = e.nodes, n = e.edges; return i = i || r.getNodes(), n = n || i.getAdjacentEdges({ bothExtremities: !0 }), r.modules.algorithms.detectCycle(i, n) } }) }, sm); function sm() { } var am = (um.prototype.createClass = function (t, e) { return this.modules.classes.createClass(Object.assign({}, e, { name: t })) }, um.prototype.updateClass = function (t, e) { return this.modules.classes.getClassByName(t, !0).update(e) }, um.prototype.getNodesByClassName = function (t) { return this.modules.classes.getClassByName(t, !0).getNodes() }, um.prototype.getEdgesByClassName = function (t) { return this.modules.classes.getClassByName(t, !0).getEdges() }, um); function um() { } var lm = (dm.prototype.getHoveredElement = function () { return this.modules.captor.getPointedElement() }, dm.prototype.getPointerInformation = function () { return this.modules.captor.getCursorInformation() }, dm); function dm() { } var hm = (cm.initNamespace = function (t) { var d; t.debug = (d = t, { wait: function (e) { return new Promise(function (t) { return setTimeout(t, e) }) }, initRandomGraph: function (t) { return d.generate.random(t).then(d.setGraph).then(function () { return d.view.locateGraph() }).then(function () { return d.view.afterNextFrame() }) }, initGrid: function (t) { var e = Math.ceil(Math.sqrt(t)); return d.generate.grid({ rows: e, columns: e }).then(function (t) { return d.setGraph(t) }).then(function () { return d.view.locateGraph() }) }, initLine: function (t) { return d.setGraph({ nodes: [{ id: 0, attributes: { x: 0, y: 0 } }, { id: 1, attributes: t ? { x: 0, y: 50 } : { x: 50, y: 0 } }], edges: [{ id: 0, source: 1, target: 0 }] }), d.view.locateGraph() }, initSingleNode: function () { return d.setGraph({ nodes: [{ id: 0, attributes: { x: 0, y: 0 } }], edges: [] }), d.view.locateGraph() }, initContinuousRenderLoop: function (t) { var e = void 0 === t ? {} : t, i = e.triggerKey, n = void 0 === i ? "r" : i, r = e.start, o = void 0 === r || r, s = function () { o && d.modules.dom.beforeNextFrame().then(s) }; document.addEventListener("keydown", function (t) { t.key === n && (o = !o, s()) }), s() }, appendToBody: function () { var t = document.createElement("div"); t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.bottom = "0", t.style.right = "0", document.body.appendChild(t), d.setContainer(t) }, loadFile: function (t) { return (t.endsWith(".gexf") ? d.parse.gexfFromUrl(t) : d.parse.jsonFromUrl(t)).then(function (t) { return d.setGraph(t) }).then(function () { return d.view.locateGraph() }).then(function () { return d.view.afterNextFrame() }) }, enableLasso: function (t) { d.events.onDragStart(function () { d.keyboard.isKeyPressed("ctrl") && d.tools.lasso.enable(t) }) }, randomizeGraph: function (t) { var e = void 0 === t ? {} : t, i = e.minX, n = void 0 === i ? 0 : i, r = e.minY, o = void 0 === r ? 0 : r, s = e.maxX, a = void 0 === s ? 500 : s, u = e.maxY, l = void 0 === u ? 500 : u; return d.getNodes().setAttributes(d.getNodes().map(function () { return { x: n + Math.random() * (a - n), y: o + Math.random() * (l - o) } })) } }) }, cm); function cm() { } var fm = (gm.prototype.setContainer = function (t) { this.modules.dom.setContainer(t) }, gm.prototype.getContainer = function () { return this.modules.dom.getContainer() }, gm); function gm() { } var pm = (_m.initNamespace = function (t) { var i; t.events = (i = t, { removeListener: function (t) { i.modules.events.removeListener(t) }, onNodesAdded: function (t) { return i.modules.events.on(xe.ADD_NODES, t), i }, onBeforeNodesRemoved: function (t) { return i.modules.events.on(xe.BEFORE_REMOVE_NODES, t), i }, onNodesRemoved: function (t) { return i.modules.events.on(xe.REMOVE_NODES, t), i }, onEdgesAdded: function (t) { return i.modules.events.on(xe.ADD_EDGES, t), i }, onBeforeEdgesRemoved: function (t) { return i.modules.events.on(xe.BEFORE_REMOVE_EDGES, t), i }, onEdgesRemoved: function (t) { return i.modules.events.on(xe.REMOVE_EDGES, t), i }, onNodesClassAdded: function (t, e) { return i.modules.classes.onNodeClassAdded(t, e), i }, onNodesClassRemoved: function (t, e) { return i.modules.classes.onNodeClassRemoved(t, e), i }, onEdgesClassAdded: function (t, e) { return i.modules.classes.onEdgeClassAdded(t, e), i }, onEdgesClassRemoved: function (t, e) { return i.modules.classes.onEdgeClassRemoved(t, e), i }, onNodeDragStart: function (t) { return i.modules.events.on(xe.NODES_DRAG_START, t), i }, onNodeDragProgress: function (t) { return i.modules.events.on(xe.NODES_DRAG_PROGRESS, t), i }, onNodeDragEnd: function (t) { return i.modules.events.on(xe.NODES_DRAG_END, t), i }, onKeyPress: function (t, e) { return i.modules.keyboard.onKeyPress(t, e), i }, onNodesSelected: function (t) { return i.events.onNodesClassAdded(ll, t) }, onNodesUnselected: function (t) { return i.events.onNodesClassRemoved(ll, t) }, onEdgesSelected: function (t) { return i.events.onEdgesClassAdded(ll, t) }, onEdgesUnselected: function (t) { return i.events.onEdgesClassRemoved(ll, t) }, onNodeDataChange: function (t) { return i.modules.events.on(xe.UPDATE_NODE_DATA, t), i }, onEdgeDataChange: function (t) { return i.modules.events.on(xe.UPDATE_EDGE_DATA, t), i }, onMouseMove: function (t) { return i.modules.events.on(xe.MOVE, t), i }, onMouseButtonDown: function (t) { return i.modules.events.on(xe.DOWN, t), i }, onMouseButtonUp: function (t) { return i.modules.events.on(xe.UP, t), i }, onClick: function (t) { return i.modules.events.on(xe.CLICK, t), i }, onDoubleClick: function (t) { return i.modules.events.on(xe.DOUBLE_CLICK, t), i }, onMouseWheel: function (t) { return i.modules.events.on(xe.WHEEL, t), i }, onHover: function (t) { return i.modules.events.on(xe.HOVER, t), i }, onUnhover: function (t) { return i.modules.events.on(xe.UNHOVER, t), i }, onDragStart: function (t) { return i.modules.events.on(xe.DRAG_START, t), i }, onDragProgress: function (t) { return i.modules.events.on(xe.DRAG_PROGRESS, t), i }, onDragEnd: function (t) { return i.modules.events.on(xe.DRAG_END, t), i }, onGestureStart: function (t) { return i.modules.events.on(xe.GESTURE_START, t), i }, onGestureProgress: function (t) { return i.modules.events.on(xe.GESTURE_PROGRESS, t), i }, onGestureEnd: function (t) { return i.modules.events.on(xe.GESTURE_END, t), i }, onRendererStateChange: function (t) { return i.modules.events.on(xe.RENDERER_STATE_CHANGE, t), i }, onZoomProgress: function (t) { return i.modules.events.on(xe.CAMERA_ZOOM, t), i }, onViewChanged: function (t) { return i.modules.events.on(xe.VIEW_CHANGED, t), i }, onNodesConnected: function (t) { return i.modules.events.on(xe.CONNECT_NODES, t), i }, onGeoModeEnabled: function (t) { return i.modules.events.on(xe.GEO_ENABLED, t), i }, onGeoModeDisabled: function (t) { return i.modules.events.on(xe.GEO_DISABLED, t), i }, onGeoModeLoaded: function (t) { return i.modules.events.on(xe.GEO_LOADED, t), i }, onLayoutStart: function (t) { return i.modules.events.on(xe.LAYOUT_START, t), i }, onLayoutComplete: function (t) { return i.modules.events.on(xe.LAYOUT_END, t), i }, onLayoutComputed: function (t) { return i.modules.events.on(xe.LAYOUT_COMPUTED, t), i }, onTooltipShown: function (t) { return i.modules.events.on(xe.TOOLTIP_SHOW, t), i }, onTooltipHidden: function (t) { return i.modules.events.on(xe.TOOLTIP_HIDE, t), i } }) }, _m); function _m() { } function vm(t) { return t instanceof Ji ? t.getId() : t } function mm(t) { return t instanceof Fi ? t.getId() : t } function ym(t) { return t instanceof tn ? t.getId() : t instanceof Ji ? [t.getId()] : I(t) ? t.map(vm) : [vm(t)] } function bm(t) { return t instanceof Pi ? t.getId() : t instanceof Fi ? [t.getId()] : I(t) ? t.map(mm) : [mm(t)] } function xm(t, e, i) { if (null != t) return Array.isArray(t) ? t[0] : "source" === t ? xm(i.color.get(e.getSource()._index)) : "target" === t ? xm(i.color.get(e.getTarget()._index)) : t } function Em(t) { return null == t ? null : "string" == typeof t || "number" == typeof t ? "" + t : t && Em(t.content) } var Am = ["color", "radius", "shape", "text.content", "x", "y"], Sm = ["color", "width", "shape.type", "text.content"]; function wm(t) { return { nodes: t.nodes.map(function (t) { var e = t.id, i = t.attributes, n = void 0 === i ? {} : i, r = t.data, o = n.color, s = n.radius, a = n.shape, u = n.text; return { id: e, x: n.x, y: n.y, color: xm(o), size: s, shape: a, text: Em(u), data: r } }), edges: t.edges.map(function (t) { var e = t.id, i = t.source, n = t.target, r = t.attributes, o = void 0 === r ? {} : r, s = t.data, a = o.color, u = o.width, l = o.text, d = o.shape; return { id: e, source: i, target: n, color: xm(a), size: u, shape: function (t) { if (null != t) return "string" == typeof t ? t : t.type }(d), text: Em(l), data: s } }) } } function Tm(t, e, i, n) { var r, o, s, a, u = (o = n, (r = e) ? ym(r) : "object" == typeof o ? ym(o.nodes) : o), l = (a = n, (s = i) ? bm(s) : "object" == typeof a ? bm(a.edges) : a); return { nodes: t.getNodes(u), edges: t.getEdges(l) } } function Cm(t, e) { var i = e.nodeAttributes, n = e.edgeAttributes, r = e.nodes, o = e.edges, s = e.filter, a = e.nodeData, u = e.edgeData, l = Tm(t, r, o, s); return { nodes: l.nodes.toJSON({ attributes: i, data: a }), edges: l.edges.toJSON({ attributes: n, data: u }) } } function Mm(r, t, e) { var i, n, o, s, a, u = e.styles, l = e.nodes, d = e.edges, h = e.filter, c = e.nodeData, f = e.edgeData, g = "all" !== u ? { nodes: ["x", "y"], edges: [] } : { nodes: Am, edges: Sm }, p = Cm(r, { nodeAttributes: g.nodes, edgeAttributes: g.edges, nodes: l, edges: d, filter: h, nodeData: c, edgeData: f }); if ("original" === u) { for (var _ = (i = t, n = Tm(r, l, d, h), o = n.nodes, s = n.edges, a = i.getOriginalAttributes(), { nodes: o.reduce(function (t, e) { return t[e.getId()] = { x: a.nodes.x.get(e._index), y: a.nodes.y.get(e._index), color: xm(a.nodes.color.get(e._index)), radius: a.nodes.radius.get(e._index), shape: a.nodes.shape.get(e._index), text: { content: a.nodes.text.content.get(e._index) } }, t }, {}), edges: s.reduce(function (t, e) { return t[e.getId()] = { color: xm(a.edges.color.get(e._index)), width: a.edges.width.get(e._index), shape: { type: a.edges.shape.type.get(e._index) }, text: { content: a.edges.text.content.get(e._index) } }, t }, {}) }), v = 0, m = p.nodes; v < m.length; v++) { var y = m[v]; y.attributes = _[y.id] } for (var b = 0, x = p.edges; b < x.length; b++) { var E = x[b]; E.attributes = _[E.id] } } return "all" === u && p.edges.forEach(function (t) { var e = t.source, i = t.target, n = t.attributes; "source" === n.color && (n.color = r.getNode(e).getAttribute("color")), "target" === n.color && (n.color = r.getNode(i).getAttribute("color")) }), wm(p) } function Im(value, t) { return null == value || Array.isArray(value) && !value.length ? t : value } function Lm(t) { return "string" == typeof t } function Nm(t, e, i, n) { for (var s = "edges" === e, a = {}, r = function (r) { var t = L(Im(i(r), e)); if (!t.every(Lm)) throw Error("The tab " + e + " function returned an invalid value."); var o = L(n(r.data, t)); t.forEach(function (t, e) { var i = Im(o[e], {}), n = uo(C({}, i, { id: r.id }, s ? { source: r.source, target: r.target } : {})).reduce(function (t, e) { var i = e.path, value = e.value; return t[i.join(".")] = value, t }, {}); a[t] = a[t] || [], a[t].push(n) }) }, o = 0, u = t; o < u.length; o++) { r(u[o]) } return a } function km(t) { if (!t.length) return []; for (var e = function (t) { for (var e = C({}, t[0]), i = 0, n = t; i < n.length; i++)for (var r = n[i], o = 0, s = Object.keys(r); o < s.length; o++) { var a = s[o]; a in e || (e[a] = void 0) } return Object.keys(e) }(t), i = -1 < e.indexOf("source") ? ["id", "source", "target"] : ["id"], n = i.concat(e.filter(function (t) { return -1 === i.indexOf(t) })), r = [n], o = function (e) { r.push(n.map(function (t) { return e[t] })) }, s = 0, a = t; s < a.length; s++) { o(a[s]) } return r } function Om(l, d, h) { for (var c = new lo, f = d ? 1 : 3, g = [], t = function (t) { var e = l[t], i = new Array(f), n = e.data; if (h) { var r = {}; h.forEach(function (t) { var e = F(t), value = function (t, e) { for (var i = 0; i < e.length; ++i) { if (null == t) return; t = t[e[i]] } return t }(n, e); !function (t, e, value) { for (var i = 0; i < e.length - 1; ++i) { var n = e[i], r = t[n]; void 0 === r && (r = {}, t[n] = r), t = r } t[e[e.length - 1]] = value }(r, e, value) }), n = r } var o = uo(n); i[0] = e.id, d || (i[1] = e.source, i[2] = e.target); for (var s = 0; s < o.length; ++s) { var a = o[s], u = a.path, value = a.value; u.length && (c.has(u) ? i[c.get(u)] = value : (c.set(u, f), i[f] = value, f++)) } g.push(i) }, e = 0; e < l.length; ++e)t(e); var i = []; return i.push("id"), d || (i.push("source"), i.push("target")), c.keys().forEach(function (t) { return i.push(t[t.length - 1]) }), g.unshift(i), g.forEach(function (t) { return t.length = f }), g } function Fm(p) { return { csv: function (t) { var e = Q("string" == typeof t ? { what: t } : t, Rm), i = e.what, n = e.dataProperties, r = e.nodes, o = e.edges, s = e.separator, a = e.textSeparator, u = e.download, l = e.nodeData, d = e.edgeData, h = e.filename, c = e.filter, f = Mm(p.modules.graph, p.modules.individualAttributes, { styles: "none", nodes: r, edges: o, filter: c, nodeData: l, edgeData: d }); try { var g = function (t, e) { var i = e.what, n = e.separator, r = e.textSeparator, o = e.dataProperties, s = new RegExp("" + r, "g"); function a(t) { return t = function (t) { if (t instanceof Date) return t.toISOString(); return "" + t }(t), t = r + t.replace(s, "\\$&") + r } if (r && '"' !== r && "'" !== r) throw new TypeError('Invalid argument :"textSeparator" is not single-quote or double-quote, was ' + r); if ("nodes" !== i && "edges" !== i) throw new TypeError('missing argument: "what": should have value "nodes" or "edges"'); var u = "nodes" === i; return Om(u ? t.nodes : t.edges, u, o).map(function (t) { return t.map(function (value) { return a(value) }) }).map(function (t) { return t.join(n) }).join("\n") }(f, { what: i, separator: s, textSeparator: a, dataProperties: n }); return u && It(g, h, "text"), Promise.resolve(g) } catch (t) { return Promise.reject(t) } } } } var Rm = { what: void 0, dataProperties: void 0, separator: ",", textSeparator: '"', download: !0, filename: "graph.csv", filter: "visible", nodes: void 0, edges: void 0, nodeData: function (t) { return t }, edgeData: function (t) { return t }, styles: "none" }; function Pm(f) { return { gexf: function (t) { void 0 === t && (t = {}); var e = Q(t, Dm), i = e.styles, n = e.nodes, r = e.edges, o = e.download, s = e.filename, a = e.creator, u = e.description, l = e.filter, d = e.nodeData, h = e.edgeData, c = function (t, e) { var i, u = new _n, l = ko(), d = {}, a = {}, h = 0, c = 0, n = l.createElement("gexf"); n.setAttribute("xmlns", "http://www.gexf.net/1.2draft"), n.setAttribute("xmlns:viz", "http://www.gexf.net/1.2draft/viz"), n.setAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"), n.setAttribute("xsi:schemaLocation", "http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd"), n.setAttribute("version", "1.2"); var r = l.createElement("meta"); if (r.setAttribute("lastmodifieddate", Qt()), e.creator) { var o = l.createElement("creator"); i = l.createTextNode("" + e.creator), o.appendChild(i), r.appendChild(o) } if (e.description) { var s = l.createElement("description"); i = l.createTextNode("" + e.description), s.appendChild(i), r.appendChild(s) } var f = l.createElement("graph"); f.setAttribute("mode", "static"); var g = l.createElement("nodes"); t.nodes.forEach(function (t) { var e = l.createElement("node"); if (e.setAttribute("id", String(t.id)), t.text && e.setAttribute("label", Ht(t.text)), Um(t.data)) { var n = Vm(t.data), r = l.createElement("attvalues"); Object.keys(n).forEach(function (t) { t in d || (d[t] = { id: h, type: "integer" }, h++); var e = n[t]; d[t].type = Bm(e, d[t].type); var i = l.createElement("attvalue"); i.setAttribute("for", d[t].id), i.setAttribute("value", Ht(e)), r.appendChild(i) }), e.appendChild(r) } if (t.color) { var i = u.parseColor(t.color), o = l.createElement("viz:color"); o.setAttribute("r", zm(i[0])), o.setAttribute("g", zm(i[1])), o.setAttribute("b", zm(i[2])), o.setAttribute("a", i[3]), e.appendChild(o) } var s = l.createElement("viz:position"); if (s.setAttribute("x", t.x), s.setAttribute("y", -t.y), e.appendChild(s), t.size) { var a = l.createElement("viz:size"); a.setAttribute("value", t.size), e.appendChild(a) } g.appendChild(e) }); var p = l.createElement("attributes"); p.setAttribute("class", "node"), Object.keys(d).forEach(function (t) { var e = l.createElement("attribute"); e.setAttribute("id", d[t].id), e.setAttribute("title", t), e.setAttribute("type", d[t].type), p.appendChild(e) }); var _ = l.createElement("edges"); t.edges.forEach(function (t) { var e = l.createElement("edge"); if (e.setAttribute("id", t.id.toString()), e.setAttribute("source", t.source), e.setAttribute("target", t.target), t.size && e.setAttribute("weight", t.size), t.text && e.setAttribute("label", Ht(t.text)), Um(t.data)) { var n = Vm(t.data), r = l.createElement("attvalues"); Object.keys(n).forEach(function (t) { t in a || (a[t] = { id: c, type: "integer" }, c++); var e = n[t]; a[t].type = Bm(e, a[t].type); var i = l.createElement("attvalue"); i.setAttribute("for", a[t].id), i.setAttribute("value", Ht(e)), r.appendChild(i) }), e.appendChild(r) } if (t.color) { var i = u.parseColor(t.color), o = l.createElement("viz:color"); o.setAttribute("r", zm(i[0])), o.setAttribute("g", zm(i[1])), o.setAttribute("b", zm(i[2])), o.setAttribute("a", i[3]), e.appendChild(o) } if (t.size) { var s = l.createElement("viz:size"); s.setAttribute("value", t.size), e.appendChild(s) } _.appendChild(e) }); var v = l.createElement("attributes"); return v.setAttribute("class", "edge"), Object.keys(a).forEach(function (t) { var e = l.createElement("attribute"); e.setAttribute("id", a[t].id), e.setAttribute("title", t), e.setAttribute("type", a[t].type), v.appendChild(e) }), f.appendChild(p), f.appendChild(v), f.appendChild(g), f.appendChild(_), n.appendChild(r), n.appendChild(f), l.appendChild(n), '<?xml version="1.0" encoding="UTF-8"?>' + l.serialize() }(Mm(f.modules.graph, f.modules.individualAttributes, { styles: i, nodes: n, edges: r, filter: l, nodeData: d, edgeData: h }), { creator: a, description: u }); return o && It(c, s, "text"), Promise.resolve(c) } } } var Dm = { creator: void 0, description: void 0, styles: "all", download: !0, filename: "graph.gexf", nodes: void 0, edges: void 0, nodeData: function (t) { return t }, edgeData: function (t) { return t }, filter: "visible" }; function zm(value) { return Math.round(255 * value) } function Bm(t, e) { if ("integer" === e && "number" == typeof t) { if (t % 1 != 0) return "float" } else if ("number" != typeof t) return "boolean" == typeof t ? "boolean" : "string"; return e } function Um(value) { return "object" == typeof value && null !== value && value.constructor === Object } function Vm(t, e) { return void 0 === e && (e = {}), V(t, function (value, t) { Um(value) ? Vm(value, e) : e[t] = value }), e } function jm(f) { return { graphml: function (t) { void 0 === t && (t = {}); var e = Q(t, Gm), i = e.styles, n = e.nodes, r = e.edges, o = e.download, s = e.filename, a = e.graphId, u = e.directedEdges, l = e.filter, d = e.nodeData, h = e.edgeData, c = function (t, o) { var r = new _n, s = Fo(); function a(t) { return r.toHexa(t) } function u(t, e) { var i, n = (i = e, r.parseColor(i)); t.r = n[0], t.g = n[1], t.b = n[2] } function l(t, e, i, n, force) { i = i || {}; var r = s.createElement(e); for (var o in i) if (i.hasOwnProperty(o)) { var value = i[o]; void 0 !== value && r.setAttribute(o, value) } return void 0 === n && !force || ("[object Object]" === Object.prototype.toString.call(n) && (n = JSON.stringify(n)), r.appendChild(s.createTextNode(n))), t.appendChild(r), r } var d = ["id", "source", "target"], h = ["size", "x", "y", "shape", "text", "color"], c = { size: { for: "all", type: "double" }, x: { for: "node", type: "double" }, y: { for: "node", type: "double" }, shape: { for: "all", type: "string" }, color: { for: "all", type: "string" }, r: { for: "all", type: "int" }, g: { for: "all", type: "int" }, b: { for: "all", type: "int" }, a: { for: "all", type: "double" }, text: { for: "all", type: "string" } }; o.noStyles && (delete c.color, delete c.r, delete c.g, delete c.b, delete c.a, delete c.shape, h.pop()); var f = [], g = []; function e(e, i) { var n = { id: e.id }; h.forEach(function (t) { var value = e[t]; "y" === t && value && (value = -parseFloat(value)), void 0 !== value && (n[("edge" === i ? "edge_" : "") + t] = value, "color" === t && u(n, value)) }), V(e.data || {}, function (value, t) { -1 === h.indexOf(t) && -1 === d.indexOf(t) && (c[t] ? c[t].for !== i && (c[t].for = "all") : c[t] = { for: i, type: "string" }, n[t] = value) }), "edge" === i ? (n.source = e.source, n.target = e.target, g.push(n)) : f.push(n) } t.nodes.forEach(function (t) { return e(t, "node") }), t.edges.forEach(function (t) { return e(t, "edge") }); var i = l(s, "graphml", { xmlns: "http://graphml.graphdrawing.org/xmlns", "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation": "http://graphml.graphdrawing.org/xmlns http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd", "xmlns:y": "http://www.yworks.com/xml/graphml", "xmlns:java": "http://www.yworks.com/xml/yfiles-common/1.0/java", "xmlns:sys": "http://www.yworks.com/xml/yfiles-common/markup/primitives/2.0", "xmlns:x": "http://ww.yworks.com/xml/yfiles-common/markup/2.0" }); V(c, function (value, t) { "node" !== value.for && "all" !== value.for || l(i, "key", { "attr.name": t, "attr.type": value.type, for: "node", id: t }), "edge" !== value.for && "all" !== value.for || l(i, "key", { "attr.name": t, "attr.type": value.type, for: "edge", id: "edge_" + t }) }), l(i, "key", { id: "nodegraphics", for: "node", "yfiles.type": "nodegraphics", "attr.type": "string" }), l(i, "key", { id: "edgegraphics", for: "edge", "yfiles.type": "edgegraphics", "attr.type": "string" }); var p = l(i, "graph", { edgedefault: o.directedEdges || void 0 === o.directedEdges ? "directed" : "undirected", id: o.graphId ? o.graphId : "G", "parse.nodes": t.nodes.length, "parse.edges": t.edges.length, "parse.order": "nodesfirst" }); return f.forEach(function (t) { var e = l(p, "node", { id: t.id }); !function (t, e) { var i = l(t, "data", { key: "nodegraphics" }), n = l(i, "y:ShapeNode"); l(n, "y:Geometry", { x: e.x, y: e.y, width: e.size, height: e.size }), o.noStyles || l(n, "y:Fill", { color: a(e.color), transparent: !1 }); l(n, "y:NodeLabel", null, e.text || ""), l(n, "y:Shape", { type: e.shape }) }(e, t), V(t, function (value, t) { -1 === d.indexOf(t) && l(e, "data", { key: t }, value, !0) }) }), g.forEach(function (t) { var e, i, n, r = l(p, "edge", { id: t.id, source: t.source, target: t.target }); e = t, i = l(r, "data", { key: "edgegraphics" }), n = l(i, "y:PolyLineEdge"), l(n, "y:LineStyle", { type: e.edge_type, color: o.noStyles ? void 0 : a(e.edge_color), width: e.edge_size }), l(n, "y:EdgeLabel", null, e.edge_label), V(t, function (value, t) { -1 === d.indexOf(t) && l(r, "data", { key: t }, value, !0) }) }), '<?xml version="1.0" encoding="UTF-8"?>\n' + Oo(s) }(Mm(f.modules.graph, f.modules.individualAttributes, { styles: i, nodes: n, edges: r, filter: l, nodeData: d, edgeData: h }), { graphId: a, directedEdges: u, noStyles: "none" === i }); return o && It(c, s, "text"), Promise.resolve(c) } } } var Gm = { graphId: "G", directedEdges: !0, styles: "all", download: !0, filename: "graph.graphml", nodes: void 0, edges: void 0, nodeData: function (t) { return t }, edgeData: function (t) { return t }, filter: "visible" }; var Hm = { nodeAttributes: ["x", "y", "color", "radius", "shape", "text"], edgeAttributes: ["color", "width", "text"], nodeData: function (t) { return t }, edgeData: function (t) { return t }, filter: "visible", pretty: !1, download: !0, filename: "graph.json" }; function qm(t, e) { var i = t.view.get(), n = "number" == typeof e.margin ? e.margin : 0, r = { pixelRatio: 1, angle: 0, backgroundColor: null, zoom: 0, x: 0, y: 0, width: 0, height: 0, hideImages: !1 }; if (e.width && e.height ? (r.width = e.width, r.height = e.height) : (r.width = i.width, r.height = i.height), e.clip) r.zoom = i.zoom, r.x = i.x, r.y = i.y; else { var o = t.getNodes(e.filter), s = o.getBoundingBox().computeForZoom(i.zoom).extend(Uo.fromValues(o.getAttribute("x"), o.getAttribute("y"), o.map(function (t) { return t.getAttribute("radius") + t.getAttribute("innerStroke.width") + t.getAttribute("outerStroke.width") }))); if (e.texts) { var a = t.modules.labels.getTextsBoundingBox(); a.isValid() && s.extend(a) } if (!isFinite(e.width) || !isFinite(e.height)) { var u = t.view.graphToScreenCoordinates(s.bottomLeft()), l = t.view.graphToScreenCoordinates(s.topRight()), d = l.x - u.x, h = l.y - u.y, c = Math.min(r.width / d, r.height / h); r.width = d * c, r.height = h * c } r.x = s.cx, r.y = s.cy, r.width = Math.max(r.width, 2 * n + 1), r.height = Math.max(r.height, 2 * n + 1), r.zoom = Math.min((r.width - 2 * n) / s.width, (r.height - 2 * n) / s.height) } return t.modules.geo.isEnabled() ? r.backgroundColor = null : void 0 !== e.background && (r.backgroundColor = e.background), r } function Wm(t, e, i, n, r) { void 0 === r && (r = !1); var o = C({}, i, { renderBackground: !1, hideImages: r, angle: i.angle || 0, isBufferDisplayable: function (t) { return e.texts || !Rl(t) } }), s = {}; if (!1 === e.badges) { var a = { text: null, image: null }; s.badges = { topLeft: a, topRight: a, bottomRight: a, bottomLeft: a } } return t.styles.getClass(fl).update({ nodeAttributes: s }), t.modules.graphics.export(n, o, e.filter, e) } function Xm(t) { return { download: !0, filter: "visible", filename: "graph." + t, clip: !1, margin: 10, width: void 0, height: void 0, background: null, badges: !0, legend: void 0, texts: !0, images: !0, textWatermark: { content: null, fontFamily: "Arial", fontSize: 48, fontStyle: null, fontColor: "red", repeat: !1, angle: 0, alpha: .65, space: 50, x: void 0, y: void 0 }, imageWatermark: { url: null, width: void 0, height: void 0, repeat: !1, angle: 0, alpha: .65, space: 50, x: void 0, y: void 0 }, imageCrossOrigin: void 0 } } var Ym = { png: Xm("png"), jpg: Xm("jpg"), tiff: Xm("tiff"), gif: Xm("gif") }; function Zm(e) { var i = e.canvas, n = e.parameters; return n.textWatermark.content && sy(i, n.textWatermark, iy, ny), n.imageWatermark.url ? Dt(n.imageWatermark.url).then(function (t) { return t && (n.imageWatermark.content = t, sy(i, n.imageWatermark, oy, ry)), e }) : e } function Km(t) { var e = t.ogma, i = t.canvas, n = t.parameters, r = e.modules.legend, o = null; return void 0 === n.legend && (o = !!r.enabled() && r.getCurrentOptions()), !0 === n.legend && (o = {}), o && r.exportOnCanvas(i, o), t } function Qm(n) { var t = n.ogma, r = n.view; return t.modules.geo.isEnabled() ? t.modules.geo.exportBackground(r).then(function (t) { var e = ty(n.view), i = e.getContext("2d"); return i.drawImage(t, (r.width - t.width) / 2, (r.height - t.height) / 2), i.drawImage(n.canvas, 0, 0), n.canvas = e, n }) : n } function Jm(e) { var i = e.ogma, n = e.parameters, t = e.canvas, r = e.view, o = t.getContext("2d"); return Wm(i, n, r, "canvas", !n.images).then(function (t) { try { return t.getContext("2d").getImageData(0, 0, 1, 1), o.drawImage(t, 0, 0), e } catch (t) { return hi(t), Wm(i, n, r, "canvas", !0).then(function (t) { return o.drawImage(t, 0, 0), e }) } }) } function $m(t) { var e = t.canvas, i = t.parameters, n = t.type, r = e.toDataURL("image/" + n); return i.download && It(r, i.filename, "dataURL"), r } function ty(t) { var e = t.width, i = t.height, n = nr(); return n.width = e, n.height = i, n } function ey(t, e, i) { null === (e = Q(e, Ym[i])).background && (e.background = t.modules.graphics.getTransparentBackgroundColor()); var n = qm(t, e), r = { ogma: t, parameters: e, canvas: ty(n), view: n, type: i }; return Promise.resolve(r).then(Qm).then(Jm).then(Zm).then(Km).then($m) } function iy(t, e, i, n) { t.textAlign = "center", t.textBaseline = "middle", t.fillText(e, i, n) } function ny(t, e, i) { return { width: t.measureText(e).width, height: i } } function ry(t, e, i, n, r) { return { width: void 0 === n ? e.width : n, height: void 0 === r ? e.height : r } } function oy(t, e, i, n, r, o) { t.drawImage(e, i - r / 2, n - o / 2, r, o) } function sy(t, e, i, n) { if (e) { if ("object" != typeof e) e = { content: e }; else if (!e.content) return; var r = e.fontFamily, o = e.fontSize, s = e.fontStyle, a = e.fontColor, u = e.repeat, l = e.angle, d = e.alpha, h = e.space, c = e.content, f = t.getContext("2d"), g = t.width, p = t.height, _ = void 0 === e.x ? g / 2 : e.x, v = void 0 === e.y ? p / 2 : e.y, m = e.height, y = e.width; l = l / 180 * Math.PI, or(f, r, o, s), f.fillStyle = a, f.globalAlpha = d; var b = n(f, c, o, y, m); if (u) { var x = b.width + h, E = b.height + h, A = Math.sqrt(g * g + p * p); f.save(), f.translate(0, 0), f.rotate(l); for (var S = 0; S < A; S += x)for (var w = 0; w < A; w += E)i(f, c, S, w, b.width, b.height), 0 !== w && i(f, c, S, -w, b.width, b.height); f.restore() } else f.save(), f.translate(_, v), f.rotate(l), i(f, c, 0, 0, b.width, b.height), f.restore() } } function ay(e) { return { svg: function (t) { return void 0 === t && (t = {}), function (e, r) { var t = (r = Q(r, uy)).background, i = r.filename, n = r.download, o = e.modules.graphics; null === t && (r.background = o.getTransparentBackgroundColor()); var s = qm(e, r); return Wm(e, r, s, "svg", !r.images).then(function (t) { return t.removeAttribute("pointer-events"), t.setAttribute("version", "1.1"), t.setAttributeNS(Ot, "xmlns", kt), t.setAttributeNS(Ot, "xmlns:xlink", Ft), t }).then(function (t) { return function (t, e, i) { for (var n = e.childNodes[2], r = n.childNodes, o = {}, s = i.prefix, a = 0; a < r.length; a++) { var u = (E = r[a]).getAttribute(pa); o[u] = o[u] || [], o[u].push(E) } var l = Object.keys(o), d = t.modules.graph, h = d.getNodeAttribute("id"), c = d.getEdgeAttribute("id"), f = Rt("g", { class: s + "-edges" }), g = Rt("g", { class: s + "-nodes" }); for (a = 0; a < l.length; a++) { var p = l[a], _ = "n" === p.charAt(0), v = parseInt(p.substring(1)), m = o[p], y = Ht((_ ? h : c).get(v).toString()), b = Rt("g"); b.setAttribute("data-" + (_ ? "node" : "edge") + "-id", y), b.setAttribute("class", s + "-" + (_ ? "node" : "edge")); for (var x = 0; x < m.length; x++) { var E = m[x]; b.appendChild(E), E.removeAttribute(pa) } (_ ? g : f).appendChild(b) } return n.appendChild(f), n.appendChild(g), e }(e, t, r) }).then(function (t) { return e = r, i = function (t) { for (var e = [].concat(Array.prototype.slice.call(t.getElementsByTagName("text") || []), Array.prototype.slice.call(t.getElementsByTagName("tspan") || [])), i = [], n = {}, r = 0; r < e.length; r++) { var o = e[r].getAttribute("font-family"); if ("string" == typeof o) for (var s = o.split(","), a = 0; a < s.length; a++) { var u = s[a].replace(/['"]/g, ""); "" === u || n[u] || (n[u] = !0, i.push(u)) } } return { list: i, map: n } }(n = t).map, Kr().then(function (t) { return t.filter(function (t) { return i[t.name] }) }).then(function (t) { return Qr(t, !!e.embedFonts) }).then(function (t) { if (0 !== t.length) { for (var e = Rt("style"), i = 0; i < t.length; i++)e.appendChild(Pt(t[i])); n.childNodes[0].appendChild(e) } return n }); var n, e, i }).then(function (t) { var e = '<?xml version="1.0" encoding="utf-8"?>' + Oo(t); return n && It(e, i, "text/xml"), e }) }(e, t) } } } var uy = { download: !0, filename: "graph.svg", width: void 0, height: void 0, background: null, texts: !0, images: !0, badges: !0, embedFonts: !1, clip: !1, margin: 10, prefix: "ogma" }; function ly(g) { return { xlsx: function (t) { "string" == typeof t && (t = { what: t }); var e = Q(t, dy), i = e.what, n = e.nodes, r = e.edges, o = e.tab, s = void 0 === o ? { nodes: void 0, edges: void 0 } : o, a = e.download, u = e.filename, l = e.dataProperties, d = e.filter, h = e.nodeData, c = e.edgeData; s.nodes || (s.nodes = function () { return "nodes" }), s.edges || (s.edges = function () { return "edges" }); var f = function (t, e) { var i = e.what, n = e.tabFunctions, r = e.tabContentFunctions, o = M("XLSX") || M("xlsx", { throwOnError: !0 }), s = new cy; if (i) { if ("nodes" !== i && "edges" !== i) throw new TypeError('Invalid argument: "what" is not "nodes" or "edges", was ' + i); "nodes" === i && (t.edges = []), "edges" === i && (t.nodes = []) } for (var a = {}, u = 0, l = ["nodes", "edges"]; u < l.length; u++)for (var d = l[u], h = Nm(t[d], d, n[d], r[d]), c = 0, f = Object.keys(h); c < f.length; c++) { var g = f[c]; a[g] = (a[g] || []).concat(h[g]) } for (var p = 0, _ = Object.keys(a); p < _.length; p++) { g = _[p]; s.SheetNames.push(g), s.Sheets[g] = hy(o, km(a[g])) } return Mt([function (t) { for (var e = new ArrayBuffer(t.length), i = new Uint8Array(e), n = 0; n !== t.length; ++n)i[n] = 255 & t.charCodeAt(n); return e }(o.write(s, { bookType: "xlsx", bookSST: !1, type: "binary" }))]) }(Mm(g.modules.graph, g.modules.individualAttributes, { styles: "none", nodes: n, edges: r, filter: d, nodeData: function (t) { return t }, edgeData: function (t) { return t } }), { what: i, tabFunctions: s, tabContentFunctions: { nodes: h || function (t) { return tt(q(t || {}), l) }, edges: c || function (t) { return tt(q(t || {}), l) } } }); return a && It(f, u, "blob"), Promise.resolve(f) } } } var dy = { what: void 0, dataProperties: void 0, filter: "visible", nodes: void 0, edges: void 0, download: !0, filename: "graph.xlsx", tab: void 0, nodeData: void 0, edgeData: void 0 }; function hy(t, e) { for (var i, n = {}, r = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } }, o = 0; o !== e.length; ++o)for (var s = e[o], a = 0; a !== s.length; ++a) { var value = s[a]; r.s.r > o && (r.s.r = o), r.s.c > a && (r.s.c = a), r.e.r < o && (r.e.r = o), r.e.c < a && (r.e.c = a); var u = { v: void 0 === (i = value) ? "" : i instanceof Date ? i.toISOString() : "" + i }; n[t.utils.encode_cell({ c: a, r: o })] = u } return r.s.c < 1e7 && (n["!ref"] = t.utils.encode_range(r)), n } var cy = function () { this.SheetNames = [], this.Sheets = {} }; function fy(t) { return t.styles.createClass({ name: fl, isBuiltin: !0 }), C({}, Fm(t), Pm(t), jm(t), { json: function (t) { void 0 === t && (t = {}); var e = Q(t, Hm), i = e.nodeAttributes, n = e.edgeAttributes, r = e.nodeData, o = e.edgeData, s = e.filter, a = e.pretty, u = e.download, l = e.filename, d = Cm(c.modules.graph, { nodeAttributes: i, edgeAttributes: n, filter: s, nodeData: r, edgeData: o }), h = a ? JSON.stringify(d, null, " ") : JSON.stringify(d); return u && It(h, l, "text"), Promise.resolve(h) } }, { png: function (t) { return void 0 === t && (t = {}), ey(e, t, "png") }, jpg: function (t) { return void 0 === t && (t = {}), ey(e, t, "jpg") }, tiff: function (t) { return void 0 === t && (t = {}), ey(e, t, "tiff") }, gif: function (t) { return void 0 === t && (t = {}), ey(e, t, "gif") } }, ay(e = c = t), ly(t)); var e, c } var gy = (py.initNamespace = function (t) { t.export = fy(t) }, py); function py() { } var _y = { configure: function (t) { var e, i = void 0 === t ? {} : t, n = i.children, r = void 0 === n ? 2 : n, o = i.height, s = void 0 === o ? 3 : o; if (!("number" == typeof (e = r) && isFinite(e) && 0 < e ? e : void 0)) throw new TypeError('Invalid argument: "children" is not a positive number, was ' + r); if (!Mu(s)) throw new TypeError('Invalid argument: "height" is not a positive number, was ' + s); return { children: r, height: s } }, generate: function (t) { var e = t.children, i = t.height; i += 1; for (var n = Math.pow(e, i), r = [], o = [], s = 1, a = 0, u = 0, l = 0; l < i; ++l) { for (var d = n / (s + 1) / 1.5, h = 0; h < s; ++h) { var c = a++; if (r.push({ id: c, attributes: { x: (h + 1) * d * 10, y: 20 * l } }), l !== i - 1) for (var f = 0; f < e; ++f)o.push({ id: u, source: c, target: c * e + f + 1 }), u += 1 } s *= e } return { nodes: r, edges: o } } }; var vy = { configure: function (t) { var e = void 0 === t ? {} : t, i = e.nodes, n = void 0 === i ? 40 : i, r = e.m0, o = void 0 === r ? 5 : r, s = e.m, a = void 0 === s ? 1 : s, u = e.scale, l = void 0 === u ? 100 : u; if (!Cu(n) || n < 3) throw new TypeError("Invalid argument: options.nodes is not a number >= 3, was " + n); if (!Cu(o) || n <= o) throw new TypeError("Invalid argument: options.m0 is not a number < " + n + ", was " + o); if (!Cu(o) || o <= a) throw new TypeError("Invalid argument: options.m is not a number <= " + o + ", was " + a); if (!Cu(l) || l < 0) throw new TypeError("Invalid argument: options.scale is not a number or is less than 0"); return { nodes: n, m0: o, m: a, scale: l } }, generate: function (t) { for (var e = t.scale, i = t.nodes, n = t.m0, r = t.m, o = { nodes: [], edges: [] }, s = {}, a = [], u = e / 10, l = 0, d = 0; d < n; d++)o.nodes.push({ id: d, attributes: { x: Math.random() * u, y: Math.random() * u } }), a[d] = 0; for (d = 0; d < n; d++)for (var h = d + 1; h < n; h++) { s[(v = { id: l++, source: d, target: h }).source + "-" + v.target] = v, o.edges.push(v), a[d]++ , a[h]++ } for (d = n; d < i; d++) { o.nodes.push({ id: d, attributes: { x: Math.random() * e, y: Math.random() * e } }); var c = a[d] = 0; for (h = 0; h < d; h++)c += a[h]; for (var f = 0, g = 0; g < r; g++) { var p = Math.random(), _ = 0; for (h = 0; h < d; h++)if (!s[d + "-" + h] && !s[h + "-" + d] && p <= (_ = 1 === d ? 1 : _ + a[h] / c + f / (d - g))) { var v; f += a[h] / c, s[(v = { id: l++, source: d, target: h }).source + "-" + v.target] = v, o.edges.push(v), a[d]++ , a[h]++; break } } } return o } }; var my = { configure: function (t) { var e = void 0 === t ? {} : t, i = e.nodes, n = void 0 === i ? 20 : i, r = e.edges, o = e.p, s = e.scale, a = void 0 === s ? 100 : s; if (!Cu(n) || n < 3) throw new TypeError("Invalid argument: options.nodes is not a number >= 3, was " + n); if (void 0 !== r && void 0 !== o) throw new TypeError("Invalid argument: choose between options.edges and options.p"); return void 0 === r && void 0 === o && (o = .1), { nodes: n, edges: r, p: o, scale: a } }, generate: function (t) { var e = { nodes: [], edges: [] }, i = t.nodes, n = t.p, r = t.scale; if (0 <= n) for (var o = 0, s = 0; s < i; s++) { e.nodes.push({ id: s, attributes: { x: Math.random() * r, y: Math.random() * r } }); for (var a = 0; a < s; a++)Math.random() < n && e.edges.push({ id: o++, source: s, target: a }) } else { var u = [], l = t.edges; for (s = 0; s < i; s++) { e.nodes.push({ id: s, attributes: { x: 100 * Math.random(), y: 100 * Math.random() } }); for (a = s + 1; a < i; a++)u.push({ source: s, target: a }) } for (o = u.length - 1, s = 0; s < l; s++) { var d = u.splice(Math.floor(Math.random() * o), 1)[0]; d.id = s, e.edges.push(d), o-- } } return e } }, yy = 5, by = 10, xy = 10, Ey = 2.7, Ay = .2; function Sy(t) { return Math.pow(Ey, t) * by } function wy(t) { return yy + Sy(t) / xy } var Ty = { configure: function (t) { var e = t.depth, i = void 0 === e ? 3 : e, n = t.breadth, r = void 0 === n ? 3 : n, o = t.nbNodes; return void 0 !== o && (r = 5, i = Math.ceil(Math.log(o) / Math.log(5))), { depth: i, breadth: r, nbNodes: o } }, generate: function (t) { var e = t.depth, i = t.breadth, n = t.nbNodes, r = { id: 0, attributes: { x: 0, y: 0, radius: wy(e + 1) } }, o = { nodes: [r], edges: [] }; return function t(e, i, n, r, o) { if (0 === n) return o; var distance = Sy(n); var s = wy(n); var a = s * Ay; var u = -Math.PI; var l = 2 * Math.PI / i; var d = r.attributes.x; var h = r.attributes.y; for (var c = 0; c < i; ++c) { var f = Math.cos(u), g = Math.sin(u), p = { id: o, attributes: { x: d + distance * f, y: h + distance * g, radius: s } }, _ = { id: o, source: r.id, target: o, attributes: { width: a } }; e.nodes.push(p), e.edges.push(_), o = t(e, i, n - 1, p, o + 1), u += l } return o }(o, i, e, r, 1), void 0 !== n && (o.nodes = o.nodes.slice(0, n), o.edges = o.edges.slice(0, Math.max(n - 1, 0))), o } }; var Cy = { configure: function (t) { var e = void 0 === t ? {} : t, i = e.rows, n = void 0 === i ? 4 : i, r = e.columns, o = void 0 === r ? 4 : r, s = e.columnDistance, a = void 0 === s ? 20 : s, u = e.rowDistance, l = void 0 === u ? 20 : u, d = e.xmin, h = void 0 === d ? 0 : d, c = e.ymin; return { rows: n, columns: o, columnDistance: a, rowDistance: l, xmin: h, ymin: void 0 === c ? 0 : c } }, generate: function (t) { for (var e = t.rows, i = t.columns, n = t.columnDistance, r = t.rowDistance, o = t.xmin, s = t.ymin, a = { nodes: [], edges: [] }, u = 0, l = 0; l < e; ++l)for (var d = 0; d < i; ++d) { var h = l * i + d; a.nodes.push({ id: h, attributes: { x: o + d * n, y: s + l * r } }), d !== i - 1 && (a.edges.push({ id: u, source: h, target: l * i + d + 1 }), u++), l !== e - 1 && (a.edges.push({ id: u, source: h, target: (l + 1) * i + d }), u++) } return a } }; var My = { configure: function (t) { var e = void 0 === t ? {} : t, i = e.nodes, n = void 0 === i ? 10 : i, r = e.edges, o = void 0 === r ? 10 : r, s = e.texts, a = void 0 !== s && s, u = e.scale; return { nodes: n, edges: o, texts: a, scale: void 0 === u ? 100 : u } }, generate: function (t) { for (var e = t.nodes, i = t.edges, n = t.texts, r = t.scale, o = [], s = [], a = 0; a < e; a++)o.push({ id: a, attributes: { x: Math.random() * r, y: Math.random() * r, text: n ? "Node " + a : void 0 } }); for (a = 0; a < i; a++)s.push({ id: a, source: Math.random() * e | 0, target: Math.random() * e | 0, attributes: { text: n ? "Edge " + a : void 0 } }); return { nodes: o, edges: s } } }; var Iy = { configure: function (t) { var e = void 0 === t ? {} : t, i = e.nodes, n = void 0 === i ? 50 : i, r = e.width, o = void 0 === r ? 100 : r, s = e.height, a = void 0 === s ? 100 : s, u = e.x, l = void 0 === u ? 0 : u, d = e.y, h = void 0 === d ? 0 : d; if (!isFinite(n) || n < 1) throw new RangeError("Tree generator: number of nodes must be a positive integer"); return { nodes: n, width: o, height: a, x: l, y: h } }, generate: function (t) { var e = t.nodes, i = t.x, n = t.y, r = t.width, o = t.height, s = i - r / 2, a = n - o / 2; return { nodes: new Array(e).fill(0).map(function (t, e) { return { id: e, attributes: { x: s + Math.random() * r, y: a + Math.random() * o } } }), edges: new Array(e - 1).fill(0).map(function (t, e) { return { id: e, source: Math.floor(Math.sqrt(e)), target: e + 1 } }) } } }; var Ly = { configure: function (t) { var e = void 0 === t ? {} : t, i = e.length, n = void 0 === i ? 5 : i, r = e.scale; return { length: n, scale: void 0 === r ? 100 : r } }, generate: function (t) { var e = t.length, i = t.scale, n = { nodes: [], edges: [] }; if (e <= 0) return n; n.nodes.push({ id: 0, attributes: { x: Math.random() * i, y: Math.random() * i } }); for (var r = 1; r < e; ++r)n.nodes.push({ id: r, attributes: { x: Math.random() * i, y: Math.random() * i } }), n.edges.push({ id: r - 1, source: r - 1, target: r }); return n } }, Ny = (ky.initNamespace = function (t) { t.generate = { balancedTree: function (t) { return Promise.resolve(_y.generate(_y.configure(t))) }, barabasiAlbert: function (t) { return Promise.resolve(vy.generate(vy.configure(t))) }, erdosRenyi: function (t) { return Promise.resolve(my.generate(my.configure(t))) }, flower: function (t) { return Promise.resolve(Ty.generate(Ty.configure(t))) }, grid: function (t) { return Promise.resolve(Cy.generate(Cy.configure(t))) }, path: function (t) { return Promise.resolve(Ly.generate(Ly.configure(t))) }, random: function (t) { return Promise.resolve(My.generate(My.configure(t))) }, randomTree: function (t) { return Promise.resolve(Iy.generate(Iy.configure(t))) } } }, ky); function ky() { } var Oy = (Fy.initNamespace = function (t) { var n; t.geo = (n = t, { enable: function (t) { return n.modules.geo.enable(t) }, disable: function (t) { return n.modules.geo.disable(t) }, setOptions: function (t) { return n.modules.geo.setOptions(t) }, getOptions: function () { return n.modules.geo.getOptions() }, getMap: function () { return n.modules.geo.getMap() }, enabled: function () { return n.modules.geo.isEnabled() }, getCenter: function () { return n.modules.geo.getCenter() }, getView: function () { return n.modules.geo.getView() }, getZoom: function () { return n.modules.geo.getZoom() }, setZoom: function (t) { return n.modules.geo.setZoom(t) }, setView: function (t, e, i) { return n.modules.geo.setView(t, e, i) }, setCenter: function (t, e) { return n.modules.geo.setCenter(t, e) }, toggle: function (t) { return n.modules.geo.toggle(t) }, resetCoordinates: function () { return n.modules.geo.resetCoordinates() }, updateCoordinates: function () { return n.modules.geo.updateCoordinates() }, getUnprojectedCoordinates: function (t) { return n.modules.geo.getUnprojectedCoordinates(n.getNodes(t)) } }) }, Fy); function Fy() { } function Ry(t, e, i, n, r) { var o; void 0 === n && (n = {}), void 0 === r && (r = !1), Array.isArray(i) || i instanceof (e ? tn : Pi) || (i = [i]); var s = t.getElements(e, i); if (r || (s = s.dedupe()), !s.size) return Promise.resolve(); e && Ry(t, !1, s.getAdjacentEdges({ filter: "all" }), n, !0); var a = n.virtual, u = void 0 !== a && a, l = s._indexes, d = t.storage.fetch(e), h = t.getCacheLists(e), c = d.getFlexArray("removed"); if (We(d.getFlexArray("virtual").getMultiple(l)) !== (u ? l.length : 0)) throw new Error("Attempting to remove virtual elements; you should not do that"); var f = ((o = { virtual: u })[e ? "nodes" : "edges"] = s, o); if (t.fireEvent(e ? xe.BEFORE_REMOVE_NODES : xe.BEFORE_REMOVE_EDGES, f), h.visible.invalidList(), h.all.invalidList(), u || h.raw.invalidList(), t.setExcluded(s, !0), c.setMultiple(l, 1), !e) for (var g = 0; g < l.length; ++g)t.topology.removeFromAdjacencyList(l[g]); return d.removeElements(l), t.setIndexFreeStep(1), t.fireEvent(e ? xe.REMOVE_NODES : xe.REMOVE_EDGES, f), Promise.resolve() } var Py = (Dy.prototype.addNodes = function (t, e) { return rn(this.modules.graph, !0, t, e) }, Dy.prototype.addEdges = function (t, e) { return rn(this.modules.graph, !1, t, e) }, Dy.prototype.addNode = function (t, e) { return nn(this.modules.graph, !0, t, e) }, Dy.prototype.addEdge = function (t, e) { return nn(this.modules.graph, !1, t, e) }, Dy.prototype.removeNodes = function (t, e) { return Ry(this.modules.graph, !0, t, e) }, Dy.prototype.removeEdges = function (t, e) { return Ry(this.modules.graph, !1, t, e) }, Dy.prototype.removeNode = function (t, e) { return Ry(this.modules.graph, !0, [t], e) }, Dy.prototype.removeEdge = function (t, e) { return Ry(this.modules.graph, !1, [t], e) }, Dy.prototype.getNodes = function (t) { return this.modules.graph.getNodes(t) }, Dy.prototype.getEdges = function (t) { return this.modules.graph.getEdges(t) }, Dy.prototype.getNode = function (t) { return this.modules.graph.getNode(t) }, Dy.prototype.getEdge = function (t) { return this.modules.graph.getEdge(t) }, Dy.prototype.clearGraph = function () { this.modules.graph.clear() }, Dy.prototype.setGraph = function (t, e) { return this.modules.graph.clear(), this.addGraph(t, e) }, Dy.prototype.addGraph = function (t, e) { return i = this.modules.graph, r = e, s = (n = t).nodes, a = void 0 === s ? [] : s, u = n.edges, l = void 0 === u ? [] : u, void 0 === r && (r = {}), r.batchSize ? rn(i, !0, a, r).then(function (t) { return o = t, rn(i, !1, l, r) }).then(function (t) { return { nodes: o, edges: t } }) : Promise.resolve({ nodes: on(i, !0, a, r), edges: on(i, !1, l, r) }); var i, n, r, o, s, a, u, l }, Dy.prototype.createNodeList = function () { return this.getNodes([]) }, Dy.prototype.createEdgeList = function () { return this.getEdges([]) }, Dy.prototype.getConnectedComponents = function (t) { return void 0 === t && (t = {}), this.modules.graph.getConnectedComponents(this.getNodes(t.filter), t) }, Dy.prototype.getConnectedComponentByNode = function (t, e) { var i = this.modules.graph.getNode(t); if (void 0 === i) throw new Error("getComponentByNode: cannot find node " + t); return this.modules.graph.getConnectedComponentByNode(i, e)[0] }, Dy); function Dy() { } var zy = (By.prototype.reloadFonts = function () { this.modules.graphics.reloadFonts() }, By); function By() { } function Uy(t) { return t.charCodeAt(0) } var Vy = Uy(" "), jy = Uy("<"), Gy = Uy(">"), Hy = Uy('"'), qy = Uy("\n"), Wy = Uy("\r"), Xy = Uy("/"), Yy = Uy("\\"), Zy = Uy("a"), Ky = Uy("z"), Qy = Uy("A"), Jy = Uy("Z"), $y = Uy("0"), tb = Uy("9"), eb = Uy(":"), ib = -1, nb = -2, rb = -3, ob = -4; function sb(t, e, i, n) { var r = n.length; if (i - e !== r) return !1; for (var o = 0; o < r; ++o)if (t[e + o] !== n[o]) return !1; return !0 } function ab(t, e, i, n) { for (var r = t.length, o = 0; o < r; ++o)if (sb(e, i, n, t[o])) return o; return t.push(e.slice(i, n)), r } function ub(t, e, i) { var n = db(e, i), r = e[n]; if (r === Gy || r === Xy) return n; var o = n; n = hb(e, n); for (var s, a, u, l = (s = e, a = o, u = n, ab(t.attributes, s, a, u)); e[n] !== Hy;)++n; for (o = ++n; (r = e[n]) !== Hy;)r === Yy && ++n, ++n; return t.tokens.push(rb, l, o, n), n + 1 } function lb(t) { return t === Vy || t === qy || t === Wy } function db(t, e) { for (; lb(t[e]);)++e; return e } function hb(t, e) { for (; i = t[e], Zy <= i && i <= Ky || Qy <= i && i <= Jy || i === eb || $y <= i && i <= tb;)++e; var i; return e } function cb(t, e) { var i = ["return {", "  id: undefined,", "  attributes: {", "    text: undefined,", "    color: undefined,", "    " + (t ? "radius" : "width") + ": undefined", t ? "  ,x: undefined" : "", t ? "  ,y: undefined" : "", "  },"]; t || i.push("  source: undefined,", "  target: undefined,"); var n = Object.keys(e); n.length && i.push("  data: {"); for (var r = 0; r < n.length; ++r) { var o = e[n[r]], s = o.title; i.push('  "' + s + '": ' + (void 0 !== o.default ? JSON.stringify(o.default) : void 0) + (r === n.length - 1 ? "" : ",")) } return n.length && i.push("}"), i.push("};"), new Function(i.join("\n")) } function fb(t) { return -1 === t.indexOf("\\") ? t : t = t.replace(/\\"/g, '"') } function gb(t) { if (-1 === t.indexOf("<gexf")) throw new Error("not a GEXF file"); var e = function (t) { for (var e = new Int32Array(t.length), i = 0, n = t.length; i < n; ++i)e[i] = t.charCodeAt(i); return e }(t), i = function (t, e) { for (var i, n, r = { tags: [], attributes: [], tokens: [] }, o = r.tokens, s = db(t, e); s < t.length;) { var a = t[s]; if (a === jy) { if (t[s = db(t, ++s)] === Xy) for (o.push(nb); t[++s] !== Gy;); else { s = hb(t, i = s); var u = ab(r.tags, t, i, s); for (o.push(ib, u), a = t[s]; a !== Gy && a !== Xy;)a = t[s = ub(r, t, s)]; if (a === Xy) for (o.push(nb); t[++s] !== Gy;); } s += 1 } else { for (i = s; t[++s] !== jy;); for (n = s - 1; lb(t[n]);)--n; o.push(ob, i, n + 1) } s = db(t, s) } return r }(e, t.indexOf("<gexf ")), n = {}, r = {}; i.tags.forEach(function (t, e) { var i = String.fromCharCode.apply(null, t); n[i] = e }), i.attributes.forEach(function (t, e) { var i = String.fromCharCode.apply(null, t); r[i] = e }); for (var o = n.attributes, s = n.attribute, a = n.node, u = n.edge, l = n.default, d = n["viz:position"], h = n["viz:size"], c = n["viz:color"], f = n.attvalue, g = r.class, p = r.id, _ = r.type, v = r.title, m = r.label, y = r.source, b = r.target, x = r.x, E = r.y, A = r.r, S = r.g, w = r.b, T = r.a, C = r.value, M = r.for, I = r.weight, L = { float: 1, double: 1, integer: 2, boolean: 3, string: 4, "list-string": 5 }, N = 0, k = i.tokens, O = k.length, F = new Array(16), R = 0, P = 0, D = 0, z = !0, B = {}, U = {}, V = null, j = null, G = null, H = void 0, q = null, W = 0, X = 0, Y = 0, Z = 1, K = null, Q = void 0, J = !1, $ = !0, tt = null, et = null, it = [], nt = [], rt = 0, ot = null; N < O;) { var st = k[N]; if (st === ib) P = R, R = k[N + 1], F[D] = R, D += 1, R === a ? (q = (tt = tt || cb(!0, B))(), $ = !0, ot = B) : R === u && (q = (et = et || cb(!1, U))(), $ = !1, ot = U), N += 2; else if (st === nb) { if (V && R === s) { ot = z ? B : U; var at = L[j]; (value = H) && (1 === at ? value = +value : 2 === at ? value = 0 | +value : 3 === at ? value = "true" === value : 5 === at && (value = value.split(" ").filter(function (t) { return t }))), ot[V] = { title: G || V, default: value, type: at }, j = G = V = null, H = void 0 } else if (R === a && 4 === D) J && (q.attributes.color = "rgba(" + W + ", " + X + ", " + Y + ", " + Z + ")", Y = X = W = 0, J = !(Z = 1)), q.id || (q.id = ++rt), it.push(q); else if (R === u && 4 === D) q.id || (q.id = ++rt), nt.push(q); else if (R === f && 6 === D && K) { var ut = ($ ? B : U)[K]; if (ut) { if (void 0 === Q) Q = ut.default; else (at = ut.type) && (1 === at ? Q = +Q : 2 === at ? Q = 0 | +Q : 3 === at ? Q = "true" === Q : 5 === at ? Q = Q.split(" ").filter(function (t) { return t }).map(function (t) { return fb(t) }) : "string" == typeof e && (Q = fb(Q))); q.data[ot[K].title] = Q } Q = K = null } R = P, P = F[--D - 2], N += 1 } else if (st === rb) { var lt = k[N + 1], value = t.substring(k[N + 2], k[N + 3]); if (R === o) lt === g && (z = "edge" !== value && "edges" !== value); else if (R === s) lt === p ? V = value : lt === _ ? j = value : lt === v && (G = value); else if (R !== a && R !== u || 4 !== D) if (R === d && 5 === D) { if (lt === x) q.attributes.x = parseFloat(value); else if (lt === E) { var dt = parseFloat(value); q.attributes.y = 0 === dt ? dt : -dt } } else R === c && 5 === D ? (J = !0, lt === A ? W = parseInt(value) : lt === S ? X = parseInt(value) : lt === w ? Y = parseInt(value) : lt === T && (Z = parseFloat(value))) : R === h && 5 === D ? lt === C && ($ ? q.attributes.radius = +value : q.attributes.width = +value) : R === f && 6 === D && (lt === M || lt === p ? K = value : lt === C && (Q = value)); else lt === p ? q.id = value : lt === m ? q.attributes.text = value : lt === y ? q.source = value : lt === b ? q.target = value : lt === I && (q.attributes.width = +value); N += 4 } else { if (st !== ob) throw new Error("at index " + N + ": token " + st); value = t.substring(k[N + 1], k[N + 2]); R === l && (H = value), N += 3 } } return { nodes: it, edges: nt } } function pb(t) { if ("string" == typeof t || isFinite(t)) return String(t); return String(t.id || t._id) } function _b(t) { var e = [], i = []; return function e(i, n, r) { if (i && "object" == typeof i) { if (Array.isArray(i)) return i.forEach(function (t) { return e(t, n, r) }); if ("vertex" === (a = i).type || "vertex" === a._type || a.inE || a.outE || a._inE || a._outE) { var o = {}; i.properties && Object.keys(i.properties).forEach(function (t) { o[t] = i.properties[t][0].value }); var t = pb(i); for (var s in n.push({ id: t, data: { id: i.id + "", categories: [i.label], properties: o } }), i) "properties" !== s && e(i[s], n, r) } else { var a, u; if ("edge" === (u = i).type || "edge" === u._type || u.inV || u.outV || u._outV || u._inV) for (var s in t = pb(i), r.push({ id: t, source: pb(i.inV || i._inV), target: pb(i.outV || i._outV), data: { id: t, type: i.label, properties: i.properties || {} } }), i) "properties" !== s && e(i[s], n, r); else Object.keys(i).forEach(function (t) { return e(i[t], n, r) }) } } }("string" == typeof t ? JSON.parse(t) : t, e, i), { nodes: e, edges: i } } function vb(t, e, i) { i = i || e, e in t && (t.attributes || (t.attributes = {}), t.attributes[i] = t[e]) } function mb(t) { for (var e = JSON.parse(t), i = e.nodes || [], n = e.edges || [], r = 0; r < i.length; r++) { var o = i[r]; "string" == typeof o.size && (o.size = +o.size), "string" == typeof o.x && (o.x = +o.x), "string" == typeof o.y && (o.y = +o.y), vb(o, "x"), vb(o, "y"), vb(o, "size", "radius"), vb(o, "color"), vb(o, "text") } for (r = 0; r < n.length; r++) { var s = n[r]; "string" == typeof s.size && (s.size = +s.size), vb(s, "size", "width"), vb(s, "color"), vb(s, "text") } return e } function yb(t, e) { for (var i = 0, n = 0; n < 20; ++n) { var r = i + t[n] + e[n]; i = +(10 <= r), t[n] = r % 10 } } function bb() { this._decimalPowerOfTwo = new Uint8Array(20), this._binaryNumber = new Uint8Array(64), this._decimalNumber = new Uint8Array(20) } var xb = new (bb.prototype.int64ToString = function (t) { var e = t.low, i = t.high; if (0 === e && 0 === i) return "0"; !function (t, e, i) { for (var n = 0; n < 32; ++n)i[n] = +!!(t & 1 << n); for (n = 0; n < 32; ++n)i[n + 32] = +!!(e & 1 << n) }(e, i, this._binaryNumber), this._decimalNumber.fill(0), this._decimalPowerOfTwo.fill(0); var n = (this._decimalPowerOfTwo[0] = 1) === this._binaryNumber[63]; n && function (t) { for (var e = 0; e < 64; ++e)t[e] ^= 1; for (e = 0; e < 64 && !(t[e] ^= 1); ++e); }(this._binaryNumber); for (var r = 0; r < 64; ++r)this._binaryNumber[r] && yb(this._decimalNumber, this._decimalPowerOfTwo), yb(this._decimalPowerOfTwo, this._decimalPowerOfTwo); var o = [], s = this._decimalNumber.length - 1; for (n && o.push("-"); !this._decimalNumber[s];)--s; for (r = s; 0 <= r; --r)o.push(String(this._decimalNumber[r])); return o.join("") }, bb); function Eb(t) { return xb.int64ToString(t) } function Ab(t) { return "object" == typeof t && "high" in t && "low" in t } var Sb = function (t) { return "start" in t && "end" in t && "type" in t }, wb = function (t) { return "segments" in t }; function Tb(e, t, i, n) { var r, o, s; t && (Array.isArray(t) ? t.forEach(function (t) { return Tb(e, t, i, n) }) : wb(t) ? (r = e, o = i, s = n, t.segments.forEach(function (t) { Tb(r, t.start, o, s), Tb(r, t.end, o, s), Tb(r, t.relationship, o, s) })) : (function (t) { if ("object" != typeof t || null === t) throw new Error("Ogma can only retrieve nodes and relationships from Neo4j. Please make sure that your Cypher query returns nodes and edges, not values."); for (var e, i = 0, n = Object.keys(t.properties); i < n.length; i++) { var r = n[i], o = t.properties[r]; Ab(o) && (t.properties[r] = Eb(o)) } if (void 0 !== t.identity && (Ab(t.identity) && (t.identity = Eb(t.identity)), "start" in (e = t) && "end" in e)) { var s = t.start.identity || t.start, a = t.end.identity || t.end; Ab(s) && (t.start = Eb(s)), Ab(a) && (t.end = Eb(a)) } }(t), Sb(t) ? n.has(t.identity) || (n.add(t.identity), e.edges.push({ id: t.identity, source: t.start, target: t.end, data: { neo4jType: t.type, neo4jProperties: t.properties } })) : i.has(t.identity) || (i.add(t.identity), e.nodes.push({ id: t.identity, attributes: { x: 100 * Math.random(), y: 100 * Math.random() }, data: { neo4jLabels: t.labels, neo4jProperties: t.properties } })))) } function Cb(t) { return { gexf: function (t) { return Promise.resolve(gb(t)) }, gexfFromUrl: function (t) { return Bt(t).then(function (t) { return gb(t) }) }, janus: function (t) { return Promise.resolve(_b(t)) }, json: function (t) { return Promise.resolve(mb(t)) }, jsonFromUrl: function (t) { return Bt(t).then(function (t) { return mb(t) }) }, neo4j: function (t) { return Promise.resolve((i = "string" == typeof (e = t) ? JSON.parse(e) : e, n = { nodes: [], edges: [] }, r = new Set, o = new Set, i.records.forEach(function (t) { t._fields.forEach(function (t) { Tb(n, t, r, o) }) }), n)); var e, i, n, r, o } } } var Mb = (Ib.initNamespace = function (t) { t.parse = Cb() }, Ib.prototype.fetch = function (t) { return Bt(t) }, Ib); function Ib() { } var Lb = (Nb.initNamespace = function (t) { var e; t.keyboard = (e = t, { isKeyPressed: function (t) { return e.modules.keyboard.isPressed(t) }, resetKeys: function () { e.modules.keyboard.resetKeys() } }) }, Nb); function Nb() { } var kb = { configure: function (t, e) { var i = e.graph, n = e.data; if (void 0 === t.centralNode) throw new Error('concentric layout: missing parameter "centralNode"'); var r, o, s, a, u, l = C({}, t, { centralNode: (a = i, (u = t.centralNode) instanceof Ji ? u : a.getNode(u)), nodes: (r = i, o = t.nodes, void 0 === s && (s = r.getNodes()), o ? o instanceof tn ? o : r.getNodes(o) : s) }), d = l.centralNode, h = l.nodes, c = i.getNode(d)._index, f = l.centralNode.getPosition(), g = f.x, p = f.y, _ = h.getAttribute("layoutable"), v = i.getNodes(h)._indexes, m = Array.from(v.filter(function (t, e) { return _[e] })); -1 === m.indexOf(c) && m.push(c); var y = i.getNodeAttribute("radius").getMultiple(v), b = function (t, e, i, n) { if (e) return "random" === e ? "random" : "radius" === e ? n.slice() : "degree" === e ? i.getDegree() : t.getProperty(i, e) }(n, l.sortBy, h, y), x = m.reduce(function (t, e, i) { return t[e] = i, t }, {}), E = m.map(function (t, e) { return e }), A = m.map(function (t) { return i.topology.getAdjacentElements(!0, new Uint32Array([t])).map(function (t) { return x[t] }) }); return { sourceNodeIndex: m.indexOf(c), centerX: "number" == typeof l.centerX ? l.centerX : g, centerY: "number" == typeof l.centerY ? l.centerY : p, list: m, indexes: E, size: m.length, totalSize: m.length, attributes: { adjacentNodes: A, size: y }, sortAttr: b, clockwise: void 0 === l.clockwise || l.clockwise, circleHopRatio: l.circleHopRatio || 5, allowOverlap: !!l.allowOverlap } }, context: function () { return { dijkstra: function (s, a, u, t, e) { var l, d = Math.pow(2, 31) - 1, h = new Int32Array(t), c = new Int32Array(t), f = new Int8Array(t); h.fill(d), c.fill(-1); for (var i = 0; i < t; ++i) { var n = a[i]; void 0 !== n && (h[n] = d, c[n] = -1) } h[e] = 0; for (var r = function () { var t = d; l = -1; for (var e = 0; e < u; ++e) { var i = a[e], n = h[i]; !f[i] && n < t && (t = n, f[l = i] = 1) } if (-1 < l) { var r = s[l], o = t + 1; r.forEach(function (t) { var e = h[t]; o < e && (h[t] = o, c[t] = l) }) } }; -1 !== l;)r(); return h }, determinePropertyType: function (e, t, i) { return t.some(function (t) { return "number" !== e[t] }) ? "string" : "number" } } }, update: function (d, t) { for (var e = d.attributes, i = d.indexes, n = d.size, r = d.sourceNodeIndex, h = d.centerX, c = d.centerY, o = d.sortAttr, s = e.adjacentNodes, f = e.size, g = new Array(d.totalSize), p = new Array(d.totalSize), a = t.dijkstra(s, i, d.size, d.totalSize, r), u = 0, _ = {}, l = 0; l < n; l++) { var v = f[i[l]]; u < v && (u = v) } var m = u * d.circleHopRatio, y = 0, b = 0, x = Math.PI / 9; for (l = 0; l < n; l++) { var E = i[l], distance = a[E], A = _[distance]; A || (A = [], _[distance] = A), A.push(E) } var S, w, T, C = (w = i, T = t, "random" === (S = o) ? function () { return Math.random() - .5 } : S ? "number" === T.determinePropertyType(S, w, w.length) ? function (t, e) { return S[t] - S[e] } : function (t, e) { return S[t] < S[e] ? -1 : 1 } : void 0), M = "random" === o || o; return Object.keys(_).sort(function (t, e) { return parseInt(t) - parseInt(e) }).forEach(function (t, e) { var i = _[t], n = i.length, r = 0, o = b, s = 2 * Math.PI / n; if (0 !== e && !d.allowOverlap) { var a; 2 * Math.PI * y < (a = 2 * (r += i.reduce(function (t, e) { return t + f[e] }, 0)) * Math.SQRT2) && (y += a / (2 * Math.PI) - y) } M && (i.sort(C), d.clockwise || i.reverse()); for (var u = 0; u < n; u++) { var l = i[u]; g[l] = Math.cos(o) * y + h, p[l] = Math.sin(o) * y + c, v = f[l], o += s * (d.allowOverlap ? 1 : v / r * n) } y += m, b += x }), { x: g, y: p, indexes: d.list } }, isRunning: function () { return !1 }, onSync: function (t) { return { indexes: t.indexes, x: t.x, y: t.y } } }; function bellmanFord(t) { var e = t.sources, i = t.targets, n = t.weights, r = t.source, o = t.target, s = t.undirected, a = void 0 !== s && s, u = t.indexes, l = t.N; if (l = u ? u.length : l, !isFinite(l) || 0 === l) throw new Error("Invalid number of nodes " + l); var d, h = new Float32Array(l), c = new Int32Array(l), f = {}, g = Number.POSITIVE_INFINITY; if (!n) { n = []; for (var p = 0; p < l; p++)n[p] = 1 } if (!u) { u = new Uint32Array(l); for (p = 0; p < l; p++)u[p] = p + 1 } for (p = 0; p < l; p++)h[p] = g, c[p] = -1, f[u[p]] = p; h[f[r]] = 0; for (p = 1; p <= l; p++) { d = !1; for (var _ = 0; _ < n.length; _++) { var v = e[_], m = i[_], y = f[v], b = f[m]; if (void 0 !== y && void 0 !== b) { var x = n[_], E = h[y] + x; h[y] !== g && E < h[b] && (h[b] = E, c[b] = v, d = !0), a && (E = h[b] + x, h[b] !== g && E < h[y] && (h[y] = E, c[y] = m, d = !0)) } } if (!d) break } if (d) for (p = 0; p < n.length; p++) { v = e[p], m = i[p], y = f[v], b = f[m]; if (void 0 !== y && void 0 !== b) { x = n[p]; if (h[y] + x < h[b]) return null } } var A = null, S = null; if (void 0 !== o) { var w = f[o]; if (void 0 !== w && h[w] !== g) { A = []; for (p = o; -1 !== p; p = c[f[p]])A.push(p); A = A.reverse(), S = h[w] } } return { distances: h, path: A, pathLength: S } } function johnson(t) { var e = t.sources, i = t.targets, n = t.weights, r = t.indexes, o = t.adjacency, s = t.undirected, a = t.ignoreWeights, u = Number.POSITIVE_INFINITY, l = r ? r.length : o.length; if (!r) { r = new Uint32Array(l); for (var d = 0; d < l; d++)r[d] = d + 1 } var h = new Array(l), c = {}; for (d = 0; d < l; d++) { h[d] = new Float32Array(l); for (var f = 0; f < l; f++)h[d][f] = d === f ? 0 : u; c[r[d]] = d } var g = l, p = n.length; e = e.slice(), i = i.slice(), n = n.slice(); for (d = 0; d < l; d++)e[p + d] = g, i[p + d] = r[d], n[p + d] = 0, a && (n[d] = 1); var _ = bellmanFord({ sources: e, targets: i, weights: n, undirected: s, N: l + 1, source: g }); if (null === _) throw new Error("Graph has negative weight loops"); var v = _.distances; for (d = 0; d < n.length; d++) { var m = c[e[d]], y = c[i[d]]; void 0 !== m && void 0 !== y && (n[d] = n[d] + v[m] - v[y]) } e = e.slice(0, p), i = i.slice(0, p), n = n.slice(0, p); for (d = 0; d < l; d++) { var b = dijkstra(o, r[d], void 0, r, c, a).distances; for (f = 0; f < l; f++)h[d][f] = d === f ? 0 : b[f] } return h } function removeRadialOverlap(t) { var i = t.X, n = t.Y, e = t.sizes, r = t.indexes, o = t.R, s = t.center, a = t.gap, u = void 0 === a ? 0 : a, l = t.epsilon, d = void 0 === l ? .001 : l, h = t.maxLoops, c = void 0 === h ? 5 : h, f = t.inPlace, g = void 0 === f || f, p = r.length, _ = s[0], v = s[1], m = p; g || (i = i.slice(), n = n.slice()); for (var y = circleCircleIntersection, b = circleSortCompare, x = r.slice().sort(function (t, e) { return b(i[t], n[t], i[e], n[e], _, v) }), E = x[p - 1], A = i[E], S = n[E], w = !1, T = 0; T < m - 1; T++) { var C = T % p, M = (T + 1) % p; -1 === T && (C = p - 1, M = 0), C = x[C], M = x[M]; var I = i[C], L = n[C], N = i[M], k = n[M], O = e[C] + e[M] + u, F = b(I, L, N, k, _, v); if (-1 === F && w && (F = 1), !(o < O)) { if (1 === F || O - distance(I, L, N, k) > d) { var R = y(_, v, o, I, L, O); if (R) { var P = R[0]; w = _ < N && P[0] < _, N = i[M] = P[0], k = n[M] = P[1] } } else w = !1; if (T % p == p - 2) { var D = x[p - 1], z = x[0]; if (n[D] > v && n[z] > v && i[D] - e[D] < i[z] + e[D]) { var B = 0; for (m = Math.min(p * c, m + p); n[x[D]] > v && n[x[0]] > v && i[x[D]] < i[x[0]] && ++B < p;)x.unshift(x.pop()) } } } } var U = A - _, V = S - v, j = i[E] - _, G = n[E] - v, H = U == j ? 0 : Math.abs(Math.acos((U * j + V * G) / (Math.sqrt(U * U + V * V) * Math.sqrt(j * j + G * G)))); if (0 !== H) { var q = Math.sin(-H), W = Math.cos(-H), X = void 0; for (T = 0; T < p; T++) { X = x[T]; B = i[X] - _; var Y = n[X] - v; i[X] = B * W - Y * q + _, n[X] = B * q + Y * W + v } } return { X: i, Y: n } } function Ob(t, e, i, n, r, o) { var s = Object.create(null), a = i[t], u = a, l = 0, d = a; for (var h in e) { for (var c = e[h], f = 0, g = 0, p = 0, _ = c.length; p < _; p++) { var v = i[c[p]]; g = Math.max(g, v), f += 2 * v + n } var m = f / (2 * Math.PI) + g, y = g + u, b = o ? l + Math.max(o, y) : l * r; l = Math.max(l, m, d, b), s[h] = l, u = g } return s[0] = 0, s[Number.POSITIVE_INFINITY] = l, s } function weightedStress(t, e, i, n, r, o) { for (var s = 0, a = 0; a < n; a++)for (var u = 0; u < n; u++) { var l = o[a], d = o[u]; if (l !== d) { var h = t[l][d] * r, c = 1 / (h * h); if (c) { var f = e[l] - e[d], g = i[l] - i[d]; s += c * Math.pow(h - Math.sqrt(f * f + g * g), 2) } } } return s } function distanceStress(t, e, i, n, r, o, s) { var a = 0; if (-1 === r) return 0; for (var u = 0; u < n; u++)for (var l = 0; l < n; l++) { var d = s[u], h = s[l]; if (d !== h && (d === r || h === r)) { var c = t[d][h] * o, f = 1 / (c * c); if (f) { var g = e[d] - e[h], p = i[d] - i[h]; a += f * Math.pow(c - Math.sqrt(g * g + p * p), 2) } } } return a } function constrainedStress(t, e, i, n, r, o, s, a) { s = s || 0; for (var weightedStress = 0, distanceStress = 0, u = 0; u < n; u++)for (var l = 0; l < n; l++) { var d = a[u], h = a[l]; if (d !== h) { var c = t[d][h] * o, f = 1 / (c * c); if (f) { var g = e[d] - e[h], p = i[d] - i[h], _ = f * Math.pow(c - Math.sqrt(g * g + p * p), 2); weightedStress += _, d !== r && h !== r || (distanceStress += _) } } } return (1 - s) * weightedStress + s * distanceStress } function stressMinimizationStep(t, e, i, n, r, o, s, a, u) { s = s || 0; var l = e, d = i; -1 === (r = void 0 === r ? -1 : r) && (s = 0); for (var h = e[r], c = i[r], f = 0; f < n; f++) { var g = a[f], p = u(t[r][f]), _ = s / (p * p); if (0 !== p) { for (var v = 0, m = 0, y = 0, b = e[g], x = i[g], E = 0; E < n; E++) { var A = a[E]; if (A !== g) { var S = t[g][A] * o, w = 1 / (S * S), T = e[A], C = i[A]; if (0 != w) { var M = (k = (L = b - T) * L + (N = x - C) * N) < 1e-6 ? 0 : 1 / Math.sqrt(k); m += (1 - s) * w * (T + S * (b - T) * M), y += (1 - s) * w * (C + S * (x - C) * M) } v += w } } var I = (1 - s) * v + _; if (0 != I) { var L, N, k; k = (k = (L = b - h) * L + (N = x - c) * N) < 1e-6 ? 0 : 1 / Math.sqrt(k); var O = 0 === p ? 0 : p * k * _; l[g] = (m + O * e[g]) / I, d[g] = (y + O * i[g]) / I } } } return { x: l, y: d } } function Fb(t, e) { return t - e } var Rb = { imports: { minHeap: minHeap, bellmanFord: bellmanFord, dijkstra: dijkstra, johnson: johnson, distance: distance, circleCircleIntersection: circleCircleIntersection, circleSortCompare: circleSortCompare, weightedStress: weightedStress, distanceStress: distanceStress, constrainedStress: constrainedStress, stressMinimizationStep: stressMinimizationStep, removeRadialOverlap: removeRadialOverlap, quadraticInOut: Zu, calculateRadii: Ob }, configure: function (t, e) { void 0 === t && (t = { centralNode: null }); var i = e.graph, n = i.getNode(t.centralNode), r = n.getPosition(), o = isFinite(t.centerX) ? t.centerX : r.x, s = isFinite(t.centerY) ? t.centerY : r.y, a = n._index, u = t.nodes; u.includes(n) || (u = u.concat(n.toList())); var l = u._indexes, d = u.getAttribute("layoutable"); (l = l.filter(function (t, e) { return d[e] || t === a })).sort(Fb); var h = l.length, c = function (t, e, i) { for (var n = t.slice().sort(Fb), r = [], o = 0, s = e.length; o < s; o++) { for (var a = [], u = e[o], l = !1, d = 0, h = u.length; d < h; d++) { var c = u[d]; -1 !== O(n, c) && (c === i && (l = !0), a.push(c)) } 0 !== a.length && r[l ? "unshift" : "push"](a.sort(Fb)) } return r }(l, i.getConnectedComponents(u, { internalIndexes: !0 }), a), f = i.degrees(l), g = new Float32Array(i.getNodeAttribute("x").getMultiple(l)), p = new Float32Array(i.getNodeAttribute("y").getMultiple(l)), _ = i.getNodeAttribute("radius").getMultiple(l), v = i.getEdges()._indexes, m = i.getEdgeAttribute("source").getMultiple(v), y = i.getEdgeAttribute("target").getMultiple(v), b = i.getAdjacencyList({ internalIndexes: !0, weight: 1, indexes: l }); return { centerIndex: a, centerIndexPos: 0, cx: o, cy: s, D: null, indexes: l, components: c, normIndexes: null, radii: null, rings: null, x: g, y: p, degree: f, size: h, attributes: { size: _, adjacency: b, weights: y.map(function () { return 1 }), sources: m, targets: y }, sortAttr: null, allowOverlap: !!t.allowOverlap, nodeGap: t.nodeGap, radiusRatio: t.radiusRatio, radiusDelta: t.radiusDelta, repulsion: t.repulsion, randomize: !("randomize" in t) || !!t.randomize, renderSteps: !!t.renderSteps, epsilon: t.epsilon, maxSteps: t.maxIterations, iterationsPerRender: t.iterationsPerRender, step: -1, stress: Number.POSITIVE_INFINITY, prevStress: 0, converged: !1, overlapRemoved: !1, done: !1 } }, context: function () { return { data: null, gridPlacement: function (t, e, i) { void 0 === i && (i = 8); for (var n = t.length, r = new Float32Array(n), o = new Float32Array(n), s = 0, a = 0, u = t.length; a < u; a++) { var l = e[t[a]]; s < l && (s = l) } var d = s * i, h = Math.ceil(Math.sqrt(n)), c = Math.ceil(n / h), f = -Math.floor((c - 1) * d / 2), g = -Math.floor((h - 1) * d / 2); for (a = 0; a < h; a++)for (var p = 0; p < c; p++)r[a * c + p] = f + p * d, o[a * c + p] = g + a * d; return { x: r, y: o } }, connectComponents: function (o, s, a, u, l, d) { var h; function c(t, value) { var e = new Uint32Array(t.length + 1); return e.set(t), e[t.length] = value, e } for (var t = function (t) { var e = o[t], i = 0, n = 0; e.forEach(function (t, e) { l.get(t) > i && (n = e, i = l.get(t)) }), h = e[n]; var r = s[d.get(h)]; r.nodes = c(r.nodes, a), r.weights.push(u), (r = s[d.get(a)]).nodes = c(r.nodes, h), r.weights.push(u) }, e = 1; e < o.length; e++)t(e) }, correctSubgraphsDistances: function (t, e, n, r, i) { for (var o = Array.prototype.reduce.call(t[n], function (t, e, i) { return i !== n && e < r && t < e && (t = e), t }, 0), s = r - o - 1, a = 1; a < e.length; a++)for (var u = e[a], l = 0, d = u.length; l < d; l++) { var h = i.get(u[l]); t[n][h] -= s, t[h][n] -= s } }, initialize: function (n, r) { (n.data = r).step = 0; var o = new Map, s = new Map; r.normIndexes = r.indexes.reduce(function (t, e, i) { return t[i] = i, o.set(e, i), s.set(e, r.degree[i]), e === r.centerIndex && (n.data.centerIndexPos = i), t }, new Uint32Array(r.indexes.length)); var t = r.centerIndexPos, e = r.components[0].length; n.connectComponents(r.components, r.attributes.adjacency, r.centerIndex, e, s, o); var i = johnson({ sources: r.attributes.sources, targets: r.attributes.targets, weights: r.attributes.weights, indexes: r.indexes, adjacency: r.attributes.adjacency, undirected: !0 }); n.correctSubgraphsDistances(i, r.components, t, e, o); for (var a = (r.D = i)[t], u = Object.create(null), l = 0, d = r.normIndexes.length; l < d; l++)if (l !== t) { var h = a[l]; u[h] = u[h] || [], u[h].push(r.normIndexes[l]) } r.rings = u, r.radii = Ob(t, r.rings, r.attributes.size, r.nodeGap, r.radiusRatio, r.radiusDelta) }, removeOverlaps: function (t, e) { var i = t.data.centerIndexPos, n = e.attributes.size, r = e.rings, o = e.x[i], s = e.y[i]; for (var a in r) { var u = r[a], l = distance(o, s, e.x[u[0]], e.y[u[0]]); removeRadialOverlap({ X: e.x, Y: e.y, sizes: n, indexes: u, center: [o, s], R: l, gap: e.nodeGap, inPlace: !0 }) } } } }, update: function (i, t) { var e, n = (i = i || t.data).indexes, r = i.centerIndex; i.x = i.x || new Float32Array(i.size), i.y = i.y || new Float32Array(i.size), -1 === i.step ? t.initialize(t, i) : i.step++; function o(t) { return i.radii[t] || 1 } var s = i.repulsion; if (0 === i.step) i.randomize && (e = t.gridPlacement(i.indexes, i.attributes.size), i.x = e.x, i.y = e.y); else if (!i.converged) for (var a = i.maxSteps, u = i.iterationsPerRender, l = i.step, d = Math.min(l + u, a + 1), h = i.D, c = i.x, f = i.y, g = i.size, p = i.centerIndexPos, _ = i.normIndexes; l <= d || !i.converged;) { var v = Zu(Math.min(l, a) / a); i.step = l++ , e = stressMinimizationStep(h, c, f, g, p, s, v, _, o), i.x = e.x, i.y = e.y, i.prevStress = i.stress, i.stress = constrainedStress(h, c, f, g, p, s, v, _), i.converged = i.converged || Math.abs(i.stress - i.prevStress) <= i.epsilon } return i.converged && (i.overlapRemoved || i.allowOverlap ? (i.done = !0, i.rings = Object.keys(i.rings).reduce(function (t, e) { return t[e] = i.rings[e].map(function (t) { return n[t] }), t }, {})) : (t.removeOverlaps(t, i, r), i.overlapRemoved = !0)), i }, isRunning: function (t) { var e = t.data; return !e.converged || !e.allowOverlap && !e.done }, onSync: function (t) { if (t.renderSteps || t.done) return Pb(t) }, onEnd: function (t, e) { return Pb(t) } }; function Pb(t) { for (var e = t.x, i = t.y, n = t.indexes.length, r = e[t.centerIndexPos] - t.cx, o = i[t.centerIndexPos] - t.cy, s = 0; s < n; s++)e[s] -= r, i[s] -= o; return { indexes: t.indexes, x: e, y: i } }
    /**
      * @preserve
      * @linkurious/force-layout @ 0.2.0
      * Ogma general-purpose force-directed layout
      */
    function Db() { return function () { var e = function (t) { var n, e = (n = 4022871197, function (t) { t = t.toString(); for (var e = 0; e < t.length; e++) { var i = .02519603282416938 * (n += t.charCodeAt(e)); i -= n = i >>> 0, n = (i *= n) >>> 0, n += 4294967296 * (i -= n) } return 2.3283064365386963e-10 * (n >>> 0) }); this.c = 1, this.s0 = e(" "), this.s1 = e(" "), this.s2 = e(" "), this.s0 -= e(String(t)), this.s0 < 0 && (this.s0 += 1), this.s1 -= e(String(t)), this.s1 < 0 && (this.s1 += 1), this.s2 -= e(t), this.s2 < 0 && (this.s2 += 1), e = null }; function i(t) { return new e(t.toString()).next() } e.prototype.next = function () { var e = this; return function () { var t = 2091639 * e.s0 + 2.3283064365386963e-10 * e.c; return e.s0 = e.s1, e.s1 = e.s2, e.s2 = t - (e.c = 0 | t) } }, e.prototype.nextDouble = function () { var t = this.next(); return function () { return t() + 11102230246251565e-32 * (2097152 * t() | 0) } }, e.prototype.nextInt32 = function () { var t = this.next(); return function () { return 4294967296 * t() | 0 } }; var st = i(42); function c(t) { st = i(t) } function k() { return 1e-6 * (st() - .5) } for (var n = [0, 1], r = [0, 2], t = 4; t < 65535; t <<= 2)for (var o = 0, s = n.length; o < s; o++)n.push(n[o] | t), r.push((n[o] | t) << 1); function x(t, e) { return (r[255 & e] | n[255 & t]) + 65536 * (r[e >> 8 & 255] | n[t >> 8 & 255]) + 4294967296 * (r[e >> 16 & 255] | n[t >> 16 & 255]) } function E(t, e) { var i = t ^ e, n = 65535 ^ i, r = 65535 ^ (t | e), o = t & (65535 ^ e), s = i | n >> 1, a = i >> 1 ^ i, u = r >> 1 ^ n & o >> 1 ^ r, l = i & r >> 1 ^ o >> 1 ^ o; a = (i = s) & (n = a) >> 2 ^ n & (i ^ n) >> 2, u ^= i & (r = u) >> 2 ^ n & (o = l) >> 2, l ^= n & r >> 2 ^ (i ^ n) & o >> 2, a = (i = s = i & i >> 2 ^ n & n >> 2) & (n = a) >> 4 ^ n & (i ^ n) >> 4, u ^= i & (r = u) >> 4 ^ n & (o = l) >> 4, l ^= n & r >> 4 ^ (i ^ n) & o >> 4, u ^= (i = s = i & i >> 4 ^ n & n >> 4) & (r = u) >> 8 ^ (n = a) & (o = l) >> 8; var d = t ^ e, h = (n = (l ^= n & r >> 8 ^ (i ^ n) & o >> 8) ^ l >> 1) | 65535 ^ (d | (i = u ^ u >> 1)); return ((h = 1431655765 & ((h = 858993459 & ((h = 252645135 & ((h = 16711935 & (h | h << 8)) | h << 4)) | h << 2)) | h << 1)) << 1 | (d = 1431655765 & ((d = 858993459 & ((d = 252645135 & ((d = 16711935 & (d | d << 8)) | d << 4)) | d << 2)) | d << 1))) >>> 0 } function A(t, e) { return function t(e, i, n, r) { if (!(r <= n)) { for (var o, s = i[n + r >> 1], a = n - 1, u = r + 1; ;) { for (; i[++a] < s;); for (; i[--u] > s;); if (u <= a) break; o = e[a], e[a] = e[u], e[u] = o, o = i[a], i[a] = i[u], i[u] = o } t(e, i, n, u), t(e, i, u + 1, r) } }(t, e, 0, t.length - 1) } var S, a, w = function (t, e, i) { this.left = null, this.right = null, this.code = t, this.left = e, this.right = i }, T = function (t, e) { this.code = t, this.data = e }, C = function (t, e) { this.code = t, this.data = e }; (a = S = S || {})[a.HILBERT = 1] = "HILBERT", a[a.MORTON = 0] = "MORTON"; function M() { this.left = null, this.right = null, this.data = null } function l(t) { for (var e = 1 << 31, i = 0; i < 31; i += 1) { if (e & t) return i; e >>>= 1 } return 32 } function I(t, e, i) { var n = t[e], r = t[i]; if (n === r) return e; for (var o, s = l(n ^ r), a = e, u = i - e; (o = a + (u = u + 1 >> 1)) < i && s < l(n ^ t[o]) && (a = o), 1 < u;); return a } var f = function (t, e) { void 0 === e && (e = {}); var i = e.getX, n = e.getY, r = e.bucketSize; void 0 === r && (r = 0); var o = e.sfc; void 0 === o && (o = S.HILBERT); var s = e.recursive; void 0 === s && (s = !0), this._bucketSize = 0, this._root = null; var a, u, l, d, h = t.length, c = new Uint32Array(h), f = 1 / 0, g = 1 / 0, p = -1 / 0, _ = -1 / 0; this._x = i, this._y = n; var v = o === S.HILBERT ? E : x; this._project = v; var m = new Uint32Array(h); for (u = 0; u < h; u++)(l = i(a = t[u])) < f && (f = l), (d = n(a)) < g && (g = d), p < l && (p = l), _ < d && (_ = d), m[u] = u; this._minX = f, this._minY = g, this._maxX = p, this._maxY = _; var y = 65535 / Math.max(p - f, 1), b = 65535 / Math.max(_ - g, 1); for (this._hw = y, this._hh = b, u = 0; u < h; u++)a = t[u], c[u] = v(y * (i(a) - f), b * (n(a) - g)); A(m, c), this._root = 0 === r ? s ? function t(e, i, n, r, o) { if (o - r == 0) return new T(n[r], e[i[r]]); var s = I(n, r, o), a = t(e, i, n, r, s), u = t(e, i, n, s + 1, o); return new w(s, a, u) }(t, m, c, 0, h - 1) : function (t, e, i, n, r) { for (var o = new M, s = [o], a = [n, r]; 0 !== s.length;) { var u = a.pop(), l = a.pop(), d = s.pop(); if (u - l == 0) d.code = i[l], d.data = t[e[l]]; else { var h = I(i, l, u); l <= (d.code = h) && (d.left = new M, s.push(d.left), a.push(l, h)), h < u && (d.right = new M, s.push(d.right), a.push(h + 1, u)) } } return o }(t, m, c, 0, h - 1) : s ? function t(e, i, n, r, o, s) { if (o - r < s) { for (var a = new Array(o - r + 1), u = r, l = 0; u <= o; u++ , l++)a[l] = e[i[u]]; return new C(n[r], a) } var d = I(n, r, o), h = t(e, i, n, r, d, s), c = t(e, i, n, d + 1, o, s); return new w(d, h, c) }(t, m, c, 0, h - 1, r) : function (t, e, i, n, r, o) { for (var s = new M, a = [s], u = [n, r]; 0 !== a.length;) { var l = u.pop(), d = u.pop(), h = a.pop(); if (l - d < o) { for (var c = new Array(l - d + 1), f = d, g = 0; f <= l; f++ , g++)c[g] = t[e[f]]; h.code = i[d], h.data = c } else { var p = I(i, d, l); d <= (h.code = p) && (h.left = new M, a.push(h.left), u.push(d, p)), p < l && (h.right = new M, a.push(h.right), u.push(p + 1, l)) } } return s }(t, m, c, 0, h - 1, r), this._bucketSize = r }, u = { root: { configurable: !0 } }; u.root.get = function () { return this._root }, f.prototype.inOrder = function (t, e) { for (var i = this._root, n = [], r = !1; !r;)if (i) n.push(i), i = i.left; else if (0 !== n.length) { if (i = n.pop(), t.call(e, i)) break; i = i.right } else r = !0; return this }, f.prototype.preOrder = function (t, e) { for (var i = [this._root]; 0 !== i.length;) { var n = i.pop(); t.call(e, n) || (n.right && i.push(n.right), n.left && i.push(n.left)) } return this }, f.prototype.postOrder = function (t, e) { var i, n = [], r = this._root; do { for (; r;)r.right && n.push(r.right), n.push(r), r = r.left; r = n.pop(), i = n.length - 1, r = r.right && n[i] === r.right ? (n[i] = r).right : (t.call(e, r), null) } while (0 !== n.length); return this }, f.prototype.map = function (e, i) { var n = []; return this.inOrder(function (t) { n.push(e.call(i, t)) }), n }, f.prototype.height = function () { return function t(e) { return e ? 1 + Math.max(t(e.left), t(e.right)) : 0 }(this._root) }, f.prototype.toString = function (t) { void 0 === t && (t = function (t) { return t.code.toString() }); var e = []; return function t(e, i, n, r, o) { if (e) { r(i + (n ? "^-- " : "|-- ") + o(e) + "\n"); var s = i + (n ? "    " : "|   "); e.left && t(e.left, s, !1, r, o), e.right && t(e.right, s, !0, r, o) } }(this._root, "", !0, function (t) { return e.push(t) }, t), e.join("") }, f.prototype.size = function () { var t = 0; return this.preOrder(function () { t++ }), t }, Object.defineProperties(f.prototype, u); var d = function (t) { return t.x }, h = function (t) { return t.y }, g = function (t) { return t.r }; function R(t, e, i, n) { void 0 === e && (e = d), void 0 === i && (i = h), void 0 === n && (n = g); for (var r, o = function (t) { for (var e = t.length - 1; 0 <= e; e--) { var i = Math.floor(Math.random() * (e + 1)); i = Math.max(Math.min(i, e), 0); var n = t[e]; t[e] = t[i], t[i] = n } return t }(t.slice()), s = o.length, a = [], u = 0; u < s;) { var l = o[u]; r && _(r, e(l), i(l), n(l)) ? u++ : (r = v(a = p(a, l, e, i, n), e, i, n), u = 0) } return r } function p(t, e, i, n, r) { var o = i(e), s = n(e), a = r(e), u = { x: o, y: s, r: a }; if (N(u, t, i, n, r)) return [e]; for (var l = 0; l < t.length; ++l) { var d = t[l], h = i(d), c = n(d), f = r(d); if (!L(u, h, c, f) && N(O(h, c, f, o, s, a), t, i, n, r)) return [t[l], e] } for (var g = 0; g < t.length - 1; g++)for (var p = g + 1; p < t.length; p++) { var _ = t[g], v = t[p], m = i(_), y = n(_), b = r(_), x = i(v), E = n(v), A = r(v); if (!L(O(m, y, b, x, E, A), o, s, a) && !L(O(m, y, b, o, s, a), x, E, A) && !L(O(x, E, A, o, s, a), m, y, b) && N(F(m, y, b, x, E, A, o, s, a), t, i, n, r)) return [t[g], t[p], e] } throw new Error } function L(t, e, i, n) { var r = t.r - n, o = e - t.x, s = i - t.y; return 0 <= r && o * o + s * s < r * r } function _(t, e, i, n) { var r = t.r - n + 1e-6, o = e - t.x, s = i - t.y; return 0 < r && o * o + s * s < r * r } function N(t, e, i, n, r) { for (var o = 0; o < e.length; ++o) { var s = e[o]; if (!_(t, i(s), n(s), r(s))) return !1 } return !0 } function v(t, e, i, n) { return 1 === t.length ? (r = e(t[0]), o = i(t[0]), s = n(t[0]), { x: r, y: o, r: s }) : 2 === t.length ? O(e(t[0]), i(t[0]), n(t[0]), e(t[1]), i(t[1]), n(t[1])) : F(e(t[0]), i(t[0]), n(t[0]), e(t[1]), i(t[1]), n(t[1]), e(t[2]), i(t[2]), n(t[2])); var r, o, s } function O(t, e, i, n, r, o) { var s = n - t, a = r - e, u = o - i, l = Math.sqrt(s * s + a * a); return { x: (t + n + s / l * u) / 2, y: (e + r + a / l * u) / 2, r: (l + i + o) / 2 } } function F(t, e, i, n, r, o, s, a, u) { var l = t - n, d = t - s, h = e - r, c = e - a, f = o - i, g = u - i, p = t * t + e * e - i * i, _ = p - n * n - r * r + o * o, v = p - s * s - a * a + u * u, m = d * h - l * c, y = (h * v - c * _) / (2 * m) - t, b = (c * f - h * g) / m, x = (d * _ - l * v) / (2 * m) - e, E = (l * g - d * f) / m, A = b * b + E * E - 1, S = 2 * (i + y * b + x * E), w = y * y + x * x - i * i, T = -(A ? (S + Math.sqrt(S * S - 4 * A * w)) / (2 * A) : w / S); return { x: t + y + b * T, y: e + x + E * T, r: T } } function m(g, e, i, t, n) { var y = t.X, b = t.Y, x = t.R, p = t.fx, _ = t.fy, E = t.masses, v = n.friction, m = n.theta, A = n.charge, r = Math.floor(Math.log(e.length)); null === i && (i = new f(e, { getX: function (t) { return y[t] }, getY: function (t) { return b[t] }, recursive: !0, bucketSize: r })).postOrder(function (t) { var e, i, n, r, o, s = 0; if (void 0 !== t.data) if (t.data.length) { var a = R(t.data, function (t) { return y[t] }, function (t) { return b[t] }, function (t) { return x[t] }); e = a.x, i = a.y, n = a.r; for (var u = 0; u < t.data.length; u++)s += E[t.data[u]] } else o = t.data, e = y[o], i = b[o], n = x[o], s = E[o]; else if (t.left && t.right) { var l = t.left.cx, d = t.left.cy, h = t.right.cx, c = t.right.cy, f = t.left.r, g = t.right.r, p = h - l, _ = c - d, v = g - f, m = Math.sqrt(p * p + _ * _); e = (l + h + p / m * v) / 2, i = (d + c + _ / m * v) / 2, n = (m + f + g) / 2, s = t.left.mass + t.right.mass } else e = (r = t.left || t.right).cx, i = r.cy, n = r.r, s = r.mass; t.cx = e, t.cy = i, t.r = n, t.mass = s }); for (var o = e.length, s = function (t) { var d = e[t], h = y[d], c = b[d], f = x[d]; i.preOrder(function (t) { var e = 0, i = 0, n = 0, r = h - t.cx || k(), o = c - t.cy || k(), s = r * r + o * o, a = f + t.r; if (t.data) { if (t.data === d) return !1; if (t.data.length) for (var u = 0; u < t.data.length; u++) { var l = t.data[u]; l !== d && (s = (r = h - y[l] || k()) * r + (o = c - b[l] || k()) * o, a = f + x[l], s < 1 && (s = Math.sqrt(1 * s)), e = A * E[l], i = g * e / s, p[d] += r * i, _[d] += o * i) } else s < 1 && (s = Math.sqrt(1 * s)), e = A * t.mass, s < a * a && (s = v * a * a), i = g * e / s, p[d] += r * i, _[d] += o * i } else if ((n = a / m) * n <= s) return s < 1 && (s = Math.sqrt(1 * s)), e = A * t.mass, s < a * a && (s = v * a * a), i = g * e / s, p[d] += r * i, _[d] += o * i, !0 }) }, a = 0; a < o; a++)s(a); return i } function y(t, e, i, n) { for (var r = i.sources, o = i.targets, s = i.X, a = i.Y, u = i.R, l = i.fx, d = i.fy, h = i.degrees, c = n.edgeStrength, f = n.edgeLength, g = 0; g < e.length; g++) { var p = e[g], _ = r[p], v = o[p], m = h[_] + 1, y = h[v] + 1, b = s[v] + l[v] - s[_] - l[_] || k(), x = a[v] + d[v] - a[_] - d[_] || k(), E = b * b + x * x, A = Math.sqrt(E), S = f + u[_] + u[v]; if (!(A <= S)) { var w = S - A, T = t * c * w * w / E / Math.min(m, y); b *= T, x *= T; var C = y / (y + m); l[_] += b * C, d[_] += x * C, l[v] -= b * (1 - C), d[v] -= x * (1 - C) } } } function b(t, e, i, n) { for (var r = i.pinned, o = i.X, s = i.Y, a = i.fx, u = i.fy, l = n.gravity, d = n.cx, h = n.cy, c = 0, f = 0, g = e.length, p = 0; p < g; p++)c += o[p], f += s[p]; c = c / g - d, f = f / g - h; for (var _ = 0; _ < g; _++) { var v = e[_]; r[v] || (o[v] -= c, s[v] -= f) } for (var m = 0; m < g; m++) { var y = e[m], b = d - o[y] || k(), x = h - s[y] || k(), E = l * t; a[y] += b * E, u[y] += x * E } } function P(t, e) { return void 0 === e && (e = 1), function (t) { for (var e = 0, i = 0, n = 0, r = t; n < r.length; n += 1) { var o = r[n]; e += o.w * o.h, i = Math.max(i, o.w) } t.sort(function (t, e) { return e.h - t.h }); for (var s = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / .95)), i), h: 1 / 0 }], a = 0, u = 0, l = 0, d = t; l < d.length; l += 1)for (var h = d[l], c = s.length - 1; 0 <= c; c--) { var f = s[c]; if (!(h.w > f.w || h.h > f.h)) { if (h.x = f.x, h.y = f.y, u = Math.max(u, h.y + h.h), a = Math.max(a, h.x + h.w), h.w === f.w && h.h === f.h) { var g = s.pop(); c < s.length && (s[c] = g) } else h.h === f.h ? (f.x += h.w, f.w -= h.w) : (h.w === f.w || s.push({ x: f.x + h.w, y: f.y, w: f.w - h.w, h: h.h }), f.y += h.h, f.h -= h.h); break } } }(t.map(function (t) { return t.w += t.maxr + e, t.h += t.maxr + e, t }).sort(function (t, e) { return t.w * t.h - e.w * e.h })) } m.initialize = function (t, e, i) { for (var n = e.X, r = e.Y, o = e.R, s = e.degrees, a = e.layer, u = e.pinned, l = e.component, d = e.masses, h = e.nodeIds, c = (e.cluster, e.layers, e.parent, i.scaling), f = i.defaultRadius, g = t.length, p = 1 / 0, _ = 1 / 0, v = -1 / 0, m = -1 / 0, y = Math.PI * (3 - Math.sqrt(5)), b = 0; b < t.length; b++) { var x = t[b], E = x.x, A = x.y, S = x.r, w = x.mass; if (isNaN(E) || isNaN(A)) { var T = 10 * Math.sqrt(b), C = b * y; E = T * Math.cos(C), A = T * Math.sin(C) } n[b] = E, r[b] = A, o[b] = S || f, u[b] = x.pinned ? 1 : 0, a[b] = x.layer, l[b] = x.component, d[b] = void 0 === w ? (1 + s[b]) * c : w, h[b] = b, E < p && (p = E), A < _ && (_ = A), v < E && (v = E), m < A && (m = A) } if (1 < t.length && (v - p == 0 || m - _ == 0)) for (var M = (p + v) / 2, I = (_ + m) / 2, L = 0; L < g; L++)if (!u[L]) { var N = 10 * Math.sqrt(L), k = L * y, O = M + N * Math.cos(k), F = I + N * Math.sin(k); (n[L] = O) < p && (p = O), (r[L] = F) < _ && (_ = F), v < O && (v = O), m < F && (m = F) } }, y.initialize = function (t, e) { for (var i = e.edgeIds, n = e.sources, r = e.targets, o = e.degrees, s = 0; s < t.length; s++) { var a = t[s], u = a.source, l = a.target; n[s] = u, r[s] = l, o[u]++ , o[l]++ , i[s] = s } }, b.initialize = function (t, e, i) { var n = e.X, r = e.Y, o = i.cx, s = i.cy, a = t.length; if (void 0 === o || void 0 === s) { o = s = 0; for (var u = 0; u < a; u++)o += n[u], s += r[u]; o /= a, s /= a } i.cx = o, i.cy = s }; var D, z, B = function () { this.ids = [], this.xmin = 1 / 0, this.ymin = 1 / 0, this.xmax = -1 / 0, this.ymax = -1 / 0, this.x = 0, this.y = 0, this.w = 0, this.h = 0, this.cx = 0, this.cy = 0, this.radius = 0, this.mx = 0, this.my = 0, this.m = 0, this.maxr = 0 }; function at(t, e) { return (t + e) * (t + e + 1) / 2 + e } function U(t, M, I) { var e = t.edgeIds, i = t.sources, n = t.targets, u = t.pinned, L = t.degrees, N = t.X, k = t.Y, O = t.R; void 0 === M && (M = 0), void 0 === I && (I = .5); for (var l = {}, F = {}, r = 0, o = e; r < o.length; r += 1) { var s = o[r], a = i[s], d = n[s]; a !== d && (l[a] = l[a] || {}, l[d] = l[d] || {}, l[a][d] = !0, l[d][a] = !0) } Object.keys(l).forEach(function (t) { var e, i, n = Number(t), r = Object.keys(l[Number(n)]); if (2 === r.length) { var o = r[0], s = r[1], a = (e = Number(o), i = Number(s), e < i ? e * i + Math.pow(i - e - 1, 2) / 4 : e * i + Math.pow(e - i - 1, 2) / 4); a in F || (F[a] = [Number(s), Number(o)]), u[n] || F[a].push(n) } }), Object.keys(F).forEach(function (t) { var e = F[Number(t)], i = e[0], n = e[1], r = e.slice(2); if (1 !== r.length) { var o = N[i], s = k[i], a = N[n], u = k[n], l = L[i], d = .25 + .5 * l / (l + L[n]), h = o + (a - o) * d, c = s + (u - s) * d, f = -(u - s), g = a - o, p = Math.sqrt(Math.pow(o - a, 2) + Math.pow(s - u, 2)); f = -2 * f / p, g = -2 * g / p; var _ = Math.acos(f / Math.sqrt(f * f + g * g)); 0 < M && (_ < M || _ > Math.PI - M && _ <= Math.PI ? (f = 2 * Math.cos(Math.PI - M), g = 2 * Math.sin(Math.PI - M)) : (_ > 2 * Math.PI - M || _ >= Math.PI && _ < Math.PI + M) && (f = 2 * Math.cos(M), g = 2 * Math.sin(M))); var v = 0, m = 1; r.sort(function (t, e) { return O[e] - O[t] }); var y = 0, b = 0, x = Math.max(O[r[0]], O[r[1]]) / 2; r.length % 2 == 1 && (v = 1, h -= f * x, c -= g * x); for (var E = 1 + I, A = 0; A < r.length; A++) { var S = (v + A) % 2, w = r[A], T = 2 <= A ? O[w] : x, C = (S ? y : b) + T; N[w] = h + f * m * C, k[w] = c + g * m * C, S ? y += T * E : b += T * E, m = -m } } }) } function V(t, e, i, n) { var r = i.X, o = i.Y, s = i.R, a = i.components, u = i.pinned, l = i.degrees, d = i.sources, h = i.targets, c = i.edgeIds, f = n.update, g = n.onUpdate, p = n.placement, _ = n.placementOffset, v = n.alignSiblings, m = n.siblingsMinAngle, y = n.siblingsOffset; if (v && (U({ X: r, Y: o, R: s, degrees: l, pinned: u, sources: d, targets: h, edgeIds: c }, m, y), f(t, r, o)), p in D) { var b = function (t, e, i, n) { for (var r = 0, o = [], s = 0, a = n; s < a.length; s += 1) { for (var u = a[s], l = new B, d = 0, h = u; d < h.length; d += 1) { var c = h[d]; l.add(c, t[c], e[c], i[c]) } o.push(l.measure()), u.length > o[r].ids.length && (r = o.length - 1) } return { boxes: o, biggest: r } }(r, o, s, a), x = b.boxes, E = b.biggest; if (p === D.spiral) !function (t, e, i, n, r) { void 0 === e && (e = 20); for (var o = 0, s = t; o < s.length; o += 1) { var a = s[o], u = R(a.ids, function (t) { return i[t] }, function (t) { return n[t] }, function (t) { return r[t] }), l = u.x, d = u.y, h = u.r; a.cx = l, a.cy = d, a.radius = h + e } for (var c = t.slice().sort(function (t, e) { return t.radius - e.radius }), f = c.map(function (t) { return { x: t.cx, y: t.cy, r: t.radius } }), g = c.pop(), p = 3 * Math.PI / 2, _ = g.radius, v = 2 * Math.PI, m = g.cx, y = g.cy, b = [g], x = function () { var n = c[c.length - 1], t = _ + n.radius, r = m + Math.cos(p) * t, o = y + Math.sin(p) * t; b.some(function (t) { var e = t.cx - r, i = t.cy - o; return Math.sqrt(e * e + i * i) < t.radius + n.radius }) ? _ += 1 : (n.x = r - n.w / 2, n.y = o - n.h / 2, n.cx = r, n.cy = o, f[c.length - 1].x = r, f[c.length - 1].y = o, b.push(c.pop()), p += (2 * n.radius + 1) / t * 1 % v) }; 0 !== c.length;)x() }(x, _, r, o, s); else { if (p !== D.box) return; P(x, _) } for (var A = x[E].xmin - x[E].x, S = x[E].ymin - x[E].y, w = 0, T = x; w < T.length; w += 1)for (var C = T[w], M = C.xmin, I = C.ymin, L = M - C.x - A, N = I - C.y - S, k = 0, O = C.ids; k < O.length; k += 1) { var F = O[k]; r[F] -= L, o[F] -= N } f(t, r, o), g() } } function j(p, _, t, e, v, i) { var m, y = t.X, b = t.Y, x = t.R, E = t.degrees, A = t.nodeIds, S = t.edgeIds, n = t.layers, r = t.layer, w = t.cluster, T = t.masses, o = t.weights, s = t.sources, a = t.targets, C = e.cx, M = e.cy, I = e.nextTick, u = e.cancelTick, L = e.update, N = e.onUpdate, k = e.batch, O = e.maxIterations, l = e.steps, F = e.minMovement, R = n.slice(), P = 0; function D() { u(m), L(p, y, b), N(), i() } for (var z = {}, d = 0; d < _.length; d++)z[Number(_[d].id) || d] = d; for (var h = new Map, c = 0; c < S.length; c++) { var f = S[c]; h.set(at(s[f], a[f]), f) } for (var g = 0; g < n.length; g++) { for (var B = n[g], U = g, V = 0; V < B.length; V++) { var j = B[V], G = w[j]; -1 !== G && (T[G] += T[j]) } for (var H = 0; H < _.length; H++) { var q = _[H], W = Number(q.id) || H, X = q.source, Y = q.target, Z = o[z[W]]; if (r[X] === U && r[Y] === U) { var K = w[X], Q = w[Y]; if (K !== Q) { var J = h.get(at(K, Q)); void 0 !== J && (o[J] += Z) } } } } A.length = 0, S.length = 0, O = 1 / 0; var $, tt, et = 1, it = 0, nt = 1 - Math.pow(.1, 1 / l / 2), rt = (et - .1) / l, ot = .5; return m = setTimeout(function t() { var e = v(et += (it - et) * nt, A, S), i = et <= ot || e < F; if (0 === P || i) { var n = R.pop(); if (n) { $ && (tt = $.reduce(function (t, e) { return Math.max(t, C - y[e], M - b[e]) }, 0)), A.push.apply(A, n); for (var r = 0; r < n.length; r++) { var o = n[r], s = w[o]; if (-1 !== s) { var a = 1 < E[o] ? 2 : 1, u = x[s] + x[o]; T[s] -= T[o], y[o] = y[s] + a * u * (2 * st() - 1), b[o] = b[s] + a * u * (2 * st() - 1) } else $ && (y[o] = C + 2 * tt * (1 - 2 * st()), b[o] = M + 2 * tt * (1 - 2 * st())) } $ = n; for (var l = A.reduce(function (t, e) { return t[e] = !0, t }, {}), d = S.length = 0; d < _.length; d++) { var h = _[d], c = h.source, f = h.target, g = h.id; l[c] && l[f] && S.push(z[Number(g)]) } i = !1, et = 0 === R.length ? .2 : .1 + 2 * rt, ot = .1 } } P % k == 0 && (L(p, y, b), N()), ++P >= O || i ? D() : m = I(t) }), { done: !1, stop: function () { return D(), this }, get iterations() { return P } } } function G(t, e, i) { for (var n = i.X, r = i.Y, o = i.fx, s = i.fy, a = i.pinned, u = 0, l = t.length, d = 0; d < l; d++) { var h = t[d], c = o[h] *= e, f = s[h] *= e; if (a[h]) o[h] = s[h] = 0; else { var g = c, p = f; if (1e4 < g || 1e4 < p) { var _ = Math.sqrt(g * g + p * p); p /= _, g /= _ } n[h] += g, r[h] += p, u += .5 * (g * g + p * p) } } return u } B.prototype.add = function (t, e, i, n) { this.ids.push(t), e - n < this.xmin && (this.xmin = e - n), i - n < this.ymin && (this.ymin = i - n), e + n > this.xmax && (this.xmax = e + n), i + n > this.ymax && (this.ymax = i + n), n > this.maxr && (this.maxr = n), this.mx += n * e, this.my += n * i, this.m += n }, B.prototype.measure = function (t) { return void 0 === t && (t = 0), this.w = this.xmax - this.xmin + 2 * t, this.h = this.ymax - this.ymin + 2 * t, this.cx = this.mx / this.m, this.cy = this.my / this.m, this.x = this.xmin, this.y = this.ymin, this.radius = Math.sqrt(this.w * this.w + this.h * this.h) / 2, this }, (z = D = D || {}).none = "none", z.box = "box", z.spiral = "spiral"; var H = 0, q = "undefined" == typeof window, W = "undefined" != typeof performance && performance.now ? performance : Date, X = q ? function (t) { var e = W.now(), i = Math.max(0, 16 - (e - H)), n = setTimeout(function () { return t(e + i) }, i); return H = e + i, n } : window.requestAnimationFrame, Y = q ? function (t) { return clearTimeout(t) } : window.cancelAnimationFrame; function Z(t, e, i) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.x = e[n], r.y = i[n] } } function K() { } function Q(t) { for (var e in void 0 === t && (t = {}), this.onUpdate = K, this.update = Z, this.nextTick = X, this.cancelTick = Y, this.onEnd = K, this.charge = 10, this.maxIterations = 1e3, this.minMovement = .1, this.edgeLength = 30, this.edgeStrength = 2, this.friction = .1, this.elasticity = .9, this.margin = 1, this.cx = void 0, this.cy = void 0, this.gravity = .01, this.theta = .34, this.batch = 1, this.inertia = .9, this.integrator = 0, this.multilevel = !1, this.placement = D.none, this.placementOffset = 10, this.alignSiblings = !1, this.siblingsMinAngle = 0, this.siblingsOffset = .15, this.steps = 300, this.scaling = 1, this.defaultRadius = 1, t) void 0 !== t[e] && (this[e] = t[e]) } function J(t, e, i) { !function (t, e, i) { for (var n = i.sources, r = i.targets, o = i.degrees, s = i.nodeIds, a = i.edgeIds, u = (i.layers, {}), l = 0; l < t.length; l++)u[l] = s[l] = l; for (var d = 0; d < e.length; d++) { var h = e[d], c = h.source, f = h.target, g = u[c], p = u[f]; a[d] = d, n[d] = g, r[d] = p, o[g]++ , o[p]++ } }(t, e, i), function (t) { for (var e = t.nodeIds, i = t.edgeIds, n = t.sources, r = t.targets, o = t.degrees, s = t.layer, a = t.layers, u = t.component, l = t.components, d = t.cluster, h = t.parent, c = 0, f = 1, g = new Uint32Array(e.length), p = 0; p < e.length; p++)g[p] = o[p]; for (var _ = new Array(e.length), v = 0; v < i.length; v++) { var m = i[v], y = n[m], b = r[m]; _[y] = _[y] || [], _[b] = _[b] || [], _[y].push(b), _[b].push(y) } var x = new Uint8Array(e.length), E = new Uint8Array(e.length); h.fill(-1); for (var A = 0, S = 0; S < e.length; S++)if (0 === x[S]) { for (var w = [S]; 0 !== w.length;) { var T = w.pop(); 0 === x[T] && (w.push.apply(w, _[T]), x[T] = 1, u[T] = A) } A++ } for (var C = new Array(e.length), M = 0; M < e.length; M++)s[M] = 0, C[M] = M; for (; 0 !== C.length;) { for (var I = [], L = [], N = 0; N < C.length; N++)g[C[N]] <= c && (I.push(N), L.push(C[N])); for (var k = 0; k < L.length; k++) { var O = L[k]; E[O] = c, s[O] = f; var F = _[O]; if (F) for (var R = 0; R < F.length; R++)g[F[R]]-- } for (var P = 0; P < L.length; P++) { var D = L[P], z = _[D]; if (z) for (var B = 0; B < z.length; B++) { var U = z[B], V = s[U]; if (void 0 === V || f < V) { h[D] = U; break } } } I.reverse(); for (var j = 0; j < I.length; j++)C.splice(I[j], 1); if (f += 1, 0 < C.length) { for (var G = 1 / 0, H = 0; H < C.length; H++) { var q = g[C[H]]; q < G && (G = q) } c + 1 <= G && (c = G, f = 1) } } x.fill(0); for (var W = 0; W < e.length; W++) { var X = e[W], Y = s[X]; if (-1 === h[X] || s[h[X]] === Y) { var Z = [X]; for (x.fill(0); 0 !== Z.length;) { var K = Z.pop(); if (!x[K]) { if (s[K] > Y) { h[X] = K; break } var Q = _[K]; x[K] = 1, Q && Z.push.apply(Z, Q) } } } } for (var J = 0; J < e.length; J++) { var $ = e[J], tt = u[$]; l[tt] = l[tt] || [], l[tt].push($); var et = s[$] - 1; a[et] = a[et] || [], a[et].push($), d[$] = h[$] } }(i) } function $(t) { var e = t.nodes.length, i = t.edges.length; c(e + i), this.X = new Array(e), this.Y = new Array(e), this.R = new Array(e), this.fx = new Float32Array(e), this.fy = new Float32Array(e), this.vx = new Float32Array(e), this.vy = new Float32Array(e), this.pinned = new Uint8Array(e), this.masses = new Float32Array(e), this.weights = new Float32Array(i), this.sources = new Uint16Array(i), this.targets = new Uint16Array(i), this.degrees = new Uint32Array(e), this.layer = new Uint32Array(e), this.parent = new Int32Array(e), this.cluster = new Int32Array(e), this.component = new Uint16Array(e), this.components = [], this.layers = [], this.nodeIds = new Array(e), this.edgeIds = new Array(i), J(t.nodes, t.edges, this) } function tt(t) { this.promise = new Promise(t) } tt.prototype.then = function (t) { return this.promise.then(t) }, tt.prototype.stop = function () { return this.simulation.stop(), this }, tt.prototype.iterations = function () { return this.simulation.iterations }; var et = { euler: function (t, e, i) { for (var n = i.X, r = i.Y, o = i.fx, s = i.fy, a = i.vx, u = i.vy, l = i.masses, d = i.pinned, h = 0, c = 0, f = t.length, g = 0; g < f; g++) { var p = t[g], _ = l[p], v = o[p] / _, m = s[p] / _; a[p] += 1 / 8 * v, u[p] += 1 / 8 * m; var y = .2 * a[p] * (1 / 8) + .5 * v * (1 / 8) * (1 / 8), b = .2 * u[p] * (1 / 8) + .5 * m * (1 / 8) * (1 / 8); o[p] = s[p] = 0, d[p] || (n[p] += y, r[p] += b, h += Math.abs(y) * _, c += Math.abs(b) * _) } return (h * h + c * c) / f }, verlet: G, leapfrog: function (t, e, i) { for (var n = i.X, r = i.Y, o = i.fx, s = i.fy, a = i.vx, u = i.vy, l = i.pinned, d = i.masses, h = t.length, c = 0, f = 0; f < h; f++) { var g = t[f], p = d[g], _ = o[g] / p, v = s[g] / p, m = a[g] + 1 * _, y = u[g] + 1 * v, b = 1 * m, x = 1 * y; 1e4 < b && (b = .1), 1e4 < x && (x = .1), a[g] = e * (m + a[g]) / 2, u[g] = e * (y + u[g]) / 2, o[g] = s[g] = 0, l[g] || (n[g] += b, r[g] += x), c += .5 * (b * b + x * x) } return c } }; function force(t, e) { var i, n; void 0 === e && (e = {}); function r(t) { return void 0 === t && (t = { nodes: [], edges: [] }), i = t.nodes, n = t.edges, c(at(i.length, n.length)), new $(t) } function o(t) { return void 0 === t && (t = {}), new Q(t) } var s = r(t), a = o(e); r(t), o(e), y.initialize(n, s), m.initialize(i, s, a), b.initialize(i, s, a); function u(t, e, i) { return h = null, e.length <= 1 ? 0 : (h = m(t, e, h, s, a), y(t, i, s, a), 0 !== a.elasticity && function (e, i, t, n) { var w = t.X, T = t.Y, C = t.R, M = t.fx, I = t.fy, L = n.margin, N = n.elasticity; if (0 === N) return; if (!i) { var r = Math.floor(Math.log(e.length)); (i = new f(e, { getX: function (t) { return w[t] }, getY: function (t) { return T[t] }, bucketSize: r })).postOrder(function (t) { var e, i, n, r, o; if (t.data) o = t.data, e = w[o], i = T[o], n = C[o]; else if (t.left && t.right) { var s = t.left.cx, a = t.left.cy, u = t.right.cx, l = t.right.cy, d = t.left.r, h = t.right.r, c = u - s, f = l - a, g = h - d, p = Math.sqrt(c * c + f * f); e = (s + u + c / p * g) / 2, i = (a + l + f / p * g) / 2, n = (p + d + h) / 2 } else (r = t.left || t.right) && (e = r.cx, i = r.cy, n = r.r); t.cx = e, t.cy = i, t.r = n }) } for (var o = function (t) { var x = e[t], E = w[x] + M[x], A = T[x] + I[x], S = C[x]; i.preOrder(function (t) { if (!t.data) { var e = t.cx - E, i = t.cy - A, n = t.r + S; return n * n < e * e + i * i } if (t.data.length) for (var r = 0; r < t.data.length; r++) { var o = t.data[r]; if (x < o) { var s = C[o], a = E - w[o], u = A - T[o], l = S + s + L, d = a * a + u * u; if (d < l * l) { 0 === a && (d += (a = k()) * a), 0 === u && (d += (u = k()) * u); var h = (l - (d = Math.sqrt(d))) * N / d, c = s / l; M[x] += a * h * c, I[x] += u * h * c, M[o] -= a * h * (1 - c), I[o] -= u * h * (1 - c) } } } else { var f = t.data; if (x < f) { var g = C[f], p = E - w[f], _ = A - T[f], v = S + g + L, m = p * p + _ * _; if (m < v * v) { 0 === p && (m += (p = k()) * p), 0 === _ && (m += (_ = k()) * _); var y = (v - (m = Math.sqrt(m))) * N / m, b = g / v; M[x] += p * y * b, I[x] += _ * y * b, M[f] -= p * y * (1 - b), I[f] -= _ * y * (1 - b) } } } }) }, s = 0; s < e.length; s++)o(s) }(e, h, s, a), b(t, e, s, a), d(e, a.inertia, s)) } var l, d = et[a.integrator] || G, h = null; return { setOptions: o, setGraph: r, start: function () { return l = (a.multilevel ? j : function (i, t, e, n, r, o) { function s() { A = !0, f(a), y(), o() } var a, u = e.X, l = e.Y, d = e.nodeIds, h = e.edgeIds, c = n.nextTick, f = n.cancelTick, g = n.batch, p = n.maxIterations, _ = n.steps, v = n.minMovement, m = n.update, y = n.onUpdate, b = 0, x = 1, E = 1 - Math.pow(.1, 1 / _), A = !1, S = function () { var t = r(x += (0 - x) * E, d, h), e = A || x < .1 || t <= v; b % g == 0 && (m(i, u, l), y()), ++b < p && !e ? a = c(S) : s() }; return a = setTimeout(S), { done: !1, stop: function () { return s(), this }, get iterations() { return b } } })(i, n, s, a, u, function () { l.done || V(i, 0, s, a), a.onEnd(), l.done = !0 }), this }, iterations: function () { return l.iterations }, data: function () { return s }, stop: function () { return l && l.stop(), this }, step: function (t) { return void 0 === t && (t = 1), u(t, s.nodeIds, s.edgeIds), this } } } return force.run = function (e, i) { var n, t = new tt(function (t) { i.onEnd = t, n = force(e, i).start() }); return t.simulation = n, t.stop = function () { return n.stop(), t }, t.iterations = function () { return n.iterations }, t }, force }().apply(this, arguments) } var zb = { imports: { force: Db }, configure: function (t, e) { var i = e.graph, n = t.nodes._indexes, r = i.getNodeAttribute("x").getMultiple(n), o = i.getNodeAttribute("y").getMultiple(n), s = i.getNodeAttribute("radius").getMultiple(n), a = i.getNodeAttribute("layoutable").getMultiple(n), u = t.nodes.getAdjacentEdges(), l = [], d = [], h = {}; void 0 !== t.edgeStrength ? t.edgeStrength = 1.5 * t.edgeStrength : t.edgeStrength = .75, null == t.gravity && (t.gravity = .05), null == t.siblingsOffset && (t.siblingsOffset = 0), t.alignSiblings = !!t.alignSiblings; for (var c = t.radiusRatio || 1.25, f = 0; f < t.nodes._indexes.length; f++) { var g = t.nodes._indexes[f]; h[g] = f, l.push({ id: f, x: r[f], y: o[f], r: s[f] * c, pinned: !a[f] }) } u.forEach(function (t) { var e = h[t.getSource()._index], i = h[t.getTarget()._index]; e !== i && void 0 !== e && void 0 !== i && d.push({ source: e, target: i }) }); var p = K(C({}, t)); return delete p.nodes, { graph: { nodes: l, edges: d }, options: p, indexes: t.nodes._indexes, done: !1, x: r, y: o } }, update: function (t, n) { if (!n.simulation) { n.graph = t.graph, n.options = t.options, n.indexes = t.indexes, t.options.nextTick = function (t) { return t() }, t.options.update = function (t, e, i) { n.x = e, n.y = i }, t.options.onEnd = function () { return n.done = !0 }; var e = Db(t.graph, t.options).start(), i = e.data(), r = i.X, o = i.Y; n.simulation = e, n.x = r, n.y = o } return { graph: n.graph, indexes: n.indexes, x: n.x, y: n.y } }, context: function () { return { done: !1, graph: null, x: null, y: null, indexes: null } }, isRunning: function (t) { return !t.done }, onSync: function (t) { return { indexes: t.indexes, x: t.x, y: t.y } } }; function minDisk(t, e, i, n) { var r; if (n) r = n; else { r = new Uint32Array(t.length); for (var o = 0, s = t.length; o < s; o++)r[o] = o } var a = i ? function (t, e, i, n, r, o) { var s = i - t, a = n - e, u = o - r, l = Math.sqrt(s * s + a * a); return [(t + i + s / l * u) / 2, (e + n + a / l * u) / 2, (l + r + o) / 2] } : function (t, e, i, n) { var r = t - i, o = e - n; return [(t + i) / 2, (e + n) / 2, Math.sqrt(r * r + o * o) / 2] }, u = i ? function (t, e, i, n, r, o, s, a, u) { var l = 2 * (t - i), d = 2 * (e - n), h = 2 * (a - s), c = t * t + e * e - s * s - i * i - n * n + a * a, f = 2 * (t - r), g = 2 * (e - o), p = 2 * (u - s), _ = t * t + e * e - s * s - r * r - o * o + u * u, v = f * d - l * g, m = (d * _ - g * c) / v - t, y = (g * h - d * p) / v, b = (f * c - l * _) / v - e, x = (l * p - f * h) / v, E = y * y + x * x - 1, A = 2 * (m * y + b * x + s), S = m * m + b * b - s * s, w = (-A - Math.sqrt(A * A - 4 * E * S)) / (2 * E); return [m + y * w + t, b + x * w + e, w] } : function (t, e, i, n, r, o) { var s = 2 * (t * (n - o) + i * (o - e) + r * (e - n)); if (0 == s) return null; var a = ((t * t + e * e) * (n - o) + (i * i + n * n) * (o - e) + (r * r + o * o) * (e - n)) / s, u = ((t * t + e * e) * (r - i) + (i * i + n * n) * (t - r) + (r * r + o * o) * (i - t)) / s, l = a - t, d = u - e; return [a, u, Math.sqrt(l * l + d * d)] }, l = i ? ad : sd; return i = i || [], function t(e, i, n, r, o, s, a, u, l) { var d, h, c, f, g, p, _, v, m, y, b, x = null; if (0 === n || 3 === i.length) h = r, c = o, f = s, g = u, p = l, y = null, 1 === (b = (d = i).length) ? y = [h[_ = d[0]], c[_], f[_] || 0] : 2 === b ? (_ = d[0], v = d[1], y = g(h[_], c[_], h[v], c[v], f[_], f[v])) : 3 === b && (_ = d[0], v = d[1], m = d[2], y = p(h[_], c[_], h[v], c[v], h[m], c[m], f[_], f[v], f[m])), x = y; else { var E = e[n - 1]; null !== (x = t(e, i, n - 1, r, o, s, a, u, l)) && a(x, r[E], o[E], s[E]) || (i.push(E), x = t(e, i, n - 1, r, o, s, a, u, l), i.pop()) } return x }(r = function (t) { for (var e = t.length - 1; 0 <= e; e--) { var i = Math.floor(Math.random() * (e + 1)); i = Math.max(Math.min(i, e), 0); var n = t[e]; t[e] = t[i], t[i] = n } return t }(r), [], r.length, t, e, i, l, a, u) } function Bb(t) { for (var e, i, n, r = t.length, o = [0, 1], s = 2, a = 2; a < r; a++) { for (; 1 < s && (e = t[o[s - 2]], i = t[o[s - 1]], n = t[a], (i[0] - e[0]) * (n[1] - e[1]) - (i[1] - e[1]) * (n[0] - e[0]) <= 0);)--s; o[s++] = a } return o.slice(0, s) } function Ub(t) { var e = t.length; if (e < 3) return null; for (var i = new Array(e), n = new Array(e), r = 0; r < e; r++)i[r] = [+t[r][0], +t[r][1], r]; i.sort(function (t, e) { return t[0] - e[0] || t[1] - e[1] }); for (r = 0; r < e; r++)n[r] = [i[r][0], -i[r][1]]; var o = Bb(i), s = Bb(n), a = s[s.length - 1], u = o[o.length - 1], l = s[0] === o[0], d = a === u ? 1 : 0, h = []; for (r = o.length - 1; 0 <= r; --r)h.push(t[i[o[r]][2]]); for (r = +l; r < s.length - d; r++)h.push(t[i[s[r]][2]]); return h } var Vb, jb = (function (t) { function e(t) { if (!(this instanceof e)) return new e(t); this.points = t || [] } function _(t, e, i) { return 0 < (e[0] - t[0]) * (i[1] - t[1]) - (e[1] - t[1]) * (i[0] - t[0]) } function v(t, e) { return _(t, e.dest, e.orig) } function m(t, e) { return _(t, e.orig, e.dest) } function y(t, e) { return v(t.dest, e) } function b(t, e, i, n) { if (t[0] === n[0] && t[1] === n[1] || e[0] === n[0] && e[1] === n[1] || i[0] === n[0] && i[1] === n[1]) return !1; var r = t[0] * t[0] + t[1] * t[1], o = e[0] * e[0] + e[1] * e[1], s = i[0] * i[0] + i[1] * i[1], a = n[0] * n[0] + n[1] * n[1], u = s - a, l = i[1] - n[1], d = i[1] * a - s * n[1], h = i[0] - n[0], c = i[0] * a - s * n[0], f = i[0] * n[1] - i[1] * n[0]; return 1 < t[0] * (e[1] * u - o * l + d) - t[1] * (e[0] * u - o * h + c) + r * (e[0] * l - e[1] * h + f) - e[0] * d + e[1] * c - o * f } function s(t, e, i) { this.onext = t, this.rot = e, this.orig = i, this.mark = !1 } function x(t, e) { var i = new s(null, null, t), n = new s(null, null, null), r = new s(null, null, e), o = new s(null, null, null); return i.onext = i, r.onext = r, (n.onext = o).onext = n, (((i.rot = n).rot = r).rot = o).rot = i } function E(t, e) { var i = t.onext.rot, n = e.onext.rot, r = t.onext, o = n.onext, s = i.onext; t.onext = e.onext, e.onext = r, i.onext = o, n.onext = s } function A(t, e) { var i = x(t.dest, e.orig); return E(i, t.lnext), E(i.sym, e), i } function S(t) { E(t, t.oprev), E(t.sym, t.sym.oprev) } e.prototype = { triangulate: function () { var t = this.points; t.sort(function (t, e) { return t[0] === e[0] ? t[1] - e[1] : t[0] - e[0] }); for (var e = t.length - 1; 1 <= e; e--)t[e][0] === t[e - 1][0] && t[e][1] === t[e - 1][1] && t.splice(e, 1); if (t.length < 2) return {}; for (var i = function t(e) { var i, n, r, o; { if (2 === e.length) return { le: i = x(e[0], e[1]), re: i.sym }; if (3 === e.length) return i = x(e[0], e[1]), n = x(e[1], e[2]), E(i.sym, n), _(e[0], e[1], e[2]) ? (r = A(n, i), { le: i, re: n.sym }) : _(e[0], e[2], e[1]) ? { le: (r = A(n, i)).sym, re: r } : { le: i, re: n.sym }; for (var s = Math.ceil(e.length / 2), a = t(e.slice(0, s)), u = t(e.slice(s)), l = a.le, d = a.re, h = u.le, c = u.re; ;)if (m(h.orig, d)) d = d.lnext; else { if (!v(d.orig, h)) break; h = h.rprev } var f = A(h.sym, d); for (d.orig === l.orig && (l = f.sym), h.orig === c.orig && (c = f); ;) { var g = f.sym.onext; if (y(g, f)) for (; b(f.dest, f.orig, g.dest, g.onext.dest);)o = g.onext, S(g), g = o; var p = f.oprev; if (y(p, f)) for (; b(f.dest, f.orig, p.dest, p.oprev.dest);)o = p.oprev, S(p), p = o; if (!y(g, f) && !y(p, f)) break; f = !y(g, f) || y(p, f) && b(g.dest, g.orig, p.orig, p.dest) ? A(p, f.sym) : A(f.sym, g.sym) } return { le: l, re: c } } }(t).le, n = [], r = 0, o = [i]; m(i.onext.dest, i);)i = i.onext; for (var s = i; o.push(s.sym), s.mark = !0, (s = s.lnext) !== i;); do { var a = o[r++]; if (!a.mark) for (s = a; n.push(s.orig), s.sym.mark || o.push(s.sym), s.mark = !0, (s = s.lnext) != a;); } while (r < o.length); return n } }, s.prototype = { get sym() { return this.rot.rot }, get dest() { return this.sym.orig }, get rotSym() { return this.rot.sym }, get oprev() { return this.rot.onext.rot }, get dprev() { return this.rotSym.onext.rotSym }, get lnext() { return this.rotSym.onext.rot }, get lprev() { return this.onext.sym }, get rprev() { return this.sym.onext } }, e.prototype.ccw = _, e.prototype.rightOf = v, e.prototype.leftOf = m, e.prototype.inCircle = b, t.exports = e }(Vb = { exports: {} }, Vb.exports), Vb.exports); function Gb(t, e, i, n, convexhull) { if (void 0 === e && (e = 1), void 0 === i && (i = 0), !n || !convexhull) { var r = t.map(function (t) { return [t.x, t.y] }); n = new jb(r.slice()).triangulate(), convexhull = Ub(r) } for (var o, s, a, u, l, d, h, c, f, g, p = i * i, _ = [], v = {}, m = 0; m < n.length; m += 3) { if (Hb(convexhull, qb(n[m], n[m + 1], n[m + 2]))) p < (E = (o = n[m], s = n[m + 1], a = n[m + 2], void 0, u = qb(o, s, a), l = u[0], d = u[1], h = o[0], c = o[1], (f = l - h) * f + (g = d - c) * g)) && (_.push(m), v[m] = E) } if (0 === _.length) return []; _.sort(function (t, e) { return v[t] - v[e] }); var y = _[0], b = v[y], x = []; for (m = 0; m < _.length; m++) { var E, A = _[m]; b < (E = v[A]) && p < E && (y = A, b = E, x.push(y), x.length > e && x.shift()) } return x.map(function (t) { return function (t, e, i) { for (var n = arguments, r = qb(t, e, i), o = 0, s = 0; s < 3; s++) { var a = n[s], u = a[0] - r[0], l = a[1] - r[1], d = Math.sqrt(u * u + l * l); o < d && (o = d) } return [r[0], r[1], o] }(n[t], n[t + 1], n[t + 2]) }) } function Hb(t, e) { for (var i = t.length, n = t[i - 1], r = e[0], o = e[1], s = n[0], a = n[1], u = !1, l = 0; l < i; l++) { var d = t[l], h = d[0], c = d[1]; o < c != o < a && r < (s - h) * (o - c) / (a - c) + h && (u = !u), s = h, a = c } return u } function qb(t, e, i) { var n = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2], r = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], o = -1 / ((e[1] - t[1]) / (e[0] - t[0])), s = -1 / ((i[1] - e[1]) / (i[0] - e[0])), a = n[1] - o * n[0], u = (a - (r[1] - s * r[0])) / (s - o); return [u, o * u + a] } var Wb = 10; function Xb(t, e, distance) { for (var i, n, r = 1 / 0, o = 0, s = e.length; o < s; o++) { var a = e[o], u = e[(o + 1) % s], l = iu(t[0], t[1], a[0], a[1], u[0], u[1]); l < r && (r = l, i = a, n = u) } return function (t, e, i, n, r, o, distance) { var s = nu(t, e, i, n, r, o), a = -(n - o), u = i - r, l = Math.sqrt(a * a + u * u); return a /= l, u /= l, [s.x - distance * a, s.y - distance * u] }(t[0], t[1], i[0], i[1], n[0], n[1], distance) } function Yb(t, e, i) { var n = e.duration, r = void 0 === n ? 0 : n, o = e.margin, s = void 0 === o ? 5 : o, a = e.referenceNodes, u = e.nodes, l = a; !l || l instanceof tn || (l = t.getNodes(l)); var d = l || u.inverse(), h = d.getPosition().map(function (t) { return [t.x, t.y] }), c = i, f = u.getBoundingBox(), g = d.getBoundingBox(); g.pad(g.maxScaledSize); var p, _, v, m, y, b, x, E, A, S = minDisk(c.map(function (t) { return t.x }), c.map(function (t) { return t.y }), u.getAttribute("radius")), w = S[0], T = S[1], C = S[2] + g.maxScaledSize + s, M = 0, I = 0; if (function (t, e, i, n) { for (var r = 0; r < t.length; r++) { var o = t[r], s = o[0], a = o[1], u = Math.abs(s - e), l = Math.abs(a - i); if (u + l <= n) return !0; if (!(n < u || n < l) && u * u + l * l <= n * n) return !0 } return !1 }(h, w, T, C)) if (d.size <= 3) { if (ud(w, T, S[2], g.minX, g.minY, g.maxX, g.maxY)) { var L = function (t, e, i) { for (var n, r = Ja(i.cx, i.cy, t, e, i.minX, i.minY, i.maxX, i.maxY), o = 1 / 0, s = { x: i.maxX, y: e }, a = 0, u = r; a < u.length; a++) { var l = u[a]; (n = distance(t, e, l.x, l.y)) < o && (o = n, s = l) } return s }(w, T, g); p = distance(g.cx, g.cy, L.x, L.y); var N = (y = g.cx, b = g.cy, x = L.x, E = L.y, { x: y + (A = (p + C) / p) * (x - y), y: b + A * (E - b) }); M = N.x - w, I = N.y - T } } else { var k = new jb(h.slice()).triangulate(), convexhull = 3 < h.length ? Ub(h) : (v = (_ = g).bottomLeft(), m = _.topRight(), [[v.x, v.y], [v.x, m.y], [m.x, m.y], [m.x, v.y]]), O = Gb(d.getPosition(), Wb, C, k, convexhull); L = Xb([w, T], convexhull, C); if (0 < O.length) { for (var F = Math.pow(w - L[0], 2) + Math.pow(T - L[1], 2), R = 0, P = O; R < P.length; R++) { var D = P[R]; M = w - D[0], I = T - D[1], (p = M * M + I * I) < F && (F = p, L = D.slice(0, 2)) } M = L[0] - w, I = L[1] - T } else M = L[0] - f.cx, I = L[1] - f.cy } var z = { layoutName: "incremental", ids: u.getId(), positions: { before: c, current: c } }; if (M || I) { var B = c.map(function (t) { return t.x += M, t.y += I, t }); if (e.locate) { "boolean" == typeof e.locate && (e.locate = {}); var U = t.modules.locate.layoutDataBoundingBox({ x: h.map(function (t) { return t[0] }).concat(B.map(function (t) { return t.x })), y: h.map(function (t) { return t[1] }).concat(B.map(function (t) { return t.y })), indexes: t.getNodes()._indexes }), V = t.modules.locate.computeConfigForBounds(U, e.locate); t.modules.camera.setView(V, { duration: r, easing: e.locate.easing, ignoreZoomLimits: !0 }) } return z.positions.current = B, u.setAttributes(B, r).then(function () { return z }) } return u.setAttributes(c, r).then(function () { return z }) } function Zb(e, i, t) { var n = j(i); return n.duration = 0, n.dryRun = !0, n.locate = !1, delete n.incremental, t(n).then(function (t) { return Yb(e, i, t.positions.current) }) } function Kb(i, t, n) { var e = t.nodes, r = t.duration, o = t.centralNode, s = e, a = s.reduce(function (t, e) { return t[e._index] = !0, t }, {}), u = i.getNodes(); if (t.focusOnGroupShape) return n({ nodes: s, duration: 0 }).then(function () { var t = s.concat(o), e = t.getAttribute("layoutable"); return t.setAttributes({ layoutable: !1 }), n({ nodes: i.getNodes(), duration: r }).then(function () { return t.setAttributes(e) }) }); var l = j(t); return delete l.centralNode, l.incremental = !1, l.nodes = u, l.nodeMass = function (t, e) { return (e + 1) * (a[t._index] ? 1 : 2) }, n(l) } function Qb(t, e, i) { var n = t.nodes, r = t.centralNode; if (!n || 0 === n.size) throw new Error("Incremental layout: no nodes are selected"); if ("boolean" != typeof t.incremental && "margin" in t.incremental && !isFinite(t.incremental.margin)) throw new Error("Incremental layout: margin has to be a positive number"); var o = j(t); return "boolean" != typeof t.incremental && (o.margin = t.incremental.margin, o.referenceNodes = t.incremental.referenceNodes), r && !r.getAttribute("layoutable") ? Kb(e, o, i) : (o.nodes = o.nodes instanceof tn ? o.nodes : e.getNodes(o.nodes), Zb(e, o, i)) } var Jb = { configure: function (t, e) { var i, n, r, o = e.graph, s = e.camera, a = (e.graphics, t.nodes), u = a._indexes, l = {}, d = {}, h = u.length, c = o.getObjectList(!0), f = o.getObjectList(!1); t.nodes && delete (t = j(t)).nodes; var g = o.getNodeAttribute("innerStroke.width").getMultiple(u), p = o.getNodeAttribute("outerStroke.width").getMultiple(u), _ = o.degrees(u), v = o.getNodeAttribute("x").getMultiple(u), m = o.getNodeAttribute("y").getMultiple(u), y = o.getNodeAttribute("radius").getMultiple(u), b = o.nodeList(u).getAttribute("layoutable"), x = "function" == typeof t.nodeMass ? t.nodeMass : function (t, e, i) { return e + 1 }; delete t.nodeMass; var E = "function" == typeof t.edgeWeight ? t.edgeWeight : function (t) { return 1 }; delete t.edgeWeight, isFinite(t.scalingRatio) || delete t.scalingRatio; var A = u.reduce(function (t, e, i) { return b[i] || (t[e] = !0), t }, {}), S = 0, w = 0, T = 0, C = s.getZoom(); for (r = 0; r < u.length; ++r) { var M = u[r], I = v[r], L = m[r], N = y[r] + (g[r] + p[r]) / C; l[M] = { id: M, x: I, y: L, degree: _[r], size: N, pinned: !!A[M], mass: x(c.get(M), _[r], r) }, T = Math.max(N, T) } if (1 < h) for (r = 0; r < h; r++) { var k = l[u[r]]; S += k.x, w += k.y } var O = { x: S /= h, y: w /= h }, F = a.getAdjacentEdges(); n = (i = F._indexes).length; var R = F.getSource()._indexes, P = F.getTarget()._indexes; for (r = 0; r < n; r++) { var D = i[r], z = R[r], B = P[r]; l[z] && l[B] && (d[D] = { source: z, target: B }, d[D].weight = E(f.get(D))) } return { nodes: l, edges: d, maxSize: T, config: K(t), barycentre: O } }, context: function () { return {} }, update: function (t, e) { var Z, i, n, r; e.W ? Z = e.W : (Z = { ppn: 10, ppe: 3, ppr: 9, MAX_SUBDIVISION_RETRIES: 3, maxForce: 10, iterations: 0, converged: !1, settings: { linLogMode: !1, outboundAttractionDistribution: !1, adjustSizes: !1, edgeWeightInfluence: 0, scalingRatio: 100, strongGravityMode: !0, gravity: 1, slowDown: 1, barnesHutOptimize: !1, barnesHutTheta: .5, startingIterations: 10, iterationsPerRender: 10, maxIterations: 1e3, avgDistanceThreshold: .01, autoStop: !0, alignNodeSiblings: !0, nodeSiblingsScale: 5, nodeSiblingsAngleMin: 0 } }, e.W = Z, n = (i = t).config, r = function (t, e) { var i, n, r, o, s = t.nodes, a = t.edges, u = t.maxSize, l = Object.keys(t.nodes), d = Object.keys(t.edges), h = l.length * Z.ppn, c = d.length * Z.ppe, f = {}, g = Math.pow(10, Math.log(Math.max(u, 1)) - 6), p = g / 2, _ = Math.random, v = e.randomizeFactor || 1; o = "locally" === e.randomize ? function (t) { return t + _() * v } : "globally" === e.randomize ? function (t) { return _() * v } : function (t) { return t + _() * g - p }; var m = new Float32Array(h), y = new Float32Array(c); for (i = n = 0, r = l.length; i < r; i++) { var b = l[i], x = s[b], E = x.x, A = x.y; x.pinned || (E = o(E), A = o(A)), f[b] = n, m[n] = E, m[n + 1] = A, m[n + 2] = 0, m[n + 3] = 0, m[n + 4] = 0, m[n + 5] = 0, m[n + 6] = x.mass, m[n + 7] = 1, m[n + 8] = x.size, m[n + 9] = x.pinned || 0, n += Z.ppn } for (i = n = 0, r = d.length; i < r; i++) { b = d[i]; var S = a[b]; y[n] = f[S.source], y[n + 1] = f[S.target], y[n + 2] = S.weight || 0, n += Z.ppe } return { nodes: m, edges: y } }(i, n), e.NodeMatrix = r.nodes, e.EdgeMatrix = r.edges, Z.nodesLength = e.NodeMatrix.length, Z.edgesLength = e.EdgeMatrix.length, Z.settings = function (t, e) { for (var i in t) e[i] = t[i]; return e }(t.config, Z.settings), e.nodes = t.nodes, e.edges = t.edges, e.barycentre = t.barycentre); var K, Q = e.NodeMatrix, J = e.EdgeMatrix; function o() { var t, e, i, n, r, o, s, a, u, l, d, h, c, f, g, distance, p; for (i = 0; i < Z.nodesLength; i += Z.ppn)Q[i + 4] = Q[i + 2], Q[i + 5] = Q[i + 3], Q[i + 2] = 0, Q[i + 3] = 0; if (Z.settings.outboundAttractionDistribution) { for (i = u = 0; i < Z.nodesLength; i += Z.ppn)u += Q[i + 6]; u /= Z.nodesLength } if (Z.settings.barnesHutOptimize) { var _, v, m, y, b = 1 / 0, x = -1 / 0, E = 1 / 0, A = -1 / 0; for (K = [], i = 0; i < Z.nodesLength; i += Z.ppn)b = Math.min(b, Q[i + 0]), x = Math.max(x, Q[i + 0]), E = Math.min(E, Q[i + 1]), A = Math.max(A, Q[i + 1]); var S = x - b, w = A - E; for (w < S ? A = (E -= (S - w) / 2) + S : x = (b -= (w - S) / 2) + w, K[0] = -1, K[1] = (b + x) / 2, K[2] = (E + A) / 2, K[3] = Math.max(x - b, A - E), K[4] = -1, K[5] = -1, K[6] = 0, K[7] = 0, t = 1, i = K[8] = 0; i < Z.nodesLength; i += Z.ppn)for (e = 0, m = Z.MAX_SUBDIVISION_RETRIES; ;) { if (!(0 <= K[e + 5])) { if (K[e + 0] < 0) { K[e + 0] = i; break } if (K[e + 5] = t * Z.ppr, s = K[e + 3] / 2, a = K[e + 5], K[a + 0] = -1, K[a + 1] = K[e + 1] - s, K[a + 2] = K[e + 2] - s, K[a + 3] = s, K[a + 4] = a + Z.ppr, K[a + 5] = -1, K[a + 6] = 0, K[a + 7] = 0, K[a + 8] = 0, a += Z.ppr, K[a + 0] = -1, K[a + 1] = K[e + 1] - s, K[a + 2] = K[e + 2] + s, K[a + 3] = s, K[a + 4] = a + Z.ppr, K[a + 5] = -1, K[a + 6] = 0, K[a + 7] = 0, K[a + 8] = 0, a += Z.ppr, K[a + 0] = -1, K[a + 1] = K[e + 1] + s, K[a + 2] = K[e + 2] - s, K[a + 3] = s, K[a + 4] = a + Z.ppr, K[a + 5] = -1, K[a + 6] = 0, K[a + 7] = 0, K[a + 8] = 0, a += Z.ppr, K[a + 0] = -1, K[a + 1] = K[e + 1] + s, K[a + 2] = K[e + 2] + s, K[a + 3] = s, K[a + 4] = K[e + 4], K[a + 5] = -1, K[a + 6] = 0, K[a + 7] = 0, K[a + 8] = 0, t += 4, _ = Q[K[y = e + 0] + 0] < K[e + 1] ? Q[K[y] + 1] < K[e + 2] ? K[e + 5] : K[e + 5] + Z.ppr : Q[K[y] + 1] < K[e + 2] ? K[e + 5] + 2 * Z.ppr : K[e + 5] + 3 * Z.ppr, K[e + 6] = Q[K[y] + 6], K[e + 7] = Q[K[y] + 0], K[e + 8] = Q[K[y] + 1], K[_ + 0] = K[e + 0], K[e + 0] = -1, _ === (v = Q[i + 0] < K[e + 1] ? Q[i + 1] < K[e + 2] ? K[e + 5] : K[e + 5] + Z.ppr : Q[i + 1] < K[e + 2] ? K[e + 5] + 2 * Z.ppr : K[e + 5] + 3 * Z.ppr)) { if (m--) { e = _; continue } m = Z.MAX_SUBDIVISION_RETRIES; break } K[v + 0] = i; break } _ = Q[i + 0] < K[e + 1] ? Q[i + 1] < K[e + 2] ? K[e + 5] : K[e + 5] + Z.ppr : Q[i + 1] < K[e + 2] ? K[e + 5] + 2 * Z.ppr : K[e + 5] + 3 * Z.ppr, K[e + 7] = (K[e + 7] * K[e + 6] + Q[i + 0] * Q[i + 6]) / (K[e + 6] + Q[i + 6]), K[e + 8] = (K[e + 8] * K[e + 6] + Q[i + 1] * Q[i + 6]) / (K[e + 6] + Q[i + 6]), K[e + 6] += Q[i + 6], e = _ } } if (Z.settings.barnesHutOptimize) for (l = Z.settings.scalingRatio, i = 0; i < Z.nodesLength; i += Z.ppn)for (e = 0; ;)if (0 <= K[e + 5]) { if (distance = Math.sqrt((Q[i + 0] - K[e + 7]) * (Q[i + 0] - K[e + 7]) + (Q[i + 1] - K[e + 8]) * (Q[i + 1] - K[e + 8])), 2 * K[e + 3] / distance < Z.settings.barnesHutTheta) { if (d = Q[i + 0] - K[e + 7], h = Q[i + 1] - K[e + 8], Z.settings.adjustSizes ? 0 < distance ? (p = l * Q[i + 6] * K[e + 6] / distance / distance, Q[i + 2] += d * p, Q[i + 3] += h * p) : distance < 0 && (p = -l * Q[i + 6] * K[e + 6] / distance, Q[i + 2] += d * p, Q[i + 3] += h * p) : 0 < distance && (p = l * Q[i + 6] * K[e + 6] / distance / distance, Q[i + 2] += d * p, Q[i + 3] += h * p), K[e + 4] < 0) break; e = K[e + 4]; continue } e = K[e + 5] } else { if (0 <= K[e + 0] && K[e + 0] !== i && (d = Q[i + 0] - Q[K[e + 0] + 0], h = Q[i + 1] - Q[K[e + 0] + 1], distance = Math.sqrt(d * d + h * h), Z.settings.adjustSizes ? 0 < distance ? (p = l * Q[i + 6] * Q[K[e + 0] + 6] / distance / distance, Q[i + 2] += d * p, Q[i + 3] += h * p) : distance < 0 && (p = -l * Q[i + 6] * Q[K[e + 0] + 6] / distance, Q[i + 2] += d * p, Q[i + 3] += h * p) : 0 < distance && (p = l * Q[i + 6] * Q[K[e + 0] + 6] / distance / distance, Q[i + 2] += d * p, Q[i + 3] += h * p)), K[e + 4] < 0) break; e = K[e + 4] } else for (l = Z.settings.scalingRatio, n = 0; n < Z.nodesLength; n += Z.ppn)for (r = 0; r < n; r += Z.ppn)d = Q[n + 0] - Q[r + 0], h = Q[n + 1] - Q[r + 1], Z.settings.adjustSizes ? 0 < (distance = Math.sqrt(d * d + h * h) - Q[n + 8] - Q[r + 8]) ? (p = l * Q[n + 6] * Q[r + 6] / distance / distance, Q[n + 2] += d * p, Q[n + 3] += h * p, Q[r + 2] += d * p, Q[r + 3] += h * p) : distance < 0 && (p = 100 * l * Q[n + 6] * Q[r + 6], Q[n + 2] += d * p, Q[n + 3] += h * p, Q[r + 2] -= d * p, Q[r + 3] -= h * p) : 0 < (distance = Math.sqrt(d * d + h * h)) && (p = l * Q[n + 6] * Q[r + 6] / distance / distance, Q[n + 2] += d * p, Q[n + 3] += h * p, Q[r + 2] -= d * p, Q[r + 3] -= h * p); for (a = Z.settings.gravity / Z.settings.scalingRatio, l = Z.settings.scalingRatio, i = 0; i < Z.nodesLength; i += Z.ppn)d = Q[i + (p = 0)], h = Q[i + 1], distance = Math.sqrt(d * d + h * h), Z.settings.strongGravityMode ? 0 < distance && (p = l * Q[i + 6] * a) : 0 < distance && (p = l * Q[i + 6] * a / distance), Q[i + 2] -= d * p, Q[i + 3] -= h * p; for (l = 1 * (Z.settings.outboundAttractionDistribution ? u : 1), o = 0; o < Z.edgesLength; o += Z.ppe)n = J[o + 0], r = J[o + 1], s = J[o + 2], g = Math.pow(s, Z.settings.edgeWeightInfluence), d = Q[n + 0] - Q[r + 0], h = Q[n + 1] - Q[r + 1], Z.settings.adjustSizes ? (distance = Math.sqrt(d * d + h * h) - Q[n + 8] - Q[r + 8], Z.settings.linLogMode ? Z.settings.outboundAttractionDistribution ? 0 < distance && (p = -l * g * Math.log(1 + distance) / distance / Q[n + 6]) : 0 < distance && (p = -l * g * Math.log(1 + distance) / distance) : Z.settings.outboundAttractionDistribution ? 0 < distance && (p = -l * g / Q[n + 6]) : 0 < distance && (p = -l * g)) : (distance = Math.sqrt(d * d + h * h), Z.settings.linLogMode ? Z.settings.outboundAttractionDistribution ? 0 < distance && (p = -l * g * Math.log(1 + distance) / distance / Q[n + 6]) : 0 < distance && (p = -l * g * Math.log(1 + distance) / distance) : p = Z.settings.outboundAttractionDistribution ? (distance = 1, -l * g / Q[n + 6]) : (distance = 1, -l * g)), 0 < distance && (Q[n + 2] += d * p, Q[n + 3] += h * p, Q[r + 2] -= d * p, Q[r + 3] -= h * p); var force, T, C, M, I = 0; if (Z.settings.adjustSizes) for (i = 0; i < Z.nodesLength; i += Z.ppn)Q[i + 9] || ((force = Math.sqrt(Q[i + 2] * Q[i + 2] + Q[i + 3] * Q[i + 3])) > Z.maxForce && (Q[i + 2] = Q[i + 2] * Z.maxForce / force, Q[i + 3] = Q[i + 3] * Z.maxForce / force), T = Q[i + 6] * Math.sqrt((Q[i + 4] - Q[i + 2]) * (Q[i + 4] - Q[i + 2]) + (Q[i + 5] - Q[i + 3]) * (Q[i + 5] - Q[i + 3])), C = Math.sqrt((Q[i + 4] + Q[i + 2]) * (Q[i + 4] + Q[i + 2]) + (Q[i + 5] + Q[i + 3]) * (Q[i + 5] + Q[i + 3])) / 2, M = .1 * Math.log(1 + C) / (1 + Math.sqrt(T)), c = Q[i + 0], f = Q[i + 1], Q[i + 0] = Q[i + 0] + Q[i + 2] * (M / Z.settings.slowDown), Q[i + 1] = Q[i + 1] + Q[i + 3] * (M / Z.settings.slowDown), d = Q[i + 0], h = Q[i + 1], I += distance = Math.sqrt((d - c) * (d - c) + (h - f) * (h - f))); else for (i = 0; i < Z.nodesLength; i += Z.ppn)Q[i + 9] || (T = Q[i + 6] * Math.sqrt((Q[i + 4] - Q[i + 2]) * (Q[i + 4] - Q[i + 2]) + (Q[i + 5] - Q[i + 3]) * (Q[i + 5] - Q[i + 3])), C = Math.sqrt((Q[i + 4] + Q[i + 2]) * (Q[i + 4] + Q[i + 2]) + (Q[i + 5] + Q[i + 3]) * (Q[i + 5] + Q[i + 3])) / 2, M = Q[i + 7] * Math.log(1 + C) / (1 + Math.sqrt(T)), Q[i + 7] = Math.min(1, Math.sqrt(M * (Q[i + 2] * Q[i + 2] + Q[i + 3] * Q[i + 3]) / (1 + Math.sqrt(T)))), c = Q[i + 0], f = Q[i + 1], Q[i + 0] = Q[i + 0] + Q[i + 2] * (M / Z.settings.slowDown), Q[i + 1] = Q[i + 1] + Q[i + 3] * (M / Z.settings.slowDown), d = Q[i + 0], h = Q[i + 1], I += distance = Math.sqrt((d - c) * (d - c) + (h - f) * (h - f))); if (Z.iterations++ , Z.settings.autoStop && (Z.converged = Z.iterations > Z.settings.maxIterations || I / Z.nodesLength < Z.settings.avgDistanceThreshold, Z.converged && Z.settings.alignNodeSiblings)) { var L, N, k = {}, O = {}; for (o = 0; o < Z.edgesLength; o += Z.ppe)(n = J[o + 0]) !== (r = J[o + 1]) && (k[n] = k[n] || {}, k[r] = k[r] || {}, k[n][r] = !0, k[r][n] = !0); Object.keys(k).forEach(function (t) { var e = ~~t; 2 == (N = Object.keys(k[e])).length && ((L = N[0] + ";" + N[1]) in O || (L = N[1] + ";" + N[0], O[L] || (O[L] = [~~N[1], ~~N[0]])), O[L].push(e)) }); var F, R, P, D, z, B, U, V, j, G, H, q, W, X, Y = Z.settings.nodeSiblingsAngleMin; Object.keys(O).forEach(function (t) { if (R = O[t].shift(), P = O[t].shift(), 1 != (F = O[t].filter(function (t) { return !Q[t + 9] })).length) { var e, i, n, r, o, s, a, u, l, d, h, c, f, g; if (B = Q[R + 0], U = Q[R + 1], V = Q[P + 0], j = Q[P + 1], D = Object.keys(k[R]).length, z = Object.keys(k[P]).length, H = { x: (n = B) + (V - n) * (o = (.75 - (i = .25)) * (D / (D + z) - (e = 0)) / (1 - e) + i), y: (r = U) + (j - r) * o }, q = { xi: -((l = j) - (a = U)), yi: (u = V) - (s = B), xiPrime: l - a, yiPrime: -(u - s) }, d = V - B, h = j - U, G = Math.sqrt(d * d + h * h), f = G, W = { x: ((c = q).xiPrime - c.xi) / f, y: (c.yiPrime - c.yi) / f }, g = W, X = Math.acos(g.x / Math.sqrt(g.x * g.x + g.y * g.y)), 2 * Y > Math.PI) throw new Error("ForceLink.Worker - Invalid parameter: angleMin must be smaller than 2 PI."); 0 < Y && (X < Y || X > Math.PI - Y && X <= Math.PI ? W = { x: 2 * Math.cos(Math.PI - Y), y: 2 * Math.sin(Math.PI - Y) } : (X > 2 * Math.PI - Y || X >= Math.PI && X < Math.PI + Y) && (W = { x: 2 * Math.cos(Y), y: 2 * Math.sin(Y) })); var p = 0, _ = 1, v = 1; F.length % 2 == 1 && (v = 0, p = 1); for (var m = 0; m < F.length; m++)Q[F[m] + 0] = H.x + _ * W.x * v * (p || 2 <= m ? Z.settings.nodeSiblingsScale : 2 * Z.settings.nodeSiblingsScale / 3), Q[F[m] + 1] = H.y + _ * W.y * v * (p || 2 <= m ? Z.settings.nodeSiblingsScale : 2 * Z.settings.nodeSiblingsScale / 3), _ = -_, v += (m + p) % 2 } }) } } return function () { if (Z.settings.autoStop) for (; !Z.converged;)o(); else for (var t = 0 === Z.iterations ? Z.settings.startingIterations : Z.iterations + Z.settings.iterationsPerRender; Z.iterations !== t;)o(); return { nodes: function (t) { for (var e = Object.keys(t), i = {}, n = 0; n < Q.length; n += Z.ppn) { var r = e[n / Z.ppn]; i[r] = { id: r, x: Q[n + 0], y: Q[n + 1], pinned: Q[n + 9] } } return i }(e.nodes), barycentre: e.barycentre } }() }, isRunning: function (t) { return !t.W.settings.autoStop }, onSync: function (t, e) { var i, n, r, o, s, a, u, l, d = t.nodes, h = t.barycentre, c = e.graph, f = Object.keys(d), g = f.length, p = 0, _ = 0, v = new Array(g), m = new Array(g), y = new Array(g), b = new Array(g), x = c.getAttributes(!0, ["x", "y"]), E = x[0], A = x[1]; for (i = 0; i < g; i++)r = d[n = f[i]], l = parseInt(n), v[i] = l, b[i] = r.pinned, s = r.pinned ? (o = E.get(l), A.get(l)) : (o = r.x, r.y), p += m[i] = o, _ += y[i] = s; for (a = p / g - h.x, u = _ / g - h.y, i = 0; i < g; i++)b[i] || (m[i] -= a, y[i] -= u); return { indexes: v, x: m, y: y } } }, $b = function (t) { return t.reduce(function (t, e) { return t[e] = !0, t }, {}) }; function tx(t, e) { for (var i = [t], n = $b(i), r = [t]; i.length;)for (var o = 0, s = e[i.shift()]; o < s.length; o += 1) { var a = s[o]; n[a] || (n[a] = !0, r.push(a), i.push(a)) } return r } function ex(t) { return t.reduce(function (t, e) { return t[e.source] = t[e.source] || [], t[e.target] = t[e.target] || [], t[e.source].push("" + e.target), t[e.target].push("" + e.source), t }, {}) } function ix(r) { return function (t, e) { var i = Math.abs(t.layer - e.layer), n = [e, t].reduce(function (t, e) { return t + (lx(e) ? 1 : .01) }, 0); return i ? 2 * i * r : n * r } } function nx(t) { return t.reduce(function (t, e) { return t + function (t, e) { for (var i = [], n = arguments.length - 2; 0 < n--;)i[n] = arguments[n + 2]; for (var r = e, o = 0, s = i; o < s.length; o += 1) { var a = s[o]; if (!r[a]) return t; r = r[a] } return r }(lx(e) ? .5 : 0, e, "data", "radius") }, 0) / t.length } function rx(t, e, i) { var n = i || ex(e || []); return t.filter(function (t) { return !(t.id in n) }) } function ox(t, e) { var i = $b(e); return t.filter(function (t) { return !(t in i) }) } function sx(t, r) { t.forEach(function (t, n) { t.forEach(function (t, e, i) { r(t, e, i, n) }) }) } function ax(e) { return Object.keys(e).map(function (t) { return e[t] }) } function ux(i, n) { return Object.keys(i).reduce(function (t, e) { return t[e] = n(i[e], e, i), t }, {}) } function lx(t) { return !!t.data } function dx(t, e) { return { id: t, data: e, children: [] } } function hx(t, e, l) { var d = e.reduce(function (t, e) { return t[e.source] = t[e.source] || [], t[e.source].push(e), t }, {}); var n = t.reduce(function t(e, i) { var n = e.visited, r = e.stack, o = e.result; if (n[i.id]) return e; n[i.id] = r[i.id] = 1; for (var s = 0, a = d[i.id] || []; s < a.length; s += 1) { var u = a[s]; r[u.target] ? o.push(u) : t(e, l[u.target]) } return delete r[i.id], e }, { visited: {}, stack: {}, result: [] }).result.reduce(function (t, e) { var i = e.source, n = e.target; return t[i] = t[i] || {}, t[i][n] = 1, t }, {}); return e.map(function (t) { var e = t.source, i = t.target; return n[e] && n[e][i] ? { source: i, target: e } : t }) } function cx(t, e) { e.forEach(function (t) { return t._median = [] }), t.forEach(function (e, i) { e.children.filter(function (t) { return t.layer > e.layer }).forEach(function (t) { t._median.push(i) }) }), e.forEach(function (e, t) { e.children.filter(function (t) { return t.layer <= e.layer }).forEach(function () { return e._median.push(t) }) }), e.forEach(function (t) { return t._median = function (t) { if (t.sort(function (t, e) { return t - e }), 0 === t.length) return 0; var e = Math.floor(t.length / 2); return t.length % 2 ? t[e] : (t[e - 1] + t[e]) / 2 }(t._median) || 0 }), e.sort(function (t, e) { return t._median - e._median }), e.forEach(function (t) { return delete t._median }) } var fx = "up", gx = "down", px = "left", _x = "right", vx = Number.POSITIVE_INFINITY; function mx(t) { for (var e = 0, i = [fx, gx]; e < i.length; e += 1) { t(i[e]) } } function yx(t) { for (var e = 0, i = [px, _x]; e < i.length; e += 1) { t(i[e]) } } function bx() { return function (t, a) { var r, i, e, d, h, n, o = (r = {}, sx(t, function (t) { r[t.id] || (r[t.id] = { successors: [], ancestors: [] }); for (var e = 0, i = t.children; e < i.length; e += 1) { var n = i[e]; r[n.id] || (r[n.id] = { successors: [], ancestors: [] }), n.layer > t.layer && (r[t.id].successors.push(n), r[n.id].ancestors.push(t)), n.layer < t.layer && (r[t.id].ancestors.push(n), r[n.id].successors.push(t)) } }), { getSuccessors: function (t) { return r[t.id].successors }, getAncestors: function (t) { return r[t.id].ancestors } }), u = o.getSuccessors, g = o.getAncestors, s = (i = {}, sx(t, function (t, e) { i[t.id] = e }), i), p = (d = u, h = function (t) { var e = t.id; return s[e] }, n = (e = t).length, e.reduce(function (t, o, e) { var i = t.prevLayer, s = t.conflicts; if (!e || n - 2 < e) return { prevLayer: i, conflicts: s }; var a = 0, u = o.length, l = o[u - 1]; return o.forEach(function (t, e) { var i = function (t) { if (lx(t)) return d(t).find(lx) }(t), n = i ? h(i) : u - 1; if (i || t === l) for (var r = function () { var i = o[a]; d(i).forEach(function (t) { var e = h(t); (e < 0 || n < e) && (s[i.id] = s[i.id] || {}, s[i.id][t.id] = !0) }), a++ }; a <= e;)r() }), { prevLayer: o, conflicts: s } }, { prevLayer: e[0], conflicts: {} }).conflicts), _ = {}; mx(function (o) { var s = o === fx ? t : [].concat(t).reverse(); yx(function (t) { t === _x && (s = s.map(function (t) { return [].concat(t).reverse() })); var e, l, d, h, c, f, i = a, n = (l = p, d = o === fx ? g : u, h = {}, c = {}, f = {}, sx(e = s, function (t, e) { h[t.id] = t.id, c[t.id] = t.id, f[t.id] = e }), e.forEach(function (t) { var u = -1; t.forEach(function (t) { var e, i, n = d(t).sort(function (t, e) { return f[t.id] - f[e.id] }); if (n.length) for (var r = (n.length - 1) / 2, o = 0, s = [Math.floor(r), Math.ceil(r)]; o < s.length; o += 1) { var a = n[s[o]]; c[t.id] === t.id && (i = a, !(l[(e = t).id] && l[e.id][i.id] || l[i.id] && l[i.id][e.id]) && u < f[a.id] && (c[a.id] = t.id, h[t.id] = h[a.id], c[t.id] = h[t.id], u = f[a.id])) } }) }), { roots: h, aligns: c }), r = function (t, r, o, s) { var a = {}, u = {}, n = {}, l = {}, d = {}, h = {}, c = {}; sx(t, function (t, e, i) { a[t.id] = t, u[t.id] = vx, n[t.id] = e, d[t.id] = i[e - 1] || t, h[t.id] = t, c[t.id] = 0 }); var f = Math.max(1e4, 1 + Object.keys(c).length / 2); function g(t) { if (null == l[t.id]) { l[t.id] = 0; for (var e = t, i = !1; !i;) { if (null != d[e.id]) { var n = h[r[d[e.id].id]]; if (c[n.id] > f) return; g(n), c[n.id]++ , a[t.id] === t && (a[t.id] = a[n.id]), a[t.id] !== a[n.id] ? u[a[n.id].id] = Math.min(u[a[n.id].id], l[t.id] - l[n.id] - s(t, d[t.id])) : l[t.id] = Math.max(l[t.id], l[n.id] + s(t, d[t.id])) } i = (e = h[o[e.id]]) === t } } } return t.forEach(function (t) { t.filter(function (t) { return r[t.id] === t.id }).forEach(g) }), sx(t, function (t) { l[t.id] = l[r[t.id]]; var e = u[a[r[t.id]].id]; t.id === r[t.id] && isFinite(e) && (l[t.id] += e) }), l }(s, n.roots, n.aligns, i); t === _x && (r = ux(r, function (t) { return -t })), _[o + t] = r }) }); var l, c, f, v, m, y, b, x = (l = _, c = Object.keys(l).reduce(function (t, e) { var i = t.alignment, value = t.value, n = ax(l[e]), r = Math.max.apply(Math, n) - Math.min.apply(Math, n); return value <= r ? { alignment: i, value: value } : { alignment: e, value: r } }, { alignment: null, value: vx }).alignment, l[c]); f = _, m = ax(v = x), y = Math.min.apply(Math, m), b = Math.max.apply(Math, m), mx(function (o) { yx(function (t) { var e = o + t, i = f[e]; if (i !== v) { var n = ax(i), r = t === px ? y - Math.min.apply(Math, n) : b - Math.max.apply(Math, n); r && (f[e] = ux(i, function (t) { return t + r })) } }) }); var E, A = ux((E = _)[fx + px], function (t, n) { var r = []; return mx(function (i) { yx(function (t) { var e = i + t; r.push(E[e][n]) }) }), r.sort(function (t, e) { return t - e }), (r[1] + r[2]) / 2 }); return sx(t, function (t) { t.x = A[t.id] }), t } } function xx() { return function (t, n) { var r = -vx; return t.forEach(function (t) { var e = t.filter(lx); if (1 === e.length) { e[0].x = .5 } else { e.reduce(function (t, e) { return e.x = void 0 === t ? 0 : t.x + n(t, e), e }, void 0); var i = e[e.length - 1].x; r = Math.max(r, i), e.forEach(function (t) { return t.x /= i }) } }), r = Math.max(r, 1), sx(t, function (t) { return t.x *= r }), t } } function Ex(t, e, i, n) { this.feasible = i, this.evaluation = e, this.bounded = n, this._tableau = t } var Ax = Ex; function Sx(t, e, i, n, r) { Ax.call(this, t, e, i, n), this.iter = r } Ex.prototype.generateSolutionSet = function () { for (var t = {}, e = this._tableau, i = e.varIndexByRow, n = e.variablesPerIndex, r = e.matrix, o = e.rhsColumn, s = e.height - 1, a = Math.round(1 / e.precision), u = 1; u <= s; u += 1) { var l = n[i[u]]; if (void 0 !== l && !0 !== l.isSlack) { var d = r[u][o]; t[l.id] = Math.round(d * a) / a } } return t }; var wx = Sx; function Tx(t) { this.model = null, this.matrix = null, this.width = 0, this.height = 0, this.costRowIndex = 0, this.rhsColumn = 0, this.variablesPerIndex = [], this.unrestrictedVars = null, this.feasible = !0, this.evaluation = 0, this.varIndexByRow = null, this.varIndexByCol = null, this.rowByVarIndex = null, this.colByVarIndex = null, this.precision = t || 1e-8, this.optionalObjectives = [], this.objectivesByPriority = {}, this.savedState = null, this.availableIndexes = [], this.lastElementIndex = 0, this.variables = null, this.nVars = 0, this.bounded = !0, this.unboundedVarIndex = null, this.branchAndCutIterations = 0 } Sx.prototype = Object.create(Ax.prototype), Sx.constructor = Sx; var Cx = Tx; function Mx(t, e) { this.priority = t, this.reducedCosts = new Array(e); for (var i = 0; i < e; i += 1)this.reducedCosts[i] = 0 } Tx.prototype.solve = function () { return 0 < this.model.getNumberOfIntegerVariables() ? this.branchAndCut() : this.simplex(), this.updateVariableValues(), this.getSolution() }, Mx.prototype.copy = function () { var t = new Mx(this.priority, this.reducedCosts.length); return t.reducedCosts = this.reducedCosts.slice(), t }, Tx.prototype.setOptionalObjective = function (t, e, i) { var n = this.objectivesByPriority[t]; void 0 === n && (n = new Mx(t, Math.max(this.width, e + 1)), this.objectivesByPriority[t] = n, this.optionalObjectives.push(n), this.optionalObjectives.sort(function (t, e) { return t.priority - e.priority })); n.reducedCosts[e] = i }, Tx.prototype.initialize = function (t, e, i, n) { this.variables = i, this.unrestrictedVars = n, this.width = t, this.height = e; for (var r = new Array(t), o = 0; o < t; o++)r[o] = 0; this.matrix = new Array(e); for (var s = 0; s < e; s++)this.matrix[s] = r.slice(); this.varIndexByRow = new Array(this.height), this.varIndexByCol = new Array(this.width), this.varIndexByRow[0] = -1, this.varIndexByCol[0] = -1, this.nVars = t + e - 2, this.rowByVarIndex = new Array(this.nVars), this.colByVarIndex = new Array(this.nVars), this.lastElementIndex = this.nVars }, Tx.prototype._resetMatrix = function () { var t, e, i = this.model.variables, n = this.model.constraints, r = i.length, o = n.length, s = this.matrix[0], a = !0 === this.model.isMinimization ? -1 : 1; for (t = 0; t < r; t += 1) { var u = i[t], l = u.priority, d = a * u.cost; 0 === l ? s[t + 1] = d : this.setOptionalObjective(l, t + 1, d), e = i[t].index, this.rowByVarIndex[e] = -1, this.colByVarIndex[e] = t + 1, this.varIndexByCol[t + 1] = e } for (var h = 1, c = 0; c < o; c += 1) { var f, g, p = n[c], _ = p.index; this.rowByVarIndex[_] = h, this.colByVarIndex[_] = -1, this.varIndexByRow[h] = _; var v = p.terms, m = v.length, y = this.matrix[h++]; if (p.isUpperBound) { for (f = 0; f < m; f += 1)g = v[f], y[this.colByVarIndex[g.variable.index]] = g.coefficient; y[0] = p.rhs } else { for (f = 0; f < m; f += 1)g = v[f], y[this.colByVarIndex[g.variable.index]] = -g.coefficient; y[0] = -p.rhs } } }, Tx.prototype.setModel = function (t) { var e = (this.model = t).nVariables + 1, i = t.nConstraints + 1; return this.initialize(e, i, t.variables, t.unrestrictedVariables), this._resetMatrix(), this }, Tx.prototype.getNewElementIndex = function () { if (0 < this.availableIndexes.length) return this.availableIndexes.pop(); var t = this.lastElementIndex; return this.lastElementIndex += 1, t }, Tx.prototype.density = function () { for (var t = 0, e = this.matrix, i = 0; i < this.height; i++)for (var n = e[i], r = 0; r < this.width; r++)0 !== n[r] && (t += 1); return t / (this.height * this.width) }, Tx.prototype.setEvaluation = function () { var t = Math.round(1 / this.precision), e = this.matrix[this.costRowIndex][this.rhsColumn]; this.evaluation = Math.round(e * t) / t }, Tx.prototype.getSolution = function () { var t = !0 === this.model.isMinimization ? this.evaluation : -this.evaluation; return 0 < this.model.getNumberOfIntegerVariables() ? new wx(this, t, this.feasible, this.bounded, this.branchAndCutIterations) : new Ax(this, t, this.feasible, this.bounded) }, Cx.prototype.simplex = function () { return this.bounded = !0, this.phase1(), !0 === this.feasible && this.phase2(), this }, Cx.prototype.phase1 = function () { for (var t = this.model.checkForCycles, e = [], i = this.matrix, n = this.rhsColumn, r = this.width - 1, o = this.height - 1, s = 0; ;) { for (var a = 0, u = -this.precision, l = 1; l <= o; l++)if (!(!0 === this.unrestrictedVars[this.varIndexByRow[l]])) { var value = i[l][n]; value < u && (u = value, a = l) } if (0 === a) return this.feasible = !0, s; for (var d = 0, h = -1 / 0, c = i[0], f = i[a], g = 1; g <= r; g++) { var p = f[g]; if (!(-this.precision < p && p < this.precision) && (!0 === this.unrestrictedVars[this.varIndexByCol[g]] || p < -this.precision)) { var _ = -c[g] / p; h < _ && (h = _, d = g) } } if (0 === d) return this.feasible = !1, s; if (t) { e.push([this.varIndexByRow[a], this.varIndexByCol[d]]); var v = this.checkForCycles(e); if (0 < v.length) throw console.log("Cycle in phase 1"), console.log("Start :", v[0]), console.log("Length :", v[1]), new Error } this.pivot(a, d), s += 1 } }, Cx.prototype.phase2 = function () { for (var t, e, i = this.model.checkForCycles, n = [], r = this.matrix, o = this.rhsColumn, s = this.width - 1, a = this.height - 1, u = this.precision, l = this.optionalObjectives.length, d = null, h = 0; ;) { var c = r[this.costRowIndex]; 0 < l && (d = []); for (var f = 0, g = u, p = !1, _ = 1; _ <= s; _++)t = c[_], e = !0 === this.unrestrictedVars[this.varIndexByCol[_]], 0 < l && -u < t && t < u ? d.push(_) : e && t < 0 ? g < -t && (g = -t, f = _, p = !0) : g < t && (g = t, f = _, p = !1); if (0 < l) for (var v = 0; 0 === f && 0 < d.length && v < l;) { var m = [], y = this.optionalObjectives[v].reducedCosts; g = u; for (var b = 0; b < d.length; b++)t = y[_ = d[b]], e = !0 === this.unrestrictedVars[this.varIndexByCol[_]], -u < t && t < u ? m.push(_) : e && t < 0 ? g < -t && (g = -t, f = _, p = !0) : g < t && (g = t, f = _, p = !1); d = m, v += 1 } if (0 === f) return this.setEvaluation(), h; for (var x = 0, E = 1 / 0, A = (this.varIndexByRow, 1); A <= a; A++) { var S = r[A], w = S[o], T = S[f]; if (!(-u < T && T < u)) { if (0 < T && w < u && -u < w) { E = 0, x = A; break } var C = p ? -w / T : w / T; u < C && C < E && (E = C, x = A) } } if (E === 1 / 0) return this.evaluation = -1 / 0, this.bounded = !1, this.unboundedVarIndex = this.varIndexByCol[f], h; if (i) { n.push([this.varIndexByRow[x], this.varIndexByCol[f]]); var M = this.checkForCycles(n); if (0 < M.length) throw console.log("Cycle in phase 2"), console.log("Start :", M[0]), console.log("Length :", M[1]), new Error } this.pivot(x, f, !0), h += 1 } }; var Ix = []; function Lx(t, e, i, n) { this.id = t, this.cost = e, this.index = i, this.value = 0, this.priority = n } function Nx(t, e, i, n) { Lx.call(this, t, e, i, n) } function kx(t, e) { Lx.call(this, t, 0, e, 0) } function Ox(t, e) { this.variable = t, this.coefficient = e } function Fx(t, e, i) { return 0 === i || "required" === i ? null : (e = e || 1, i = i || 1, !1 === t.isMinimization && (e = -e), t.addVariable(e, "r" + t.relaxationIndex++, !1, !1, i)) } function Rx(t, e, i, n) { this.slack = new kx("s" + i, i), this.index = i, this.model = n, this.rhs = t, this.isUpperBound = e, this.terms = [], this.termsByVarIndex = {}, this.relaxation = null } function Px(t, e) { this.upperBound = t, this.lowerBound = e, this.model = t.model, this.rhs = t.rhs, this.relaxation = null } Cx.prototype.pivot = function (t, e) { var i = this.matrix, n = i[t][e], r = this.height - 1, o = this.width - 1, s = this.varIndexByRow[t], a = this.varIndexByCol[e]; this.varIndexByRow[t] = a, this.varIndexByCol[e] = s, this.rowByVarIndex[a] = t, this.rowByVarIndex[s] = -1, this.colByVarIndex[a] = -1, this.colByVarIndex[s] = e; for (var u, l, d, h = i[t], c = 0, f = 0; f <= o; f++)0 !== h[f] && (h[f] /= n, Ix[c] = f, c += 1); h[e] = 1 / n; this.precision; for (var g = 0; g <= r; g++) { var p = i[g]; if (g !== t && 0 !== (u = p[e])) { for (l = 0; l < c; l++)0 !== (d = h[f = Ix[l]]) && (p[f] = p[f] - u * d); p[e] = -u / n } } var _ = this.optionalObjectives.length; if (0 < _) for (var v = 0; v < _; v += 1) { var m = this.optionalObjectives[v].reducedCosts; if (0 !== (u = m[e])) { for (l = 0; l < c; l++)0 !== (d = h[f = Ix[l]]) && (m[f] = m[f] - u * d); m[e] = -u / n } } }, Cx.prototype.checkForCycles = function (t) { for (var e = 0; e < t.length - 1; e++)for (var i = e + 1; i < t.length; i++) { var n = t[e], r = t[i]; if (n[0] === r[0] && n[1] === r[1]) { if (i - e > t.length - i) break; for (var o = !0, s = 1; s < i - e; s++) { var a = t[e + s], u = t[i + s]; if (a[0] !== u[0] || a[1] !== u[1]) { o = !1; break } } if (o) return [e, i - e] } } return [] }, kx.prototype.isSlack = Nx.prototype.isInteger = !0, Rx.prototype.addTerm = function (t, e) { var i = e.index, n = this.termsByVarIndex[i]; if (void 0 === n) n = new Ox(e, t), this.termsByVarIndex[i] = n, this.terms.push(n), !0 === this.isUpperBound && (t = -t), this.model.updateConstraintCoefficient(this, e, t); else { var r = n.coefficient + t; this.setVariableCoefficient(r, e) } return this }, Rx.prototype.removeTerm = function (t) { return this }, Rx.prototype.setRightHandSide = function (t) { if (t !== this.rhs) { var e = t - this.rhs; !0 === this.isUpperBound && (e = -e), this.rhs = t, this.model.updateRightHandSide(this, e) } return this }, Rx.prototype.setVariableCoefficient = function (t, e) { var i = e.index; if (-1 !== i) { var n = this.termsByVarIndex[i]; if (void 0 === n) this.addTerm(t, e); else if (t !== n.coefficient) { var r = t - n.coefficient; !0 === this.isUpperBound && (r = -r), n.coefficient = t, this.model.updateConstraintCoefficient(this, e, r) } return this } console.warn("[Constraint.setVariableCoefficient] Trying to change coefficient of inexistant variable.") }, Rx.prototype.relax = function (t, e) { this.relaxation = Fx(this.model, t, e), this._relax(this.relaxation) }, Rx.prototype._relax = function (t) { null !== t && (this.isUpperBound ? this.setVariableCoefficient(-1, t) : this.setVariableCoefficient(1, t)) }, Px.prototype.isEquality = !0, Px.prototype.addTerm = function (t, e) { return this.upperBound.addTerm(t, e), this.lowerBound.addTerm(t, e), this }, Px.prototype.removeTerm = function (t) { return this.upperBound.removeTerm(t), this.lowerBound.removeTerm(t), this }, Px.prototype.setRightHandSide = function (t) { this.upperBound.setRightHandSide(t), this.lowerBound.setRightHandSide(t), this.rhs = t }, Px.prototype.relax = function (t, e) { this.relaxation = Fx(this.model, t, e), this.upperBound.relaxation = this.relaxation, this.upperBound._relax(this.relaxation), this.lowerBound.relaxation = this.relaxation, this.lowerBound._relax(this.relaxation) }; var Dx = { Constraint: Rx, Variable: Lx, IntegerVariable: Nx, SlackVariable: kx, Equality: Px, Term: Ox }, zx = Dx.SlackVariable; function Bx(t, value) { this.index = t, this.value = value } Cx.prototype.addCutConstraints = function (t) { for (var e, i = t.length, n = this.height, r = n + i, o = n; o < r; o += 1)void 0 === this.matrix[o] && (this.matrix[o] = this.matrix[o - 1].slice()); this.height = r, this.nVars = this.width + this.height - 2; for (var s = this.width - 1, a = 0; a < i; a += 1) { var u = t[a], l = n + a, d = "min" === u.type ? -1 : 1, h = u.varIndex, c = this.rowByVarIndex[h], f = this.matrix[l]; if (-1 === c) { for (f[this.rhsColumn] = d * u.value, e = 1; e <= s; e += 1)f[e] = 0; f[this.colByVarIndex[h]] = d } else { var g = this.matrix[c], p = g[this.rhsColumn]; for (f[this.rhsColumn] = d * (u.value - p), e = 1; e <= s; e += 1)f[e] = -d * g[e] } var _ = this.getNewElementIndex(); this.varIndexByRow[l] = _, this.rowByVarIndex[_] = l, this.colByVarIndex[_] = -1, this.variablesPerIndex[_] = new zx("s" + _, _), this.nVars += 1 } }, Cx.prototype._addLowerBoundMIRCut = function (t) { if (t === this.costRowIndex) return !1; this.model; var e = this.matrix; if (!this.variablesPerIndex[this.varIndexByRow[t]].isInteger) return !1; var i = e[t][this.rhsColumn], n = i - Math.floor(i); if (n < this.precision || 1 - this.precision < n) return !1; var r = this.height; e[r] = e[r - 1].slice(), this.height += 1, this.nVars += 1; var o = this.getNewElementIndex(); this.varIndexByRow[r] = o, this.rowByVarIndex[o] = r, this.colByVarIndex[o] = -1, this.variablesPerIndex[o] = new zx("s" + o, o), e[r][this.rhsColumn] = Math.floor(i); for (var s = 1; s < this.varIndexByCol.length; s += 1) { if (this.variablesPerIndex[this.varIndexByCol[s]].isInteger) { var a = e[t][s], u = Math.floor(a) + Math.max(0, a - Math.floor(a) - n) / (1 - n); e[r][s] = u } else e[r][s] = Math.min(0, e[t][s] / (1 - n)) } for (var l = 0; l < this.width; l += 1)e[r][l] -= e[t][l]; return !0 }, Cx.prototype._addUpperBoundMIRCut = function (t) { if (t === this.costRowIndex) return !1; this.model; var e = this.matrix; if (!this.variablesPerIndex[this.varIndexByRow[t]].isInteger) return !1; var i = e[t][this.rhsColumn], n = i - Math.floor(i); if (n < this.precision || 1 - this.precision < n) return !1; var r = this.height; e[r] = e[r - 1].slice(), this.height += 1, this.nVars += 1; var o = this.getNewElementIndex(); this.varIndexByRow[r] = o, this.rowByVarIndex[o] = r, this.colByVarIndex[o] = -1, this.variablesPerIndex[o] = new zx("s" + o, o), e[r][this.rhsColumn] = -n; for (var s = 1; s < this.varIndexByCol.length; s += 1) { var a = this.variablesPerIndex[this.varIndexByCol[s]], u = e[t][s], l = u - Math.floor(u); a.isInteger ? e[r][s] = l <= n ? -l : -(1 - l) * n / l : e[r][s] = 0 <= u ? -u : u * n / (1 - n) } return !0 }, Cx.prototype.applyMIRCuts = function () { for (var t = this.height, e = 0; e < t; e += 1)this._addUpperBoundMIRCut(e); for (e = 0; e < t; e += 1)this._addLowerBoundMIRCut(e) }, Cx.prototype._putInBase = function (t) { var e = this.rowByVarIndex[t]; if (-1 === e) { for (var i = this.colByVarIndex[t], n = 1; n < this.height; n += 1) { var r = this.matrix[n][i]; if (r < -this.precision || this.precision < r) { e = n; break } } this.pivot(e, i) } return e }, Cx.prototype._takeOutOfBase = function (t) { var e = this.colByVarIndex[t]; if (-1 === e) { for (var i = this.rowByVarIndex[t], n = this.matrix[i], r = 1; r < this.height; r += 1) { var o = n[r]; if (o < -this.precision || this.precision < o) { e = r; break } } this.pivot(i, e) } return e }, Cx.prototype.updateVariableValues = function () { for (var t = this.variables.length, e = Math.round(1 / this.precision), i = 0; i < t; i += 1) { var n = this.variables[i], r = n.index, o = this.rowByVarIndex[r]; if (-1 === o) n.value = 0; else { var s = this.matrix[o][this.rhsColumn]; n.value = Math.round(s * e) / e } } }, Cx.prototype.updateRightHandSide = function (t, e) { var i = this.height - 1, n = this.rowByVarIndex[t.index]; if (-1 === n) { for (var r = this.colByVarIndex[t.index], o = 0; o <= i; o += 1) { var s = this.matrix[o]; s[this.rhsColumn] -= e * s[r] } var a = this.optionalObjectives.length; if (0 < a) for (var u = 0; u < a; u += 1) { var l = this.optionalObjectives[u].reducedCosts; l[this.rhsColumn] -= e * l[r] } } else this.matrix[n][this.rhsColumn] -= e }, Cx.prototype.updateConstraintCoefficient = function (t, e, i) { if (t.index === e.index) throw new Error("[Tableau.updateConstraintCoefficient] constraint index should not be equal to variable index !"); var n = this._putInBase(t.index), r = this.colByVarIndex[e.index]; if (-1 === r) for (var o = this.rowByVarIndex[e.index], s = 0; s < this.width; s += 1)this.matrix[n][s] += i * this.matrix[o][s]; else this.matrix[n][r] -= i }, Cx.prototype.updateCost = function (t, e) { var i = t.index, n = this.width - 1, r = this.colByVarIndex[i]; if (-1 === r) { var o, s = this.matrix[this.rowByVarIndex[i]]; if (0 === t.priority) { var a = this.matrix[0]; for (o = 0; o <= n; o += 1)a[o] += e * s[o] } else { var u = this.objectivesByPriority[t.priority].reducedCosts; for (o = 0; o <= n; o += 1)u[o] += e * s[o] } } else this.matrix[0][r] -= e }, Cx.prototype.addConstraint = function (t) { var e = t.isUpperBound ? 1 : -1, i = this.height, n = this.matrix[i]; void 0 === n && (n = this.matrix[0].slice(), this.matrix[i] = n); for (var r = this.width - 1, o = 0; o <= r; o += 1)n[o] = 0; n[this.rhsColumn] = e * t.rhs; for (var s = t.terms, a = s.length, u = 0; u < a; u += 1) { var l = s[u], d = l.coefficient, h = l.variable.index, c = this.rowByVarIndex[h]; if (-1 === c) n[this.colByVarIndex[h]] += e * d; else { var f = this.matrix[c]; f[this.rhsColumn]; for (o = 0; o <= r; o += 1)n[o] -= e * d * f[o] } } var g = t.index; this.varIndexByRow[i] = g, this.rowByVarIndex[g] = i, this.colByVarIndex[g] = -1, this.height += 1 }, Cx.prototype.removeConstraint = function (t) { var e = t.index, i = this.height - 1, n = this._putInBase(e), r = this.matrix[i]; this.matrix[i] = this.matrix[n], this.matrix[n] = r, this.varIndexByRow[n] = this.varIndexByRow[i], this.varIndexByRow[i] = -1, this.rowByVarIndex[e] = -1, this.availableIndexes[this.availableIndexes.length] = e, t.slack.index = -1, --this.height }, Cx.prototype.addVariable = function (t) { var e = this.height - 1, i = this.width, n = !0 === this.model.isMinimization ? -t.cost : t.cost, r = t.priority, o = this.optionalObjectives.length; if (0 < o) for (var s = 0; s < o; s += 1)this.optionalObjectives[s].reducedCosts[i] = 0; 0 === r ? this.matrix[0][i] = n : (this.setOptionalObjective(r, i, n), this.matrix[0][i] = 0); for (var a = 1; a <= e; a += 1)this.matrix[a][i] = 0; var u = t.index; this.varIndexByCol[i] = u, this.rowByVarIndex[u] = -1, this.colByVarIndex[u] = i, this.width += 1 }, Cx.prototype.removeVariable = function (t) { var e = t.index, i = this._takeOutOfBase(e), n = this.width - 1; if (i !== n) { for (var r = this.height - 1, o = 0; o <= r; o += 1) { var s = this.matrix[o]; s[i] = s[n] } var a = this.optionalObjectives.length; if (0 < a) for (var u = 0; u < a; u += 1) { var l = this.optionalObjectives[u].reducedCosts; l[i] = l[n] } var d = this.varIndexByCol[n]; this.varIndexByCol[i] = d, this.colByVarIndex[d] = i } this.varIndexByCol[n] = -1, this.colByVarIndex[e] = -1, this.availableIndexes[this.availableIndexes.length] = e, t.index = -1, --this.width }, Cx.prototype.log = function (t, force) { console.log("****", t, "****"), console.log("Nb Variables", this.width - 1), console.log("Nb Constraints", this.height - 1), console.log("Basic Indexes", this.varIndexByRow), console.log("Non Basic Indexes", this.varIndexByCol), console.log("Rows", this.rowByVarIndex), console.log("Cols", this.colByVarIndex); var e, i, n, r, o, s, a, u, l, d, h = "", c = [" "]; for (i = 1; i < this.width; i += 1)o = this.varIndexByCol[i], a = " ", u = "\t", 5 < (s = void 0 === (r = this.variablesPerIndex[o]) ? "c" + o : r.id).length ? a += " " : u += "\t", c[i] = a, h += u + s; console.log(h); var f = this.matrix[this.costRowIndex], g = "\t"; for (e = 1; e < this.width; e += 1)g += "\t", g += c[e], g += f[e].toFixed(5); for (g += "\t" + c[0] + f[0].toFixed(5), console.log(g + "\tZ"), n = 1; n < this.height; n += 1) { for (l = this.matrix[n], d = "\t", i = 1; i < this.width; i += 1)d += "\t" + c[i] + l[i].toFixed(5); d += "\t" + c[0] + l[0].toFixed(5), o = this.varIndexByRow[n], s = void 0 === (r = this.variablesPerIndex[o]) ? "c" + o : r.id, console.log(d + "\t" + s) } console.log(""); var p = this.optionalObjectives.length; if (0 < p) { console.log("    Optional objectives:"); for (var _ = 0; _ < p; _ += 1) { var v = this.optionalObjectives[_].reducedCosts, m = ""; for (e = 1; e < this.width; e += 1)m += v[e] < 0 ? "" : " ", m += c[e], m += v[e].toFixed(5); m += (v[0] < 0 ? "" : " ") + c[0] + v[0].toFixed(5), console.log(m + " z" + _) } } return console.log("Feasible?", this.feasible), console.log("evaluation", this.evaluation), this }, Cx.prototype.copy = function () { var t = new Cx(this.precision); t.width = this.width, t.height = this.height, t.nVars = this.nVars, t.model = this.model, t.variables = this.variables, t.variablesPerIndex = this.variablesPerIndex, t.unrestrictedVars = this.unrestrictedVars, t.lastElementIndex = this.lastElementIndex, t.varIndexByRow = this.varIndexByRow.slice(), t.varIndexByCol = this.varIndexByCol.slice(), t.rowByVarIndex = this.rowByVarIndex.slice(), t.colByVarIndex = this.colByVarIndex.slice(), t.availableIndexes = this.availableIndexes.slice(); for (var e = [], i = 0; i < this.optionalObjectives.length; i++)e[i] = this.optionalObjectives[i].copy(); t.optionalObjectives = e; for (var n = this.matrix, r = new Array(this.height), o = 0; o < this.height; o++)r[o] = n[o].slice(); return t.matrix = r, t }, Cx.prototype.save = function () { this.savedState = this.copy() }, Cx.prototype.restore = function () { if (null !== this.savedState) { var t, e, i = this.savedState, n = i.matrix; for (this.nVars = i.nVars, this.model = i.model, this.variables = i.variables, this.variablesPerIndex = i.variablesPerIndex, this.unrestrictedVars = i.unrestrictedVars, this.lastElementIndex = i.lastElementIndex, this.width = i.width, this.height = i.height, t = 0; t < this.height; t += 1) { var r = n[t], o = this.matrix[t]; for (e = 0; e < this.width; e += 1)o[e] = r[e] } var s = i.varIndexByRow; for (e = 0; e < this.height; e += 1)this.varIndexByRow[e] = s[e]; for (; this.varIndexByRow.length > this.height;)this.varIndexByRow.pop(); var a = i.varIndexByCol; for (t = 0; t < this.width; t += 1)this.varIndexByCol[t] = a[t]; for (; this.varIndexByCol.length > this.width;)this.varIndexByCol.pop(); for (var u = i.rowByVarIndex, l = i.colByVarIndex, d = 0; d < this.nVars; d += 1)this.rowByVarIndex[d] = u[d], this.colByVarIndex[d] = l[d]; if (0 < i.optionalObjectives.length && 0 < this.optionalObjectives.length) { this.optionalObjectives = [], this.optionalObjectivePerPriority = {}; for (var h = 0; h < i.optionalObjectives.length; h++) { var c = i.optionalObjectives[h].copy(); this.optionalObjectives[h] = c, this.optionalObjectivePerPriority[c.priority] = c } } } }, Cx.prototype.getMostFractionalVar = function () { for (var t = 0, e = null, i = null, n = this.model.integerVariables, r = n.length, o = 0; o < r; o++) { var s = n[o].index, a = this.rowByVarIndex[s]; if (-1 !== a) { var u = this.matrix[a][this.rhsColumn], l = Math.abs(u - Math.round(u)); t < l && (t = l, e = s, i = u) } } return new Bx(e, i) }, Cx.prototype.getFractionalVarWithLowestCost = function () { for (var t = 1 / 0, e = null, i = null, n = this.model.integerVariables, r = n.length, o = 0; o < r; o++) { var s = n[o], a = s.index, u = this.rowByVarIndex[a]; if (-1 !== u) { var l = this.matrix[u][this.rhsColumn]; if (Math.abs(l - Math.round(l)) > this.precision) { var d = s.cost; d < t && (t = d, e = a, i = l) } } } return new Bx(e, i) }, Cx.prototype.countIntegerValues = function () { for (var t = 0, e = 1; e < this.height; e += 1)if (this.variablesPerIndex[this.varIndexByRow[e]].isInteger) { var i = this.matrix[e][this.rhsColumn]; (i -= Math.floor(i)) < this.precision && -i < this.precision && (t += 1) } return t }, Cx.prototype.isIntegral = function () { for (var t = this.model.integerVariables, e = t.length, i = 0; i < e; i++) { var n = this.rowByVarIndex[t[i].index]; if (-1 !== n) { var r = this.matrix[n][this.rhsColumn]; if (Math.abs(r - Math.round(r)) > this.precision) return !1 } } return !0 }, Cx.prototype.computeFractionalVolume = function (t) { for (var e = -1, i = 1; i < this.height; i += 1)if (this.variablesPerIndex[this.varIndexByRow[i]].isInteger) { var n = this.matrix[i][this.rhsColumn]; if (n = Math.abs(n), Math.min(n - Math.floor(n), Math.floor(n + 1)) < this.precision) { if (!t) return 0 } else -1 === e ? e = n : e *= n } return -1 === e ? 0 : e }; var Ux = Cx; function Vx(t, e, value) { this.type = t, this.varIndex = e, this.value = value } function jx(t, e) { this.relaxedEvaluation = t, this.cuts = e } function Gx(t, e) { return e.relaxedEvaluation - t.relaxedEvaluation } Cx.prototype.applyCuts = function (t) { if (this.restore(), this.addCutConstraints(t), this.simplex(), this.model.useMIRCuts) for (var e = !0; e;) { var i = this.computeFractionalVolume(!0); this.applyMIRCuts(), this.simplex(), .9 * i <= this.computeFractionalVolume(!0) && (e = !1) } }, Cx.prototype.branchAndCut = function () { for (var t = [], e = 0, i = 1 / 0, n = null, r = [], o = 0; o < this.optionalObjectives.length; o += 1)r.push(1 / 0); var s = new jx(-1 / 0, []); for (t.push(s); 0 < t.length;)if (!((s = t.pop()).relaxedEvaluation > i)) { var a = s.cuts; if (this.applyCuts(a), e++ , !1 !== this.feasible) { var u = this.evaluation; if (!(i < u)) { if (u === i) { for (var l = !0, d = 0; d < this.optionalObjectives.length && !(this.optionalObjectives[d].reducedCosts[0] > r[d]); d += 1)if (this.optionalObjectives[d].reducedCosts[0] < r[d]) { l = !1; break } if (l) continue } if (!0 === this.isIntegral()) { if (1 === e) return void (this.branchAndCutIterations = e); n = s, i = u; for (var h = 0; h < this.optionalObjectives.length; h += 1)r[h] = this.optionalObjectives[h].reducedCosts[0] } else { 1 === e && this.save(); for (var c = this.getMostFractionalVar(), f = c.index, g = [], p = [], _ = a.length, v = 0; v < _; v += 1) { var m = a[v]; m.varIndex === f ? "min" === m.type ? p.push(m) : g.push(m) : (g.push(m), p.push(m)) } var y = Math.ceil(c.value), b = Math.floor(c.value), x = new Vx("min", f, y); g.push(x); var E = new Vx("max", f, b); p.push(E), t.push(new jx(u, g)), t.push(new jx(u, p)), t.sort(Gx) } } } } null !== n && this.applyCuts(n.cuts), this.branchAndCutIterations = e }; var Hx = {}, qx = Dx.Constraint, Wx = Dx.Equality, Xx = Dx.Variable, Yx = Dx.IntegerVariable; function Zx(t, e) { this.tableau = new Cx(t), this.name = e, this.variables = [], this.integerVariables = [], this.unrestrictedVariables = {}, this.constraints = [], this.nConstraints = 0, this.nVariables = 0, this.isMinimization = !0, this.tableauInitialized = !1, this.relaxationIndex = 1, this.useMIRCuts = !0, this.checkForCycles = !1 } var Kx = Zx; Zx.prototype.minimize = function () { return this.isMinimization = !0, this }, Zx.prototype.maximize = function () { return this.isMinimization = !1, this }, Zx.prototype._getNewElementIndex = function () { if (0 < this.availableIndexes.length) return this.availableIndexes.pop(); var t = this.lastElementIndex; return this.lastElementIndex += 1, t }, Zx.prototype._addConstraint = function (t) { var e = t.slack; this.tableau.variablesPerIndex[e.index] = e, this.constraints.push(t), this.nConstraints += 1, !0 === this.tableauInitialized && this.tableau.addConstraint(t) }, Zx.prototype.smallerThan = function (t) { var e = new qx(t, !0, this.tableau.getNewElementIndex(), this); return this._addConstraint(e), e }, Zx.prototype.greaterThan = function (t) { var e = new qx(t, !1, this.tableau.getNewElementIndex(), this); return this._addConstraint(e), e }, Zx.prototype.equal = function (t) { var e = new qx(t, !0, this.tableau.getNewElementIndex(), this); this._addConstraint(e); var i = new qx(t, !1, this.tableau.getNewElementIndex(), this); return this._addConstraint(i), new Wx(e, i) }, Zx.prototype.addVariable = function (t, e, i, n, r) { if ("string" == typeof r) switch (r) { case "required": r = 0; break; case "strong": r = 1; break; case "medium": r = 2; break; case "weak": r = 3; break; default: r = 0 }var o, s = this.tableau.getNewElementIndex(); return null == e && (e = "v" + s), null == t && (t = 0), null == r && (r = 0), i ? (o = new Yx(e, t, s, r), this.integerVariables.push(o)) : o = new Xx(e, t, s, r), this.variables.push(o), this.tableau.variablesPerIndex[s] = o, n && (this.unrestrictedVariables[s] = !0), this.nVariables += 1, !0 === this.tableauInitialized && this.tableau.addVariable(o), o }, Zx.prototype._removeConstraint = function (t) { var e = this.constraints.indexOf(t); -1 !== e ? (this.constraints.splice(e, 1), --this.nConstraints, !0 === this.tableauInitialized && this.tableau.removeConstraint(t), t.relaxation && this.removeVariable(t.relaxation)) : console.warn("[Model.removeConstraint] Constraint not present in model") }, Zx.prototype.removeConstraint = function (t) { return t.isEquality ? (this._removeConstraint(t.upperBound), this._removeConstraint(t.lowerBound)) : this._removeConstraint(t), this }, Zx.prototype.removeVariable = function (t) { var e = this.variables.indexOf(t); if (-1 !== e) return this.variables.splice(e, 1), !0 === this.tableauInitialized && this.tableau.removeVariable(t), this; console.warn("[Model.removeVariable] Variable not present in model") }, Zx.prototype.updateRightHandSide = function (t, e) { return !0 === this.tableauInitialized && this.tableau.updateRightHandSide(t, e), this }, Zx.prototype.updateConstraintCoefficient = function (t, e, i) { return !0 === this.tableauInitialized && this.tableau.updateConstraintCoefficient(t, e, i), this }, Zx.prototype.setCost = function (t, e) { var i = t - e.cost; return !1 === this.isMinimization && (i = -i), e.cost = t, this.tableau.updateCost(e, i), this }, Zx.prototype.loadJson = function (t) { this.isMinimization = "max" !== t.opType; for (var e = t.variables, i = t.constraints, n = {}, r = {}, o = Object.keys(i), s = o.length, a = 0; a < s; a += 1) { var u, l, d = o[a], h = i[d], c = h.equal, f = h.weight, g = h.priority, p = void 0 !== f || void 0 !== g; if (void 0 === c) { var _ = h.min; void 0 !== _ && (u = this.greaterThan(_), n[d] = u, p && u.relax(f, g)); var v = h.max; void 0 !== v && (l = this.smallerThan(v), r[d] = l, p && l.relax(f, g)) } else { u = this.greaterThan(c), n[d] = u, l = this.smallerThan(c), r[d] = l; var m = new Wx(u, l); p && m.relax(f, g) } } for (var y = Object.keys(e), b = y.length, x = t.ints || {}, E = t.binaries || {}, A = t.unrestricted || {}, S = t.optimize, w = 0; w < b; w += 1) { var T = y[w], C = e[T], M = C[S] || 0, I = !!E[T], L = !!x[T] || I, N = !!A[T], k = this.addVariable(M, T, L, N); I && this.smallerThan(1).addTerm(1, k); var O = Object.keys(C); for (a = 0; a < O.length; a += 1) { var F = O[a]; if (F !== S) { var R = C[F], P = n[F]; void 0 !== P && P.addTerm(R, k); var D = r[F]; void 0 !== D && D.addTerm(R, k) } } } return this }, Zx.prototype.getNumberOfIntegerVariables = function () { return this.integerVariables.length }, Zx.prototype.solve = function () { return !1 === this.tableauInitialized && (this.tableau.setModel(this), this.tableauInitialized = !0), this.tableau.solve() }, Zx.prototype.isFeasible = function () { return this.tableau.feasible }, Zx.prototype.save = function () { return this.tableau.save() }, Zx.prototype.restore = function () { return this.tableau.restore() }, Zx.prototype.activateMIRCuts = function (t) { this.useMIRCuts = t }, Zx.prototype.debug = function (t) { this.checkForCycles = t }, Zx.prototype.log = function (t) { return this.tableau.log(t) }; var Qx = { CleanObjectiveAttributes: function (t) { var e, i, n; if ("string" == typeof t.optimize) { if (t.constraints[t.optimize]) { for (i in e = Math.random(), t.variables) t.variables[i][t.optimize] && (t.variables[i][e] = t.variables[i][t.optimize]); return t.constraints[e] = t.constraints[t.optimize], delete t.constraints[t.optimize], t } return t } for (n in t.optimize) if (t.constraints[n]) if ("equal" === t.constraints[n]) delete t.optimize[n]; else { for (i in e = Math.random(), t.variables) t.variables[i][n] && (t.variables[i][e] = t.variables[i][n]); t.constraints[e] = t.constraints[n], delete t.constraints[n] } return t } }; function Jx(t) { return t.length ? function (t) { var e = { is_blank: /^\W{0,}$/, is_objective: /(max|min)(imize){0,}\:/i, is_int: /^(?!\/\*)\W{0,}int/i, is_constraint: /(\>|\<){0,}\=/i, is_unrestricted: /^\S{0,}unrestricted/i, parse_lhs: /(\-|\+){0,1}\s{0,1}\d{0,}\.{0,}\d{0,}\s{0,}[A-Za-z]\S{0,}/gi, parse_rhs: /(\-|\+){0,1}\d{1,}\.{0,}\d{0,}\W{0,}\;{0,1}$/i, parse_dir: /(\>|\<){0,}\=/gi, parse_int: /[^\s|^\,]+/gi, get_num: /(\-|\+){0,1}(\W|^)\d+\.{0,1}\d{0,}/g, get_word: /[A-Za-z].*/ }, i = { opType: "", optimize: "_obj", constraints: {}, variables: {} }, n = { ">=": "min", "<=": "max", "=": "equal" }, r = "", o = null, s = "", a = "", u = "", l = 0; "string" == typeof t && (t = t.split("\n")); for (var d = 0; d < t.length; d++)if (u = "__" + d, r = t[d], o = null, e.is_objective.test(r)) i.opType = r.match(/(max|min)/gi)[0], (o = r.match(e.parse_lhs).map(function (t) { return t.replace(/\s+/, "") }).slice(1)).forEach(function (t) { s = null === (s = t.match(e.get_num)) ? "-" === t.substr(0, 1) ? -1 : 1 : s[0], s = parseFloat(s), a = t.match(e.get_word)[0].replace(/\;$/, ""), i.variables[a] = i.variables[a] || {}, i.variables[a]._obj = s }); else if (e.is_int.test(r)) o = r.match(e.parse_int).slice(1), i.ints = i.ints || {}, o.forEach(function (t) { t = t.replace(";", ""), i.ints[t] = 1 }); else if (e.is_constraint.test(r)) { var h = r.indexOf(":"); (o = (-1 === h ? r : r.slice(h + 1)).match(e.parse_lhs).map(function (t) { return t.replace(/\s+/, "") })).forEach(function (t) { s = null === (s = t.match(e.get_num)) ? "-" === t.substr(0, 1) ? -1 : 1 : s[0], s = parseFloat(s), a = t.match(e.get_word)[0], i.variables[a] = i.variables[a] || {}, i.variables[a][u] = s }), l = parseFloat(r.match(e.parse_rhs)[0]), r = n[r.match(e.parse_dir)[0]], i.constraints[u] = i.constraints[u] || {}, i.constraints[u][r] = l } else e.is_unrestricted.test(r) && (o = r.match(e.parse_int).slice(1), i.unrestricted = i.unrestricted || {}, o.forEach(function (t) { t = t.replace(";", ""), i.unrestricted[t] = 1 })); return i }(t) : function (t) { if (!t) throw new Error("Solver requires a model to operate on"); var e = "", i = { max: "<=", min: ">=", equal: "=" }, n = new RegExp("[^A-Za-z0-9]+", "gi"); for (var r in e += t.opType + ":", t.variables) t.variables[r][r] = t.variables[r][r] ? t.variables[r][r] : 1, t.variables[r][t.optimize] && (e += " " + t.variables[r][t.optimize] + " " + r.replace(n, "_")); for (r in e += ";\n", t.constraints) for (var o in t.constraints[r]) { for (var s in t.variables) t.variables[s][r] && (e += " " + t.variables[s][r] + " " + s.replace(n, "_")); e += " " + i[o] + " " + t.constraints[r][o], e += ";\n" } if (t.ints) for (r in e += "\n\n", t.ints) e += "int " + r.replace(n, "_") + ";\n"; if (t.unrestricted) for (r in e += "\n\n", t.unrestricted) e += "unrestricted " + r.replace(n, "_") + ";\n"; return e }(t) } function $x() { this.Model = Kx, this.branchAndCut = Hx, this.Constraint = tE, this.Variable = eE, this.Numeral = iE, this.Term = nE, this.Tableau = Ux, this.lastSolvedModel = null, this.Solve = function (t, e, i, n) { if (n) for (var r in Qx) t = Qx[r](t); if (!t) throw new Error("Solver requires a model to operate on"); t instanceof Kx == !1 && (t = new Kx(e).loadJson(t)); var o = t.solve(); if (this.lastSolvedModel = t, o.solutionSet = o.generateSolutionSet(), i) return o; var s = {}; return s.feasible = o.feasible, s.result = o.evaluation, s.bounded = o.bounded, Object.keys(o.solutionSet).map(function (t) { s[t] = o.solutionSet[t] }), s }, this.ReformatLP = Jx, this.MultiObjective = function (t) { return function (t, e) { var i, n, r, o, s, a = e.optimize, u = JSON.parse(JSON.stringify(e.optimize)), l = Object.keys(e.optimize), d = 0, h = {}, c = "", f = {}, g = []; for (delete e.optimize, n = 0; n < l.length; n++)u[l[n]] = 0; for (n = 0; n < l.length; n++) { for (s in e.optimize = l[n], e.opType = a[l[n]], i = t.Solve(e, void 0, void 0, !0), l) if (!e.variables[l[s]]) for (o in i[l[s]] = i[l[s]] ? i[l[s]] : 0, e.variables) e.variables[o][l[s]] && i[o] && (i[l[s]] += i[o] * e.variables[o][l[s]]); for (c = "base", r = 0; r < l.length; r++)i[l[r]] ? c += "-" + (1e3 * i[l[r]] | 0) / 1e3 : c += "-0"; if (!h[c]) { for (h[c] = 1, d++ , r = 0; r < l.length; r++)i[l[r]] && (u[l[r]] += i[l[r]]); delete i.feasible, delete i.result, g.push(i) } } for (n = 0; n < l.length; n++)e.constraints[l[n]] = { equal: u[l[n]] / d }; for (n in e.optimize = "cheater-" + Math.random(), e.opType = "max", e.variables) e.variables[n].cheater = 1; for (n in g) for (o in g[n]) f[o] = f[o] || { min: 1e99, max: -1e99 }; for (n in f) for (o in g) g[o][n] ? (g[o][n] > f[n].max && (f[n].max = g[o][n]), g[o][n] < f[n].min && (f[n].min = g[o][n])) : (g[o][n] = 0, f[n].min = 0); return { midpoint: i = t.Solve(e, void 0, void 0, !0), vertices: g, ranges: f } }(this, t) } } var tE = Dx.Constraint, eE = Dx.Variable, iE = Dx.Numeral, nE = Dx.Term; "object" == typeof window && (window.solver = new $x); var rE = new $x; function oE(t) { var n = {}, e = {}, r = {}; t.nodes.forEach(function (i) { e[i.id] = 1, n[i.id] = { opt: i.children.length }, i.children.forEach(function (t) { var e = i.id + "->" + t.id; r[e] = { min: 1 }, n[i.id][e] = -1 }) }), t.nodes.forEach(function (i) { i.children.forEach(function (t) { var e = i.id + "->" + t.id; n[t.id].opt-- , n[t.id][e] = 1 }) }); var i = rE.Solve({ optimize: "opt", opType: "max", constraints: r, variables: n, ints: e }); return t.nodes.forEach(function (t) { t.layer = i[t.id] || 0 }), t } function sE(t) { return t.nodes.forEach(function (t) { t.layer = null != t.data.layer ? t.data.layer : t.layer }), t } function aE(t) { var u = Object.assign({}, { normalization: !0 }, t), l = oE; return function (t) { if (t.nodes.some(function (t) { return "layer" in t.data && t.data.layer < 0 })) throw new Error("Some nodes have negative layering information"); if (!u.normalization && t.nodes.every(function (t) { return "layer" in t.data && -1 < t.data.layer })) { var e = []; t.nodes.forEach(function (t) { return e[t.data.layer] = 1 }); for (var i = e.findIndex(function (t) { return null != t }), n = 0, r = e.slice(i); n < r.length; n += 1) { if (null == r[n]) throw new Error("The overall layering contains gaps (two non-consecutive layers)") } } t.nodes.some(function (t) { return "layer" in t.data && 0 === t.data.layer }) || sE(l(t)); var o, s, a = function (t) { if (t.nodes.every(function (t) { return t.layer })) { var e = 1 / 0; t.nodes.forEach(function (t) { e = Math.min(e, t.layer) }), t.nodes.forEach(function (t) { t.layer -= e }) } return t }(function (t) { if (t.nodes.some(function (t) { return t.data.sink })) { var e = -1 / 0; t.nodes.forEach(function (t) { e = Math.max(e, t.layer) }), t.nodes.forEach(function (t) { t.data.sink && (t.layer = e + 1) }) } return t }(function (t) { var i = {}; t.nodes.forEach(function (e) { i[e.id] = (i[e.id] || []).concat(e.children), e.children.forEach(function (t) { i[t.id] = (i[t.id] || []).concat([e]) }) }); var e = []; t.nodes.forEach(function (t) { 0 === t.layer && e.push(t) }); var n = {}, r = {}; for (t.nodes.forEach(function (t) { null != t.layer && (r[t.id] = t.layer) }); e.length;)for (var o = e.shift().id, s = 0, a = i[o]; s < a.length; s += 1) { var u = a[s]; if (!n[u.id]) { if (null == r[u.id]) { var l = r[o] + 1; r[u.id] = l, u.layer = l } n[u.id] = !0, e.push(u) } } return t }(sE(t)))); return function (t, e) { if (!e.normalization) return; var i = []; t.nodes.forEach(function (t) { return i[t.layer] = 0 }); var n = Array.from(i).reduce(function (t, e, i) { if (0 === i) return t.push(0), t; var n = t[i - 1]; return null != e ? t.push(n) : t.push(n - 1), t }, []); t.nodes.forEach(function (t) { t.layer += n[t.layer] }) }(a, u), (s = (o = a).nodes.reduce(function (t, e) { if (e.data.fixed) { if (null == t) return e; if (t.layer > e.layer) return e } return t }, null)) && o.nodes.forEach(function (t) { t.ref = s.id }), o } } var uE = function () { this.root = null }; function lE(t) { return t.nodes.filter(function (t) { return !t.layer }) } uE.prototype.fit = function (t) { var e = t.length ? t[0].w : 0, i = t.length ? t[0].h : 0; this.root = { x: 0, y: 0, w: e, h: i }; for (var n = 0, r = t; n < r.length; n += 1) { var o = r[n], s = this.findNode(this.root, o.w, o.h); o.fit = s ? this.splitNode(s, o.w, o.h) : this.growNode(o.w, o.h) } }, uE.prototype.findNode = function (t, e, i) { return t.used ? this.findNode(t.right, e, i) || this.findNode(t.down, e, i) : e <= t.w && i <= t.h ? t : void 0 }, uE.prototype.splitNode = function (t, e, i) { return t.used = !0, t.down = { x: t.x, y: t.y + i, w: t.w, h: t.h - i }, t.right = { x: t.x + e, y: t.y, w: t.w - e, h: i }, t }, uE.prototype.growNode = function (t, e) { var i = t <= this.root.w, n = e <= this.root.h; return n && this.root.h >= this.root.w + t ? this.growRight(t, e) : i && this.root.w >= this.root.h + e ? this.growDown(t, e) : n ? this.growRight(t, e) : i ? this.growDown(t, e) : void 0 }, uE.prototype.getNewRoot = function (t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.root), void 0 === n && (n = this.root), { used: !0, x: 0, y: 0, w: this.root.w + t, h: this.root.h + e, right: i, down: n } }, uE.prototype.growRight = function (t, e) { return this.root = this.getNewRoot(t, 0, { x: this.root.w, y: 0, w: t, h: this.root.h }), this.grow(t, e) }, uE.prototype.growDown = function (t, e) { return this.root = this.getNewRoot(0, e, void 0, { x: 0, y: this.root.h, w: this.root.w, h: e }), this.grow(t, e) }, uE.prototype.grow = function (t, e) { var i = this.findNode(this.root, t, e); if (i) return this.splitNode(i, t, e) }; var dE = { down: function () { }, up: function (t, e, i) { t.y = -t.y + i }, left: function (t, e, i) { var n = t.x; t.x = -t.y + i, t.y = n - e }, right: function (t, e, i) { var n = t.x; t.x = t.y - i, t.y = -n + e } }; function hE(t, _, v) { for (var s, e, i, n, m = -1 / 0, y = -1 / 0, b = [], x = v.nodesSeparation || 0, r = (s = _, e = t.reduce(function (t, e) { return e.nodes.reduce(function (t, e) { var i = e.id, n = s[i] || {}, r = n.x, o = n.y; return null != r && null !== o && (t.x = Math.min(r, t.x), t.y = Math.min(o, t.y)), t }, t) }, { x: 1 / 0, y: 1 / 0 }), i = e.x, n = e.y, { x: isFinite(i) ? i : 0, y: isFinite(n) ? n : 0 }), o = t.reduce(function (t, e) { return e.nodes.filter(function (t) { return t.data && t.data.fixed }).reduce(function (t, e) { var i = _[e.id], n = i.x, r = i.y; return t[e.id] = { x: n, y: r }, t }, t) }, {}), a = function () { var t = A[E], i = {}, e = t.nodes, n = 1 == e.length, r = 2 * nx(e) | 5, o = null != v.layerSeparation ? v.layerSeparation : 50, s = e.reduce(function (t, e) { var i = e.x; return Math.min(t, i) }, 1 / 0); m = e.reduce(function (t, e) { var i = e.x; return Math.max(t, i) }, -1 / 0) - s; for (var a = 0, u = e; a < u.length; a += 1) { var l = u[a], d = l.x, h = l.y, c = l.id; _[c] && (n ? _[c].x = _[c].y = 0 : (_[c].x = d - s, _[c].y = h, i[h] = i[h] || [], i[h].push(_[c]))) } var f = Math.max(r, o), g = Object.keys(i), p = g.reduce(function (t, e) { return Math.max(t, i[e].length - 1) }, 1) * (3 + Math.max(1, x)); y = (g.length || 1) * f, m = Math.max(m, 1), t.isFake || g.sort(function (t, e) { return t - e }).forEach(function (t, e) { i[t].forEach(function (t) { t.y = e * f, t.x = t.x / m * p }) }), b.push({ w: Math.ceil(p), h: Math.ceil(y), dag: t }), y = m = -1 / 0 }, E = 0, A = t; E < A.length; E += 1)a(); b.sort(function (t, e) { return Math.max(e.w, e.h) - Math.max(t.w, t.h) }), (new uE).fit(b); for (var u, l, d, h, c = b.reduce(function (t, e) { var i = e.h; return Math.max(t, i) }, 1), f = b.reduce(function (t, e) { var i = e.fit; return Math.max(i && i.x || 0, t) }, 1), g = 0, p = b; g < p.length; g += 1) { for (var S = p[g], w = S.fit, T = S.dag, C = S.w, M = S.h, I = w || { x: 0, y: 0 }, L = I.y / c * 50 + I.y, N = I.x / f * 100 + I.x, k = 0, O = T.nodes; k < O.length; k += 1) { var F = O[k].id; _[F] && (_[F].x += N, _[F].y += L, u = _[F], l = v.direction, d = (C + N) / 2, h = (M + L) / 2, l && l in dE && dE[l](u, d, h), _[F].x += r.x, _[F].y += r.y) } var R = T.nodes[0] && T.nodes[0].ref, P = 0, D = 0; if (R && (P = _[R].x - o[R].x, D = _[R].y - o[R].y), P || D) for (var z = 0, B = T.nodes; z < B.length; z += 1) { var U = B[z].id; _[U] && (_[U].x -= P, _[U].y -= D) } } for (var V = 0, j = Object.keys(o); V < j.length; V += 1) { var G = j[V]; _[G].x = o[G].x, _[G].y = o[G].y } return t } var cE = { rect: hE, hierarchy: function (t, e, i, n) { var r = t; if (1 < t.length) { for (var o = { id: "__root__", parentIds: [], virtual: !0 }, s = 0, a = t.map(lE); s < a.length; s += 1)for (var u = 0, l = a[s]; u < l.length; u += 1) { l[u].data.parentIds.push(o.id) } r = n([t.reduce(function (t, e) { return t.concat(e.nodes.map(function (t) { return t.data })) }, [o])], i) } return hE(r, e, i) } }; var fE = 1.2, gE = 50; function pE(t, e) { void 0 === e && (e = {}); var i = t.slice().sort(function (t, e) { return e.r - t.r }), n = Math.sqrt(i.length), r = Math.floor(n), o = Math.ceil(n); r * o < i.length && (r < o ? r++ : o++); var s = fE * i.reduce(function (t, e) { var i = e.r; return Math.max(t, 2 * i) }, 0), a = Math.max(e.nodesGridSeparation || gE, 1), u = s * o + a * (o - 1), l = s * r + a * Math.max(r - 1, 0); return i.forEach(function (t, e) { var i = e % o, n = Math.floor(e / o); t.x = u * i / o, t.y = l * n / r }), { w: u, h: l } } function _E(t) { if (!t || !t.length) throw Error("Cannot stratify empty data"); for (var e = 0, i = t; e < i.length; e += 1) { var n = i[e]; if (null == n) throw Error('Node data is "null"'); if (null == n.id) throw Error('Node id contains a "null" value') } for (var r = t.map(function (t) { return dx(t.id, t) }), o = r.reduce(function (t, e) { if (t[e.id]) throw Error("The connected component contains id duplicates: " + e.id); return t[e.id] = e, t }, {}), s = dx(), a = 0, u = r; a < u.length; a += 1) { for (var l = u[a], d = 0, h = l.data.parentIds; d < h.length; d += 1) { var c = h[d], f = o[c]; if (!f) throw Error("The node " + l.id + " has a missing parent id " + c); f.children.push(l) } l.data.parentIds.length || s.children.push(l) } return { nodes: function (t) { var e = {}, i = [].concat(t.children), n = []; for (; i.length;) { var r = i.pop(); e[r.id] || (n.push(r), e[r.id] = 1, i.push.apply(i, r.children)) } return n }(s) } } var vE = 1, mE = 1; function yE(t, e) { var i = e.decross, n = e.separation, r = e.coord; (0, e.layering)(t); var o, s, a = t.nodes.reduce(function (r, o) { return r[o.layer] = r[o.layer] || [], r[o.layer].push(o), o.children = o.children.map(function (t) { if (t.layer === o.layer + 1) return t; for (var e = t, i = t.layer - 1; i > o.layer; i--) { var n = dx(o.id + "->" + t.id + "@" + i); n.children = [e], r[i] = r[i] || [], r[i].push(n), e = n } return e }), r }, []); return s = 1 === (o = a).length ? bE : xE, o.forEach(function (t, e) { for (var i = 0, n = t; i < n.length; i += 1)n[i].y = s(e, o.length) }), function (t, e) { var i = e.coord, n = e.decross, r = e.separation; if (t.every(function (t) { return 1 === t.length })) return t.forEach(function (t) { return t[0].x = mE / 2 }); n(t), i(t, r) }(a, { decross: i, coord: r, separation: n }), t.nodes.forEach(function (t) { t.data && (t.children = t.children.filter(function (t) { return t.data })) }), t } function bE() { return vE / 2 } function xE(t, e) { return vE * t / (e - 1) } function EE(t) { return { id: "" + t.id, layer: t.layer, sink: t.sink, radius: t.r, fixed: !1 === t.layoutable, parentIds: [], ref: null } } function AE(t, e) { void 0 === e && (e = {}); for (var i = (t.edges || []).filter(function (t) { return t.source !== t.target }), n = {}, r = 0, o = t.nodes; r < o.length; r += 1) { var s = o[r]; n[s.id] = s } var a = hx(t.nodes, i, n), u = function (t, e, i) { void 0 === i && (i = {}); for (var n = ex(e), r = Object.keys(n), o = []; r.length;) { var s = tx(r[0], n); o.push(s), r = ox(r, s) } return i.skipSingletons ? o : o.concat(rx(t, e, n).map(function (t) { return [t.id + ""] })) }(t.nodes, a, { skipSingletons: "singleton" === e.packing }), l = a.reduce(function (t, e) { return t[e.source] || (t[e.source] = EE(n[e.source])), t[e.target] || (t[e.target] = EE(n[e.target])), t[e.target].parentIds.push("" + e.source), t }, {}); return { shapes: u.map(function (t) { return t.map(function (t) { return l[t] || EE({ id: t }) }) }), nLookup: n } } function SE(t, e) { void 0 === e && (e = {}); for (var i = [], n = 0, r = t; n < r.length; n += 1) { var o = _E(r[n]); i.push(o), yE(o, { decross: function (i) { return i.slice(0, i.length - 1).forEach(function (t, e) { return cx(t, i[e + 1]) }), i }, separation: ix(nx(o.nodes)), coord: e.evenDistribution ? xx() : bx(), layering: aE(e) }) } return i } function wE(t, e) { if (!t || !t.nodes) return t; var i, n, r, o, s, a, u = e || {}, l = AE(t, u), d = l.shapes, h = l.nLookup, c = SE(d, u); if ("singleton" === u.packing) { var f = rx(t.nodes, t.edges), g = pE(f, u); c.push((i = f, n = g, Object.assign({}, { nodes: i.map(function (t) { return Object.assign({}, t, { data: t }) }), isFake: !0 }, n))) } return r = c, o = h, a = SE, void 0 === (s = u) && (s = {}), (cE[s.packing] || cE.rect)(r, o, s, a), t } function TE(t) { return C({}, ((u = t).modules.layouts.register("concentric", kb), { concentric: function (t) { return u.modules.layouts.start("concentric", t) } }), ((a = t).modules.layouts.register("radial", Rb), { radial: function (t) { if (void 0 === t.centralNode) throw new Error('concentric layout: missing parameter "centralNode"'); t.nodes = a.modules.graph.getNodes(t.nodes); var e = t.nodes.size; if (t.radiusRatio = isFinite(t.radiusRatio) ? t.radiusRatio : Math.SQRT2, t.radiusDelta = isFinite(t.radiusDelta) ? t.radiusDelta : 0, t.nodeGap = isFinite(t.nodeGap) ? t.nodeGap : 10, t.repulsion = e * (isFinite(t.repulsion) ? t.repulsion : 1), t.maxIterations = isFinite(t.maxIterations) ? Math.floor(t.maxIterations) : 100, t.maxIterations < 1) throw new RangeError("maxIterations must be a positive integer"); if (t.iterationsPerRender = isFinite(t.iterationsPerRender) ? Math.floor(t.iterationsPerRender) : 20, t.iterationsPerRender < 1) throw new RangeError("iterationsPerRender must be a positive integer"); if (t.epsilon = isFinite(t.epsilon) ? t.epsilon : .001, t.epsilon <= 0) throw new RangeError("epsilon has to be a positive number"); return a.modules.layouts.start("radial", t) } }), ((s = t).modules.layouts.register("force", zb), { force: function (t) { if (void 0 === t && (t = {}), t.nodes) { if (Array.isArray(t.nodes)) t.nodes = s.getNodes(t.nodes); else if (!(t.nodes instanceof tn)) throw new Error("'nodes' must be a NodeList or an Array<NodeId>") } else t.nodes = s.modules.graph.getNodes(); if (t.incremental) return Qb(t, s, s.layouts.force); if (void 0 !== t.edgeStrength && (!isFinite(t.edgeStrength) || t.edgeStrength <= 0 || 1 < t.edgeStrength)) throw new Error("force layout: edgeStrength must be between 0 and 1"); if (void 0 !== t.steps && (!isFinite(t.steps) || t.steps <= 0)) throw new Error("force layout: 'steps' must be a positive integer"); if (void 0 !== t.edgeLength && (!isFinite(t.edgeLength) || t.edgeLength <= 0)) throw new Error("force layout: 'edgeLength' must be positive"); if (void 0 !== t.gravity && (!isFinite(t.gravity) || t.gravity < 0 || 1 <= t.gravity)) throw new Error("force layout: 'gravity' must be between 0 and 1"); if (void 0 !== t.charge && !isFinite(t.charge)) throw new Error("force layout: 'charge' must be a number"); if (void 0 !== t.radiusRatio && (!isFinite(t.radiusRatio) || t.radiusRatio < 0)) throw new Error("force layout: 'radiusRatio' must be a positive number"); if (void 0 !== t.theta && (!isFinite(t.theta) || t.theta < 0 || 1 < t.theta)) throw new Error("force layout: 'theta' must be between 0 and 1"); if (!(void 0 === t.cx && void 0 === t.cy || "number" == typeof t.cx && "number" == typeof t.cy)) throw new Error("force layout: both 'cx' and 'cy' must be numbers"); if (void 0 !== t.siblingsOffset && !isFinite(t.siblingsOffset)) throw new Error("force layout: 'siblingsOffset' must be a number"); return s.modules.layouts.start("force", t) } }), ((o = t).modules.layouts.register("forceLink", Jb), { forceLink: function (t) { if (void 0 === t && (t = {}), t.nodes) { if (Array.isArray(t.nodes)) t.nodes = o.getNodes(t.nodes); else if (!(t.nodes instanceof tn)) throw new Error("'nodes' must be a NodeList or an Array<NodeId>") } else t.nodes = o.modules.graph.getNodes(); return t.incremental ? Qb(t, o, o.layouts.forceLink) : o.modules.layouts.start("forceLink", t) } }), ((n = t).modules.layouts.register("hierarchical", ME), { hierarchical: function (t) { return void 0 === t && (t = {}), t.useWebWorker = !1, n.modules.layouts.start("hierarchical", t) } }), ((i = t).modules.layouts.register("sequential", ME), { sequential: function (t) { void 0 === t && (t = {}), t.useWebWorker = !1; var e = C({}, t, { evenDistribution: !0 }); return i.modules.layouts.start("sequential", e) } }), ((e = t).modules.layouts.register("grid", IE), { grid: function (t) { return void 0 === t && (t = {}), e.modules.layouts.start("grid", t) } }), (r = t, { incremental: function (t) { hi("Incremental ForceLink layout is now deprecated.\n    Please use the incremental option in force and forceLink layouts."); var e = t.nodes, i = t.centralNode; if (e instanceof tn && 0 === e.size || Array.isArray(e) && 0 === e.length) throw new Error("Incremental ForceLink layout: no nodes are selected"); if ("margin" in t && !isFinite(t.margin)) throw new Error("Incremental ForceLink layout: margin has to be a positive number"); if (i && !i.getAttribute("layoutable")) return Kb(r, t, r.layouts.forceLink); var n = C({}, t, { nodes: t.nodes instanceof tn ? t.nodes : r.getNodes(t.nodes) }); return Zb(r, n, r.layouts.forceLink) } }), { stop: function () { return t.modules.layouts.stop() } }); var r, e, i, n, o, s, a, u } var CE = { direction: "TB", nodeDistance: 50, levelDistance: 50, arrangeComponents: "fit", gridDistance: 50, layer: "layer" }, ME = { imports: { sequential: wE }, configure: function (t, e) { void 0 === t && (t = {}); var i = e.graph, n = e.data; function r(t, e, i) { return void 0 === i && (i = t.getNodes()), e ? e instanceof tn ? e : t.getNodes(e) : i } var o = C({}, CE, t, { nodeList: null }); o.nodeList = r(i, t.nodes), o.direction = t.direction || o.rankdir || CE.direction, o.layerSeparation = o.levelDistance, o.nodesSeparation = o.nodeDistance, o.packing = o.arrangeComponents; var s = C({}, o), a = i.getEdges(), u = i.getNodes(o.nodeList); if (-1 === ["TB", "BT", "LR", "RL"].indexOf(o.direction)) throw new Error('direction should be one of the "TB", "BT", "LR", "RL"'); if (-1 === ["fit", "grid", "singleLine"].indexOf(o.packing)) throw new Error('arrangeComponents should be one of the "fit", "grid", "singleLine"'); o.nodesGridSeparation = t.gridDistance; var l = u.getId(), d = u.getAttribute("layoutable").reduce(function (t, value, e) { return t[l[e]] = value, t }, {}), h = u.getAttributes(["x", "y"]).reduce(function (t, value, e) { return t[l[e]] = value, t }, {}), c = u.getAttribute("radius"); if ("string" != typeof s.layer) throw new Error("'layer' should be the valid data field name"); for (var f = r(i, o.roots, i.nodeList()), g = n.getProperty(o.nodeList, s.layer), p = 0, _ = f.map(function (i) { var n = -1; return o.nodeList.forEach(function (t, e) { t === i && (n = e) }), n }); p < _.length; p++) { g[_[p]] = 0 } var v = r(i, o.sinks, i.nodeList()).toArray().reduce(function (t, e) { return t[e.getId()] = !0, t }, {}), m = l.map(function (t) { return v[t] }); return { nodes: l, edges: a.map(function (t) { return { id: t.getId(), source: t.getSource().getId(), target: t.getTarget().getId() } }), options: K(o), layoutable: d, radiuses: c, layers: g, sinks: m, coords: h } }, context: function () { }, update: function (t) { var e = t.nodes, i = t.edges, n = t.options, r = t.layoutable, o = t.radiuses, s = t.layers, a = t.sinks, u = t.coords, l = i.filter(function (t) { var e = t.source, i = t.target; return e in r && i in r }); return { positions: wE({ nodes: e.map(function (t, e) { return { id: t, r: o[e], layer: s[e], sink: a[e], layoutable: r[t], x: u[t].x, y: u[t].y } }), edges: l }, { packing: { fit: "rect", singleLine: "hierarchy", grid: "singleton" }[n.arrangeComponents], direction: { TB: "down", BT: "up", RL: "left", LR: "right" }[n.direction], layerSeparation: n.layerSeparation, nodesSeparation: n.nodesSeparation, nodesGridSeparation: n.nodesGridSeparation, evenDistribution: n.evenDistribution }).nodes } }, isRunning: function () { return !1 }, onSync: function (t, e) { var i = t.positions, n = e.graph; return { indexes: i.map(function (t) { var e = t.id; return n.getNode(e)._index }), x: i.map(function (t) { return t.x }), y: i.map(function (t) { return t.y }) } } }, IE = { configure: function (t, e) { var i = e.graph, n = e.camera; function r(t) { return void 0 === t || "number" == typeof t && isFinite(t) && 0 < t } var o = t.sortBy, s = C({}, t, { nodes: null }); t.nodes || (s.nodes = i.getNodes()), t.nodes && (s.nodes = t.nodes instanceof tn ? t.nodes : i.getNodes(t.nodes)); var a, u, l, d, h, c = s.nodes, f = Array.from(c._indexes), g = f.length, p = function (t, e, i) { if (!r(t)) throw new TypeError('"rows" should be a positive integer'); if (!r(e)) throw new TypeError('"cols" should be a positive integer'); if (t) return { rows: t, cols: Math.ceil(i / t) }; if (e) return { cols: e, rows: Math.ceil(i / e) }; var n = Math.ceil(Math.sqrt(i)); return { cols: n, rows: Math.ceil(i / n) } }(s.rows, s.cols, g), _ = p.rows, v = p.cols, m = (a = o, u = i, l = c, d = f, h = t.sortFallbackValue, "string" != typeof a ? d.map(function (t, e) { return e }) : "radius" === a ? u.getAttribute(!0, "radius").getMultiple(d) : "random" === a ? d.map(function () { return Math.random() }) : l.getData(a).map(function (value) { return value || h })), y = c.getAttribute("layoutable"), b = f.reduce(function (t, e, i) { return y[i] && t.push({ id: e, attr: m[i] }), t }, []), x = c.getBoundingBox(), E = .65 * Math.max(x.maxScaledSize, x.maxFixedSize / n.getZoom()), A = x.minX + E, S = x.maxX - E, w = x.minY + E, T = x.maxY - E; return x.width < E * v * 2 && (A = x.cx - E * v + E, S = x.cx + E * v - E), x.height < E * _ * 2 && (w = x.cy - E * _ + E, T = x.cy + E * _ - E), { sort: !!o, nodes: b, reverse: !!s.reverse, cols: v, rows: _, minX: A, maxX: S, minY: w, maxY: T } }, update: function (t) { var e = t.sort, i = t.nodes, n = t.maxX, r = t.minX, o = t.maxY, s = t.minY, a = t.reverse, u = t.rows, l = t.cols; e && i.sort(function (t, e) { var i = t.attr, n = e.attr; return i < n ? -1 : n < i ? 1 : 0 }), a && i.reverse(); var d = (n - r) / (l - 1), h = (o - s) / (u - 1), c = r, f = s; isFinite(d) || (d = 0), isFinite(h) || (h = 0); var g = 0, p = 0; return i.forEach(function (t) { t.x = c + g * d, t.y = f + p * h, (g += 1) === l && (p += 1, g = 0) }), i }, onSync: function (t) { return { indexes: t.map(function (t) { return t.id }), x: t.map(function (t) { return t.x }), y: t.map(function (t) { return t.y }) } } }, LE = (NE.initNamespace = function (t) { t.layouts = TE(t) }, NE); function NE() { } var kE = (OE.initNamespace = function (t) { var i; t.mouse = (i = t, { move: function (t) { return i.modules.virtualMouse.move(t) }, down: function (t) { return i.modules.virtualMouse.down(t) }, up: function (t) { return i.modules.virtualMouse.up(t) }, click: function (t) { return i.modules.virtualMouse.click(t) }, rightClick: function (t) { return i.modules.virtualMouse.rightClick(t) }, doubleClick: function (t) { return i.modules.virtualMouse.doubleClick(t) }, drag: function (t, e) { return i.modules.virtualMouse.drag(t, e) }, wheel: function (t) { return i.modules.virtualMouse.wheel(t) } }) }, OE); function OE() { } var FE = (RE.initNamespace = function (t) { var n; t.pathfinding = (n = t, { astar: function (t, e, i) { return void 0 === i && (i = {}), n.modules.pathfinding.astar(t, e, i) }, dijkstra: function (t, e, i) { return void 0 === i && (i = {}), n.modules.pathfinding.dijkstra(t, e, i) }, dijkstraBig: function (t, e, i) { return void 0 === i && (i = {}), n.modules.pathfinding.dijkstraBig(t, e, i) } }) }, RE); function RE() { } var PE = (DE.initNamespace = function (t) { var e; t.rules = (e = t, { map: function (t) { return e.modules.rules.createMapping(t) }, slices: function (t) { return e.modules.rules.createSlices(t) }, template: function (t) { return e.modules.rules.createTemplate(t) } }) }, DE); function DE() { } var zE = (BE.prototype.clearSelection = function () { return this.modules.selection.clear() }, BE.prototype.getSelectedNodes = function () { return this.modules.selection.getSelectedNodes() }, BE.prototype.getNonSelectedNodes = function () { return this.modules.selection.getNonSelectedNodes() }, BE.prototype.getSelectedEdges = function () { return this.modules.selection.getSelectedEdges() }, BE.prototype.getNonSelectedEdges = function () { return this.modules.selection.getNonSelectedEdges() }, BE); function BE() { } var UE = (VE.prototype.setOptions = function (t) { return this.modules.settings.update(t) }, VE.prototype.getOptions = function () { return this.modules.settings.get() }, VE); function VE() { } var jE = (GE.initNamespace = function (t) { var r; t.styles = (r = t, { setNodesVisibility: function (value) { return r.modules.graphics.setNodesVisibility(value) }, setEdgesVisibility: function (value) { return r.modules.graphics.setEdgesVisibility(value) }, setNodeTextsVisibility: function (value) { return r.modules.graphics.setNodeTextsVisibility(value) }, setEdgeTextsVisibility: function (value) { return r.modules.graphics.setEdgeTextsVisibility(value) }, addRule: function (t) { return r.modules.styleRules.addRule(t) }, getRuleList: function () { return r.modules.styleRules.getRuleList() }, addNodeRule: function (t, e) { var i, n; return n = 1 === arguments.length ? void (i = t) : (i = e, t), r.styles.addRule({ nodeAttributes: i, nodeSelector: n }) }, addEdgeRule: function (t, e) { var i, n; return n = 1 === arguments.length ? void (i = t) : (i = e, t), r.styles.addRule({ edgeAttributes: i, edgeSelector: n }) }, getNodeRules: function () { return r.styles.getRuleList().filter(function (t) { return void 0 === t.getDefinition().edgeAttributes }) }, getEdgeRules: function () { return r.styles.getRuleList().filter(function (t) { return void 0 === t.getDefinition().nodeAttributes }) }, createClass: function (t) { return r.modules.classes.createClass(t) }, getClass: function (t) { return r.modules.classes.getClassByName(t) }, getClassList: function () { return r.modules.classes.getClassList() }, setHoveredNodeAttributes: function (t, e) { r.modules.hover.updateNodeAttributes(t, e) }, setHoveredEdgeAttributes: function (t, e) { r.modules.hover.updateEdgeAttributes(t, e) }, setSelectedNodeAttributes: function (t, e) { return r.modules.selection.setNodeAttributes(t, e) }, setSelectedEdgeAttributes: function (t, e) { return r.modules.selection.setEdgeAttributes(t, e) } }) }, GE); function GE() { } var HE = (qE.initNamespace = function (t) { var e; t.schema = (e = t, { watchNodeObjectProperty: function (t) { return e.modules.watcher.watchNodeObjectProperty(t) }, watchEdgeObjectProperty: function (t) { return e.modules.watcher.watchEdgeObjectProperty(t) }, watchNodeNonObjectProperty: function (t) { return e.modules.watcher.watchNodeNonObjectProperty(t) }, watchEdgeNonObjectProperty: function (t) { return e.modules.watcher.watchEdgeNonObjectProperty(t) } }) }, qE); function qE() { } function WE(t) { return { lasso: { enable: function (t) { return l.modules.lasso.enable(t), this }, disable: function () { return l.modules.lasso.disable(), this }, enabled: function () { return l.modules.lasso.enabled() } }, connectNodes: { enable: function (t) { return u.modules.connectNodes.enable(t), this }, disable: function () { return u.modules.connectNodes.disable(), this }, enabled: function () { return u.modules.connectNodes.enabled() } }, legend: { enable: function (t) { return a.modules.legend.enable(t) }, disable: function () { return a.modules.legend.disable() }, enabled: function () { return a.modules.legend.enabled() }, getOptions: function () { return a.modules.legend.getOptions() } }, rectangleSelect: { enable: function (t) { s.modules.rectangleSelect.enable(t) }, disable: function () { s.modules.rectangleSelect.disable() }, enabled: function () { return s.modules.rectangleSelect.enabled() } }, resize: { enable: function (t) { return o.modules.resizing.enable(t), this }, disable: function () { return o.modules.resizing.disable(), this }, enabled: function () { return o.modules.resizing.enabled() } }, rewire: { enable: function (t) { return r.modules.rewiring.enable(t), this }, disable: function () { return r.modules.rewiring.disable(), this }, enabled: function () { return r.modules.rewiring.enabled() } }, snapping: { enable: function (t) { return e.modules.snapping.enable(t), this }, disable: function () { return e.modules.snapping.disable(), this }, enabled: function () { return e.modules.snapping.enabled() } }, tooltip: { onNodeHover: function (t, e) { n.modules.tooltip.setHandler("hover.node", t, e) }, onNodeClick: function (t, e) { n.modules.tooltip.setHandler("click.left.node", t, e) }, onNodeRightClick: function (t, e) { n.modules.tooltip.setHandler("click.right.node", t, e) }, onNodeDoubleClick: function (t, e) { n.modules.tooltip.setHandler("doubleClick.left.node", t, e) }, onEdgeHover: function (t, e) { n.modules.tooltip.setHandler("hover.edge", t, e) }, onEdgeClick: function (t, e) { n.modules.tooltip.setHandler("click.left.edge", t, e) }, onEdgeRightClick: function (t, e) { n.modules.tooltip.setHandler("click.right.edge", t, e) }, onEdgeDoubleClick: function (t, e) { n.modules.tooltip.setHandler("doubleClick.left.edge", t, e) }, onBackgroundClick: function (t, e) { n.modules.tooltip.setHandler("click.left.background", t, e) }, onBackgroundRightClick: function (t, e) { n.modules.tooltip.setHandler("click.right.background", t, e) }, onBackgroundDoubleClick: function (t, e) { n.modules.tooltip.setHandler("doubleClick.left.background", t, e) }, refresh: function () { return n.modules.tooltip.refresh() }, isShown: function () { return n.modules.tooltip.isShown() }, hide: function () { n.modules.tooltip.hide() }, show: function (t, e) { return n.modules.tooltip.show(t, e) } }, brand: (i = n = e = r = o = s = a = u = l = t, { set: function (t, e) { return i.modules.brand.set(t, e) }, remove: function () { i.modules.brand.remove() } }) }; var i, n, e, r, o, s, a, u, l } var XE = (YE.initNamespace = function (t) { t.tools = WE(t) }, YE); function YE() { } function ZE(t) { return !0 } function KE(t) { return "" } function QE(t, e, i) { return {} } var JE, $E = (b(tA, JE = Oc), tA.prototype._computeNodeGroupId = function (t) { return this._nodeSelector(t) ? this._nodeGroupIdFunction(t) : void 0 }, tA.prototype._computeEdgeGroupId = function (t) { return this._edgeSelector(t) ? this._edgeGroupIdFunction(t) : void 0 }, tA.prototype._addMetaNodes = function (o, t) { for (var e = t.getId(), i = o.getNodes(), n = new Map, r = 0; r < i.size; ++r) { var s = i.get(r); if (void 0 !== (h = this._computeNodeGroupId(s))) { var a = n.get(h); a || (a = { id: h, nodes: [] }, n.set(h, a)), a.nodes.push(s) } } var u = io(n), l = u.map(function (t) { var e = t.nodes; return o.getNodes(e) }), d = []; for (r = 0; r < u.length; ++r) { var h = u[r].id, c = l[r], f = this._nodeGenerator(c, h, t); void 0 === f.id && (f.id = iA(h, e)), f.position = Wd(c.getPosition()), d.push(f) } return o.addNodes(d.map(function (t) { return { id: t.id, attributes: t.position } }), { virtual: !0 }).then(function () { var i = o.getNodes(d.map(function (t) { return t.id })); i.replaceOriginalAttributes(d.map(function (t) { return t.attributes }), ["x", "y"]); for (var t = i.getData(), e = 0; e < t.length; e++) { var n = t[e], r = d[e]; t[e] = void 0 === n ? r.data : C({}, n, r.data) } return i.setData(null, t), i.setVisible(!0), o.modules.grouping.setSubElements(i, l), l.forEach(function (t, e) { o.modules.grouping.setMetaElement(t, i.get(e)) }), i }) }, tA.prototype._addMetaEdges = function (o, t) { for (var e = t.getId(), i = o.getEdges(), n = new Map, r = o.modules.graphics.getAttributesManager().getUsedEdgeAttributes(), s = 0; s < i.size; ++s) { var a = i.get(s); if (void 0 !== (y = this._computeEdgeGroupId(a))) { var u = this._edgeSource(a), l = this._edgeTarget(a), d = this._groupEdges ? eA(y, u.getId(), l.getId(), this._separateEdgesByDirection) : String(a.getId()); (m = n.get(d)) || (m = { id: d, source: u, target: l, edges: [] }, n.set(d, m)), m.edges.push(a) } } var h, c, f, g, p = io(n), _ = p.map(function (t) { var e = t.edges; return o.getEdges(e) }), v = []; for (s = 0; s < p.length; ++s) { var m, y = (m = p[s]).id, b = _[s], x = this._groupEdges ? this._edgeGenerator(b, y, t) : (f = r, g = void 0, { data: (g = b.get(0)).getData(), attributes: g.getAttributes(f) }); if (null != x.id && (h = o, c = x.id, null != h.getEdge(c))) throw Error("The id " + x.id + " returned by the edgeGenerator function is not a unique id."); void 0 === x.id && (x.id = iA(y, e)), x.source = m.source.getId(), x.target = m.target.getId(), v.push(x) } return o.addEdges(v.map(function (t) { return { id: t.id, source: t.source, target: t.target } }), { virtual: !0 }).then(function () { var i = o.getEdges(v.map(function (t) { return t.id })); i.replaceOriginalAttributes(v.map(function (t) { return t.attributes })); for (var t = i.getData(), e = 0; e < t.length; e++) { var n = v[e], r = t[e]; t[e] = void 0 === r ? n.data : C({}, r, n.data) } return i.setData(null, t), i.setVisible(!0), o.modules.grouping.setSubElements(i, _), _.forEach(function (t, e) { o.modules.grouping.setMetaElement(t, i.get(e)) }), i }) }, tA); function tA(t) { var e = JE.call(this, t) || this; return e._nodeSelector = t.nodeSelector, e._nodeGroupIdFunction = t.nodeGroupIdFunction, e._nodeGenerator = t.nodeGenerator, e._edgeSelector = t.edgeSelector, e._edgeGroupIdFunction = t.edgeGroupIdFunction, e._edgeGenerator = t.edgeGenerator, e._edgeSource = t.edgeSource, e._edgeTarget = t.edgeTarget, e._separateEdgesByDirection = t.separateEdgesByDirection, e._groupSelfLoopEdges = t.groupSelfLoopEdges, e._groupEdges = t.groupEdges, e } function eA(t, e, i, n) { var r = e, o = i; return !n && r.toString() > o.toString() && (r = i, o = e), t + "[" + r + "-" + o + "]" } function iA(t, e) { return "gen_grp_" + e + "_" + t } var nA, rA = (b(oA, nA = $E), oA.prototype.getName = function () { return "node-grouping" }, oA.prototype.run = function (t) { var e, i, r, o, s, n = this, a = t.ogma, u = t.duration, l = t.wrapper; return this._addMetaNodes(a, l).then(function (t) { return (e = t).setVisible(!1), n._addMetaEdges(a, l) }).then(function (t) { (i = t).setVisible(!1), r = e.getSubNodes().reduce(function (t, value) { return t.concat(value) }, a.createNodeList()), o = i.getSubEdges().reduce(function (t, value) { return t.concat(value) }, a.createEdgeList()); var n = a.getNodes(r.getMetaNode()).getPosition(); return s = r.getPosition().map(function (t, e) { var i = n[e]; return { x: t.x - i.x, y: t.y - i.y } }), r.setAttributes(n, u) }).then(function () { return r.setVisible(!1), o.setVisible(!1), e.setVisible(!0), i.filter(function (t) { return n._groupSelfLoopEdges || t.getSource() !== t.getTarget() }).setVisible(!0), { metaNodes: e, metaEdges: i, subNodes: r, subEdges: o, offsets: s } }) }, oA.prototype.undo = function (t) { var e = this, i = t.ogma, n = t.duration, r = t.context, o = r.metaNodes, s = r.metaEdges, a = r.subNodes, u = r.subEdges, l = r.offsets, d = i.getNodes(a.getMetaNode()).getPosition(), h = d.map(function (t, e) { return i = t, n = l[e], { x: i.x + n.x, y: i.y + n.y }; var i, n }); return a.setVisible(!0), u.setVisible(!0), i.modules.grouping.setMetaElement(a, null), i.modules.grouping.setMetaElement(u, null), o.setVisible(!1), s.setVisible(!1), a.setAttributes(d).then(function () { if (e._restorePositions) return a.setAttributes(h, n) }) }, oA.prototype.cleanup = function (t) { var e = t.ogma, i = t.context, n = i.metaNodes, r = i.metaEdges, o = n.filter(function (t) { return !t.isVisible() }), s = r.filter(function (t) { return !t.isVisible() }); return Promise.all([e.removeEdges(s, { virtual: !0 }), e.removeNodes(o, { virtual: !0 })]).then(function () { return Promise.resolve() }) }, oA); function oA(t) { var e = t.selector, i = void 0 === e ? ZE : e, n = t.groupIdFunction, r = void 0 === n ? KE : n, o = t.nodeGenerator, s = void 0 === o ? QE : o, a = t.edgeGenerator, u = void 0 === a ? QE : a, l = t.separateEdgesByDirection, d = void 0 !== l && l, h = t.groupSelfLoopEdges, c = void 0 !== h && h, f = t.groupEdges, g = void 0 === f || f, p = t.restorePositions, _ = void 0 === p || p, v = nA.call(this, { nodeSelector: i, nodeGroupIdFunction: r, nodeGenerator: s, edgeSelector: function (t) { return !(!t.getSource().getMetaNode() && !t.getTarget().getMetaNode()) }, edgeGroupIdFunction: function () { return "" }, edgeGenerator: u, edgeSource: function (t) { return sA(t.getSource()) }, edgeTarget: function (t) { return sA(t.getTarget()) }, separateEdgesByDirection: d, groupEdges: g }) || this; return v._groupSelfLoopEdges = c, v._restorePositions = _, v } function sA(t) { return t.getMetaNode() || t } var aA, uA = (b(lA, aA = $E), lA.prototype.getName = function () { return "edge-grouping" }, lA.prototype.run = function (t) { var e, i, n = t.ogma, r = t.wrapper; return this._addMetaEdges(n, r).then(function (t) { return (i = (e = t).getSubEdges().reduce(function (t, value) { return t.concat(value) }, n.createEdgeList())).setVisible(!1), { metaEdges: e, subEdges: i } }) }, lA.prototype.undo = function (t) { var e = t.context, i = e.metaEdges; return e.subEdges.setVisible(!0), i.setVisible(!1), Promise.resolve() }, lA.prototype.cleanup = function (t) { var e = t.ogma, i = t.context.metaEdges; return e.removeEdges(i.filter(function (t) { return !t.isVisible() }), { virtual: !0 }) }, lA); function lA(t) { var e = t.selector, i = void 0 === e ? ZE : e, n = t.groupIdFunction, r = void 0 === n ? KE : n, o = t.generator, s = void 0 === o ? QE : o, a = t.separateEdgesByDirection, u = void 0 !== a && a; return aA.call(this, { nodeSelector: null, nodeGroupIdFunction: null, nodeGenerator: null, edgeSelector: i, edgeGroupIdFunction: r, edgeGenerator: s, edgeSource: function (t) { return t.getSource() }, edgeTarget: function (t) { return t.getTarget() }, separateEdgesByDirection: u, groupEdges: !0 }) || this } var dA, hA = (b(cA, dA = Oc), cA.prototype.getName = function () { return Gv.NeighborGeneration }, cA.prototype.run = function (t) { for (var value, u = this, l = t.ogma, e = t.duration, i = t.wrapper.getId(), n = l.getNodes(), r = new Map, o = 0; o < n.size; ++o) { var s = n.get(o), a = (value = this._generateIds(s), Array.isArray(value) ? value : value ? [value] : null); if (a) for (var d = 0; d < a.length; ++d) { var h = a[d]; (v = r.get(h)) || (v = [], r.set(h, v)), v.push(s) } } var c, f, g = new Array(r.size), p = eo(r), _ = io(r).map(function (t) { return l.getNodes(t) }); for (o = 0; o < g.length; ++o) { h = p[o]; var v = _[o], m = this._nodeGenerator(h, v); m.id = "_gen_" + i + "_" + h; var y = Wd(v.getPosition()); m.attributes = m.attributes || {}, m.attributes.x = y.x, m.attributes.y = y.y, g[o] = m } return l.addNodes(g.map(function (t) { return { id: t.id, attributes: t.attributes } }), { virtual: !0 }).then(function (t) { (c = t).replaceOriginalAttributes(g.map(function (t) { return t.attributes }), ["x", "y"]), c.setData(null, g.map(function (t) { return t.data })); for (var e = [], i = 0; i < t.size; ++i)for (var n = t.get(i), r = _[i], o = 0; o < r.size; ++o) { var s = r.get(o), a = u._edgeGenerator(s, n); a.source || a.target || (a.source = s.getId(), a.target = n.getId()), e.push(a) } return l.addEdges(e, { virtual: !0 }) }).then(function (t) { return f = t, c.setVisible(!0), f.setVisible(!0), c.addClass(gl), f.addClass(gl), Promise.all([c.removeClass(gl, e), f.removeClass(gl, e)]) }).then(function () { return { virtualNodes: c, virtualEdges: f } }) }, cA.prototype.undo = function (t) { var e = t.context, i = t.duration, n = e.virtualNodes, r = e.virtualEdges; return Promise.all([n.addClass(gl, i), r.addClass(gl, i)]).then(function () { n.setVisible(!1), r.setVisible(!1) }) }, cA.prototype.cleanup = function (t) { var e = t.ogma, i = t.context, n = i.virtualEdges, r = i.virtualNodes.filter(function (t) { return !t.isVisible() }), o = n.filter(function (t) { return !t.isVisible() }); return e.removeNodes(r, { virtual: !0 }), e.removeEdges(o, { virtual: !0 }), Promise.resolve() }, cA); function cA(t) { var e = dA.call(this) || this, i = t.selector, n = void 0 === i ? function () { return !0 } : i, r = t.neighborIdFunction, o = void 0 === r ? function () { return null } : r, s = t.nodeGenerator, a = void 0 === s ? function () { return {} } : s, u = t.edgeGenerator, l = void 0 === u ? function () { return { source: null, target: null } } : u; return e._generateIds = function (t) { return n(t) && o(t) }, e._nodeGenerator = a, e._edgeGenerator = l, e } var fA, gA = (b(pA, fA = Oc), pA.prototype.run = function (t) { for (var e = t.ogma, i = t.duration, n = e.getNodes().filter(this._selector), r = [], o = new Map, s = 0; s < n.size; ++s)for (var a = n.get(s), u = a.getAdjacentEdges(), l = this._dataFunction(a), d = 0; d < u.size; ++d) { var h = u.get(d), c = h.getSource(), f = h.getTarget(); if (c !== f && void 0 !== l) { var g = c === a ? f : c, p = o.get(g); p || (p = [], o.set(g, p)), p.push(l) } r.push(h) } var _ = e.getEdges(r), v = e.getNodes(eo(o)), m = io(o), y = v.getData(), b = new Array(v.size); for (s = 0; s < b.length; ++s) { var x = m[s], E = y[s]; for (d = 0; d < x.length; ++d)E = $(E, x[d]); b[s] = E } return Promise.all([n.addClass(gl, i), _.addClass(gl, i)]).then(function () { return n.setVisible(!1), _.setVisible(!1), v.setData(b), { hiddenNodes: n, hiddenEdges: _, nodesWithDataChange: v, oldDataList: y } }) }, pA.prototype.getName = function () { return Gv.NeighborMerging }, pA.prototype.undo = function (t) { var e = t.duration, i = t.context, n = i.hiddenNodes, r = i.hiddenEdges, o = i.nodesWithDataChange, s = i.oldDataList; return n.setVisible(!0), r.setVisible(!0), n.addClass(gl), r.addClass(gl), Promise.all([n.removeClass(gl, e), r.removeClass(gl, e)]).then(function () { o.setData(s) }) }, pA); function pA(t) { var e = t.selector, i = void 0 === e ? function () { return !1 } : e, n = t.dataFunction, r = void 0 === n ? function () { } : n, o = fA.call(this) || this; return o._selector = i, o._dataFunction = r, o } function _A(t, e) { return t.size === e.size && 0 < t.filter(function (t) { return e.includes(t) }).size } var vA, mA = (b(yA, vA = Oc), yA.prototype.getName = function () { return Gv.NodeCollapsing }, yA.prototype.run = function (t) { for (var e = this, i = t.ogma, n = t.duration, r = i.getNodes().filter(this._selector), o = r.getAdjacentEdges(), s = [], a = r.map(function (t) { return t.getAdjacentNodes().filter(function (t) { return !e._selector(t) }) }), u = 0; u < r.size; u++)for (var l = u; l < r.size; l++) { var d = r.get(u), h = r.get(l); if (0 < i.modules.graph.getEdgesBetweenTwoNodes(d, h).size && (a[u].size || a[l].size) && !_A(a[u], a[l])) throw Error("addNodeCollapsing: invalid connected nodes [" + d.getId() + "] and [" + h.getId() + "] to be collapsed. The addNodeCollapsing function supports only disconnected nodes.") } for (u = 0; u < r.size; ++u) { var c = r.get(u), f = a[u]; for (l = 0; l < f.size - 1; ++l) { var g = f.get(l), p = i.modules.graph.getEdgesBetweenTwoNodes(c, g); if (g !== c) for (var _ = l + 1; _ < f.size; ++_) { var v = f.get(_), m = i.modules.graph.getEdgesBetweenTwoNodes(c, v), y = this._edgeGenerator(c, g, v, p, m); if (y) for (var b = L(y), x = 0; x < b.length; ++x)s.push(bA(i, b[x], x, c, g, v, p, m)) } } } return i.addEdges(s, { virtual: !0 }).then(function (t) { return t.addClass(gl) }).then(function (t) { return Promise.all([t.removeClass(gl, n), r.addClass(gl, n), o.addClass(gl, n)]) }).then(function (t) { var e = t[0]; return r.setVisible(!1), o.setVisible(!1), { virtualEdges: e, hiddenNodes: r, hiddenEdges: o } }) }, yA.prototype.undo = function (t) { var e = t.duration, i = t.context, n = i.virtualEdges, r = i.hiddenNodes, o = i.hiddenEdges; return r.setVisible(!0), o.setVisible(!0), Promise.all([r.addClass(gl), o.addClass(gl)]).then(function () { return Promise.all([r.removeClass(gl, e), o.removeClass(gl, e), n.addClass(gl, e)]) }).then(function () { n.setVisible(!1) }) }, yA.prototype.cleanup = function (t) { var e = t.ogma, i = t.context; return e.removeEdges(i.virtualEdges.filter(function (t) { return !t.isVisible() }), { virtual: !0 }) }, yA); function yA(t) { var e = t.selector, i = void 0 === e ? function () { return !1 } : e, n = t.edgeGenerator, r = void 0 === n ? function () { return {} } : n, o = vA.call(this) || this; return o._selector = i, o._edgeGenerator = r, o } function bA(t, e, i, n, r, o, s, a) { var u = null, l = null; if (void 0 !== e.source && (u = t.getNode(e.source)) !== r && u !== o) throw new Error(["addNodeCollapsing: edge generator produced RawEdge with invalid source [" + e.source + "]", "expected to be [" + r.getId() + "] or [" + o.getId() + "]"].join("; ")); if (void 0 !== e.target && (l = t.getNode(e.target)) !== r && l !== o) throw new Error(["addNodeCollapsing: edge generator produced RawEdge with invalid target [" + e.target + "]", "expected to be [" + r.getId() + "] or [" + o.getId() + "]"].join("; ")); if (u && l && u === l) throw new Error("addNodeCollapsing: edge generator produced RawEdge with same source and target [" + u.getId() + "]"); if (u && !l) l = u === r ? o : r; else if (l && !u) u = l === r ? o : r; else if (!u && !l) { for (var d = !0, h = 0; h < s.size; ++h) { s.get(h).getSource() === r && (d = !1) } for (h = 0; h < a.size; ++h) { a.get(h).getTarget() === o && (d = !1) } l = d ? (u = o, r) : (u = r, o) } return C({}, e, { id: "_gen_" + n.getId() + "_" + u.getId() + "_" + l.getId() + "_" + i, source: u.getId(), target: l.getId() }) } var xA, EA = (b(AA, xA = Oc), AA.prototype.getName = function () { return Gv.VirtualProperties }, AA.prototype.run = function (t) { var e = t.ogma, i = { nodes: null, oldNodesData: null, edges: null, oldEdgesData: null }; return this._nodeDataFunction && (i.nodes = e.getNodes().filter(this._nodeSelector), i.oldNodesData = SA(i.nodes, this._nodeDataFunction)), this._edgeDataFunction && (i.edges = e.getEdges().filter(this._edgeSelector), i.oldEdgesData = SA(i.edges, this._edgeDataFunction)), Promise.resolve(i) }, AA.prototype.undo = function (t) { var e = t.context, i = e.nodes, n = e.oldNodesData, r = e.edges, o = e.oldEdgesData; return i && i.setData(n), r && r.setData(o), Promise.resolve() }, AA); function AA(t) { var e = t.nodeSelector, i = void 0 === e ? function () { return !0 } : e, n = t.edgeSelector, r = void 0 === n ? function () { return !0 } : n, o = t.nodeDataFunction, s = void 0 === o ? null : o, a = t.edgeDataFunction, u = void 0 === a ? null : a, l = xA.call(this) || this; return l._nodeSelector = i, l._edgeSelector = r, l._nodeDataFunction = s, l._edgeDataFunction = u, l } function SA(t, e) { for (var i = [], n = 0; n < t.size; ++n) { var r = t.get(n), o = r.getData(), s = $(o, e(r)); i.push(o), r.setData(s) } return i } function wA(t) { return C({}, { getList: function () { return s.modules.transformations.getList() }, clear: function () { return s.modules.transformations.clear() }, afterNextUpdate: function () { return s.modules.transformations.whenApplied() } }, { addNodeGrouping: function (t) { return void 0 === t && (t = {}), o.modules.transformations.add(new rA(t), { duration: t.duration, enabled: t.enabled }) }, addEdgeGrouping: function (t) { return void 0 === t && (t = {}), o.modules.transformations.add(new uA(t), { duration: t.duration, enabled: t.enabled }) } }, { addNodeFilter: function (t) { return r.modules.filters.addNodeFilter(t) }, addEdgeFilter: function (t) { return r.modules.filters.addEdgeFilter(t) } }, { addNeighborGeneration: function (t) { return n.modules.transformations.add(new hA(t), { duration: t.duration, enabled: t.enabled }) }, addNeighborMerging: function (t) { return n.modules.transformations.add(new gA(t), { duration: t.duration, enabled: t.enabled }) } }, { addNodeCollapsing: function (t) { return void 0 === t && (t = {}), i.modules.transformations.add(new mA(t), { duration: t.duration, enabled: t.enabled }) } }, (e = i = n = r = o = s = t, { addVirtualProperties: function (t) { return e.modules.transformations.add(new EA(t), { duration: t.duration, enabled: t.enabled }) } })); var e, i, n, r, o, s } var TA = (CA.initNamespace = function (t) { t.transformations = wA(t) }, CA.prototype.addNodeFilter = function (t) { return this.modules.filters.addNodeFilter(t) }, CA.prototype.addEdgeFilter = function (t) { return this.modules.filters.addEdgeFilter(t) }, CA.prototype.getNodeFilters = function () { return this.modules.transformations.getList().filter(function (t) { return t.getName() === Gv.NodeFilter }) }, CA.prototype.getEdgeFilters = function () { return this.modules.transformations.getList().filter(function (t) { return t.getName() === Gv.EdgeFilter }) }, CA.prototype.clearNodeFilters = function () { return Promise.all(this.getNodeFilters().map(function (t) { return t.destroy() })).then(function () { return Promise.resolve() }) }, CA.prototype.clearEdgeFilters = function () { return Promise.all(this.getEdgeFilters().map(function (t) { return t.destroy() })).then(function () { return Promise.resolve() }) }, CA); function CA() { } var MA = (IA.initNamespace = function (t) { var e, i, n, r, o, s; t.view = (e = t.modules, i = e.camera, n = e.captor, r = e.dom, o = e.graphics, s = e.locate, { setZoom: function (t, e) { return i.setZoom(t, e) }, zoomIn: function (t, e) { return i.zoomIn(t, e) }, zoomOut: function (t, e) { return i.zoomOut(t, e) }, getZoom: function () { return i.getZoom() }, setCenter: function (t, e) { return i.setCenter(t, e) }, move: function (t, e) { return i.move(t, e) }, getCenter: function () { return i.getCenter() }, setAngle: function (t, e) { return i.setAngle(t, e) }, rotate: function (t, e) { return i.rotate(t, e) }, getAngle: function () { return i.getAngle() }, set: function (t, e) { return i.setView(t, e) }, get: function () { return i.getView() }, graphToScreenCoordinates: function (t) { return i.graphToScreenCoordinates(t) }, screenToGraphCoordinates: function (t) { return i.screenToGraphCoordinates(t) }, getImageData: function () { return o.getImageData() }, getElementAt: function (t) { return n.getElementAt(t) }, beforeNextFrame: function () { return r.beforeNextFrame() }, afterNextFrame: function () { return r.afterNextFrame() }, setFullScreen: function (value) { return r.setFullScreen(value) }, isFullScreen: function () { return r.isFullScreen() }, forceResize: function () { return r.forceResize() }, getSize: function () { return r.getDimensions() }, setSize: function (t) { if (!t || isNaN(t.width) || isNaN(t.height)) throw new Error("Size must follow the format { width: number, height: number }"); if (t.width < 0) throw new Error("width must be positive"); if (t.height < 0) throw new Error("height must be positive"); return r.setDimensions(t), Promise.resolve() }, locateGraph: function (t) { return s.locateGraph(t) }, locateRawGraph: function (t, e) { return s.locateRawGraph(t, e) }, getGraphBoundingBox: function () { return s.getGraphBoundingBox() } }) }, IA); function IA() { } function LA(t) { return --t * t * t + 1 } function NA(t, e, i) { var n = t - i[0], r = e - i[1]; return n * n + r * r } var kA = Object.freeze({ __proto__: null, circleCircleIntersection: circleCircleIntersection, circleSortCompare: circleSortCompare, circleContainsPoint: sd, circleContainsCircle: ad, circleIntersectsBox: ud, circleLineIntersection: ld, isPointInLine: Ya, twoSegmentsIntersect: function (t, e, i, n, r) { if (void 0 === r && (r = !1), r && (Za(t, i) || Za(t, n) || Za(e, i) || Za(e, n))) return !1; var o = (t.y - i.y) * (n.x - i.x) - (t.x - i.x) * (n.y - i.y), s = (e.x - t.x) * (n.y - i.y) - (e.y - t.y) * (n.x - i.x); if (0 == s) return !1; var a = o / s, u = (o = (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y)) / s; return !(a <= 0 || 1 <= a || u <= 0 || 1 <= u) }, lineAngle: Ka, angle: function (t, e, i) { var n = Ka(t.x, t.y, e.x, e.y) - Ka(i.x, i.y, e.x, e.y); return n < 0 ? n + 2 * Math.PI : n }, lineIntersection: function (t, e, i, n, r, o, s, a) { var u = (a - o) * (i - t) - (s - r) * (n - e); if (0 == u) return null; var l = e - o; return { x: t + (l = ((s - r) * l - (a - o) * (t - r)) / u) * (i - t), y: e + l * (n - e) } }, segmentIntersection: Qa, segmentRectangleIntersection: Ja, lineLine: $a, lineAABB: tu, distancePointSegment: eu, distToSegmentSquared: iu, getClosestPointOnSegment: nu, getClosestPointOnLine: function (t, e, i, n, r, o) { var s = r - i, a = o - n, u = ((t - i) * s + (e - n) * a) / (s * s + a * a); return { x: i + s * u, y: n + a * u } }, defaultAABB: ua, rotate: la, move: function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = { x: 0, y: 0 }), n.x = t.x + i * Math.sin(e), n.y = t.y + i * Math.cos(e), n }, distance: distance, squaredDistance: da, radiansToDegrees: ha, degreesToRadians: function (t) { return t * Math.PI / 180 }, extendBounds: function (t, e) { return t.minX -= e, t.minY -= e, t.maxX += e, t.maxY += e, t.width += 2 * e, t.height += 2 * e, t }, isPointInPolygon: jd, polygonsIntersect: qd, computeCentroid: Wd, getPointOnQuadraticCurve: hu, isPointOnQuadraticCurve: cu, getPointOnBezierCurve: fu, isPointOnBezierCurve: gu, getQuadraticCurveBoundingBox: pu, getBezierCurveBoundingBox: _u, quadBezierAABB: uu, cubicBezierAABB: du, getSelfLoopControlPoints: ta, getQuadraticCurveControlPoint: $s, getAABB: cp, getOBBPoints: fp, moveAABB: gp, padBounds: function (t, e) { return t.minX -= e, t.minY -= e, t.maxX += e, t.maxY += e, t.width += 2 * e, t.height += 2 * e, t }, overlapsAABB: function (t, e) { return _p(t[0], t[1], t[2], t[3], e[0], e[1], e[2], e[3]) }, intersects: pp, overlaps: _p }); var OA = Object.freeze({ __proto__: null, minHeap: minHeap, bellmanFord: bellmanFord, dijkstra: dijkstra, johnson: johnson, largestEmptyCircle: Gb, minDisk: minDisk, removeRadialOverlap: removeRadialOverlap, convexhull: Ub, circlePack: function (t) { var I = t.X, L = t.Y, N = t.R, k = t.center, e = t.maxSteps, i = void 0 === e ? 1e3 : e, n = t.padding, O = void 0 === n ? 5 : n, r = t.epsilon, o = void 0 === r ? 1e-5 : r, s = t.damping, F = void 0 === s ? 2 : s, R = t.pinned, a = t.indexes, u = t.onUpdate, l = t.pushSmallerOut, P = void 0 === l || l, D = a ? a.length : I.length, z = a; if (isFinite(R) || (R = -1), void 0 === z) { z = new Uint32Array(D); for (var d = 0; d < D; d++)z[d] = d } else z = a; if (-1 !== R) k = [I[R], L[R]]; else if (!k) { var h = 0, c = 0; for (d = 0; d < D; d++)h += I[z[d]], c += L[z[d]]; k = [h / D, c / D] } var f = function (t, e) { for (var i = 1 / 0, n = -1 / 0, r = 0; r < t.length; r++) { var o = t[r], s = e ? e[o] : o; i = Math.min(s, i), n = Math.max(s, n) } return { min: i, max: n } }(z, N), B = f.min, U = f.max; function g(t, e) { for (var i = 0, n = 0; n < D - 1; n++)for (var r = n + 1; r < D; r++)if (n !== r) { var o = z[n], s = z[r], a = I[o], u = L[o], l = N[o], d = I[s], h = L[s], c = N[s], f = d - a, g = h - u, p = f * f + g * g; if (p < (E = l + c + O) * E - t) { var _ = (E - Math.sqrt(p)) * e, v = 1 / p, m = (A = f * v * _) * A + (S = g * v * _) * S; if (s !== R) i += m * (C = l / B), I[s] += A * C, L[s] += S * C; if (o !== R) i += m * (C = c / B), I[o] -= A * C, L[o] -= S * C } } var y = t * F * (1 - e), b = k[0], x = k[1]; for (n = 0; n < D; n++) { if ((o = z[n]) !== R) { var E, A, S, w = I[o], T = L[o], C = (E = N[o]) / U, M = P ? y * C : y; i += m = (A = (w - b) * M) * A + (S = (T - x) * M) * S, I[o] -= A, L[o] -= S } } return i } z.sort(function (t, e) { return N[e] * NA(I[e], L[e], k) - N[t] * NA(I[t], L[t], k) }); var p = 0, _ = 0, v = LA(1 / D); for (d = 0; d < i && (p = g(v, LA((d + 1) / i)), u && setTimeout(function () { return u(I, L) }), !(Math.abs(p - _) < o)); d++)_ = p; return { X: I, Y: L } }, Quadtree: Tp, weightedStress: weightedStress, distanceStress: distanceStress, constrainedStress: constrainedStress, stressMinimizationStep: stressMinimizationStep, stressMinimizationStepGeneral: function (t, e, i, n, r, o, s, a) { s = s || 0; var u, l = e, d = i; -1 === (r = void 0 === r ? -1 : r) && (s = 0); for (var h = 0; h < n; h++) { for (var c = a[h], f = 0, g = 0, p = 0, _ = e[c], v = i[c], m = 0; m < n; m++) { var y = a[m], b = void 0; if (y !== c) { var x = 0, E = t[c][y] * o, A = 1 / (E * E); c !== r && y !== r || (x = A); var S = (1 - s) * A + s * x; if (f += S, 0 != A) { var w = e[y], T = i[y], C = _ - w, M = v - T, I = C * C + M * M; 1e-6 < I && (b = 1 / Math.sqrt(I)), g += S * (w + E * (_ - w) * b), p += S * (T + E * (v - T) * b) } } } 0 !== (u = f) && (l[c] = g / u, d[c] = p / u) } return { x: l, y: d } }, detectCyclesUndirected: function (t, e, i, n) { void 0 === n && (n = !1); for (var r, o, s, a, u = new Int32Array(t.length), l = {}, d = 0; d < t.length; d++)u[d] = -1, l[t[d]] = d; for (d = 0; d < e.length; d++) { var h = l[e[d]], c = l[i[d]]; if (n && h === c) return !0; var f = xf(u, h), g = xf(u, c); if (f === g) return !0; o = g, void 0, s = xf(r = u, f), a = xf(r, o), r[s] = a } return !1 }, detectCyclesDirected: Af, detectCyclesUndirectedDFS: function (t, e, i) { for (var n = t.length, r = new Uint8Array(n), o = new Int32Array(n), s = {}, a = 0; a < n; a++)o[s[t[a]] = a] = -1; var u = bf(t, e, i, s, !0); for (a = 0; a < e.length; a++) { var l = s[e[a]], d = s[i[a]]; u[l] = u[l] || [], u[l].push(d) } for (a = 0; a < n; a++) { if (!r[a] && Sf(a, r, -1, o, u, [], t)) return !0 } return !1 }, CyclesFinder: wf }), FA = 1, Ogma = function () { function Ogma(t) { void 0 === t && (t = {}); var e = this; if (this.node = function (t) { return new Ji(t, e) }, this.edge = function (t) { return new Fi(t, e) }, this.nodeList = function (t) { return new tn(t || new Uint32Array(0), e) }, this.edgeList = function (t) { return new Pi(t || new Uint32Array(0), e) }, this._onReady = [], null == this || this.constructor !== Ogma) return new Ogma(t); this._init(t) } return Ogma.prototype._init = function (t) { var e = this; this._initParameters = t, this._debug = !!t.debug, this._token = FA++ , this.modules = new nm(this, t), jE.initNamespace(this), om.initNamespace(this), gy.initNamespace(this), Lb.initNamespace(this), Ny.initNamespace(this), LE.initNamespace(this), Mb.initNamespace(this), TA.initNamespace(this), XE.initNamespace(this), MA.initNamespace(this), kE.initNamespace(this), pm.initNamespace(this), HE.initNamespace(this), PE.initNamespace(this), Oy.initNamespace(this), FE.initNamespace(this), hm.initNamespace(this), this._onReady.forEach(function (t) { return t(e) }), this.safelyBindToInstance() }, Ogma.prototype.safelyBindToInstance = function () { for (var t = 0, e = Object.keys(Ogma.prototype); t < e.length; t++) { var i = e[t]; "function" == typeof Ogma.prototype[i] && (this[i] = this[i].bind(this)) } }, Ogma.prototype.onReady = function (t) { this._onReady.push(t) }, Ogma.prototype._destroy = function () { if (!this._token) throw new Error('"destroy" called twice on the same instance of Ogma'); this._onReady = [], this.modules.destroy(), this.modules = null }, Ogma.prototype.destroy = function () { this._destroy() }, Ogma.prototype.reset = function () { var t = this._initParameters; this._destroy(), this._init(t) }, Ogma.prototype.isDebug = function () { return this._debug }, Ogma.libraries = E, Ogma.build = { version: "2.9.3", commit: "673d5e4", date: "Wed Jan 08 2020 19:06:20 GMT+0100 (Central European Standard Time)" }, Ogma.geometry = kA, Ogma.algorithms = OA, Ogma.utils = Ho, Ogma }(), RA = [om, am, lm, hm, fm, pm, gy, Ny, Oy, Py, zy, Mb, Lb, LE, FE, zE, UE, jE, XE, TA, MA, kE, HE, PE]; return Object.assign.apply(Object, [Ogma.prototype].concat(RA.map(function (t) { return t.prototype }))), Ogma
});
//# sourceMappingURL=ogma.min.js.map
